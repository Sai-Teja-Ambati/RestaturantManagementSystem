<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/UMLDiagrams.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UMLDiagrams.md" />
              <option name="updatedContent" value="# UML Diagrams for Restaurant Management System&#10;&#10;## Entity-Relationship Diagram&#10;&#10;![ER Diagram](ERDiagram.png)&#10;&#10;## Class Diagram&#10;&#10;![Class Diagram](class_diagram.png)&#10;&#10;## Sequence Diagrams&#10;&#10;### Admin Sequence Diagram&#10;![Admin Sequence Diagram](admin_sequence_diagram.png)&#10;&#10;### Customer Sequence Diagram&#10;![Customer Sequence Diagram](customer_sequence_diagram.png)&#10;&#10;### Waiter Sequence Diagram&#10;![Waiter Sequence Diagram](waiter_sequence_diagram.png)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/cice.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cice.txt" />
              <option name="originalContent" value="# CICE - Continuous Integration Certification Environment&#10;&#10;## Executive Summary&#10;&#10;CICE is an Integrated Development Environment (IDE) extension designed to replicate the functionality of ROSE CI pipelines within the local development environment. It provides authentic real-time processing rather than mere mocking capabilities.&#10;&#10;This is not just mocking, this is 100% realtime processing.&#10;&#10;## Background and Purpose&#10;&#10;The Cluster Certification Environment (CCE) was established to validate functional test cases and simulations, ensuring applications meet operational requirements for production and demonstration environments. This proactive approach prevents critical outages and incidents.&#10;&#10;The primary objective is to guarantee application stability and reliability in production and pre-production environments.&#10;&#10;While CCE focuses on risk mitigation, CICE's primary emphasis is on cost efficiency.&#10;&#10;## Technical Implementation&#10;&#10;### User Experience&#10;Users simply activate the extension within their IDE. The extension deploys a preconfigured Docker Compose environment containing all necessary software components.&#10;&#10;### Included Components&#10;- Multiple JDK versions&#10;- Snyk CLI integration&#10;- SonarQube server configuration&#10;- Additional development tools&#10;&#10;### Practical Application Example&#10;When encountering a specific error scenario (such as a 403 Forbidden error that occurs when attempting to publish an already existing version), JFrog would typically reject the upload with an error response. CICE preemptively identifies such condition and prevents the gitrepo from even initializing the pipeline.&#10;&#10;### Validation Workflow&#10;The extension performs comprehensive checks including:&#10;- JFrog version compatibility based on POM configuration&#10;- Compilation verification&#10;- Security scanning via Snyk&#10;- Code quality analysis through SonarQube&#10;- Pre-commit hook validation&#10;- Local verification mirroring CI environment behaviors&#10;&#10;Recommendations for improvements are provided directly within the development environment.&#10;&#10;### Detailed Validation Process&#10;After activation, the extension performs a series of validations:&#10;1. It checks the JFrog latest version based upon POM configuration&#10;2. If version compatibility is confirmed, it returns an &quot;OK&quot; status&#10;3. It performs compilation verification once to ensure build integrity&#10;4. It conducts security scans using Snyk&#10;5. It executes SonarQube analysis for code quality assessment&#10;6. It verifies pre-commit hooks and compilation issues locally&#10;7. All these validations occur in a CIA-powered environment&#10;8. Changes and improvements are suggested directly within the IDE environment&#10;&#10;### CIA Integration&#10;All validations take place in a CIA-powered environment (Continuous Integration Agent v1.3.0). CIA revolutionizes build failure resolution through:&#10;&#10;- AI-powered analysis of build failures in continuous integration pipelines&#10;- Automatic log analysis when CI builds fail&#10;- Root cause identification for failures&#10;- Provision of feasible solutions to developers via Microsoft Teams&#10;- Rapid response time (within 4 minutes of failure detection)&#10;&#10;This integration ensures that developers receive immediate, actionable feedback on potential issues before they even reach the CI pipeline, further reducing development cycle time and improving code quality.&#10;&#10;## Security and Access Control&#10;&#10;A secured encrypted file (secret.txt.gpg) contains a simple pass/fail designation. If a repository's secret file contains a fail status, the Jenkins build request is automatically rejected in the ROSE CI pipeline.&#10;&#10;## Business Value&#10;&#10;This solution addresses significant efficiency concerns. For repositories such as ledger and upi-psp that require more than an hour to build artifacts, failed builds represent substantial developer time wastage. CICE prevents these productivity losses through early detection of issues.&#10;" />
              <option name="updatedContent" value="h1. CICE - Continuous Integration Certification Environment&#10;&#10;h2. Executive Summary&#10;&#10;CICE is an Integrated Development Environment (IDE) extension designed to replicate the functionality of ROSE CI pipelines within the local development environment. It provides authentic real-time processing rather than mere mocking capabilities.&#10;&#10;This is not just mocking, this is 100% realtime processing.&#10;&#10;h2. Background and Purpose&#10;&#10;The Cluster Certification Environment (CCE) was established to validate functional test cases and simulations, ensuring applications meet operational requirements for production and demonstration environments. This proactive approach prevents critical outages and incidents.&#10;&#10;The primary objective is to guarantee application stability and reliability in production and pre-production environments.&#10;&#10;While CCE focuses on risk mitigation, CICE's primary emphasis is on cost efficiency.&#10;&#10;h2. Technical Implementation&#10;&#10;h3. User Experience&#10;Users simply activate the extension within their IDE. The extension deploys a preconfigured Docker Compose environment containing all necessary software components.&#10;&#10;h3. Included Components&#10;* Multiple JDK versions&#10;* Snyk CLI integration&#10;* SonarQube server configuration&#10;* Additional development tools&#10;&#10;h3. Practical Application Example&#10;When encountering a specific error scenario (such as a 403 Forbidden error that occurs when attempting to publish an already existing version), JFrog would typically reject the upload with an error response. CICE preemptively identifies such condition and prevents the gitrepo from even initializing the pipeline.&#10;&#10;h3. Validation Workflow&#10;The extension performs comprehensive checks including:&#10;* JFrog version compatibility based on POM configuration&#10;* Compilation verification&#10;* Security scanning via Snyk&#10;* Code quality analysis through SonarQube&#10;* Pre-commit hook validation&#10;* Local verification mirroring CI environment behaviors&#10;&#10;Recommendations for improvements are provided directly within the development environment.&#10;&#10;h3. Detailed Validation Process&#10;After activation, the extension performs a series of validations:&#10;# It checks the JFrog latest version based upon POM configuration&#10;# If version compatibility is confirmed, it returns an &quot;OK&quot; status&#10;# It performs compilation verification once to ensure build integrity&#10;# It conducts security scans using Snyk&#10;# It executes SonarQube analysis for code quality assessment&#10;# It verifies pre-commit hooks and compilation issues locally&#10;# All these validations occur in a CIA-powered environment&#10;# Changes and improvements are suggested directly within the IDE environment&#10;&#10;h3. CIA Integration&#10;All validations take place in a CIA-powered environment (Continuous Integration Agent v1.3.0). CIA revolutionizes build failure resolution through:&#10;&#10;* AI-powered analysis of build failures in continuous integration pipelines&#10;* Automatic log analysis when CI builds fail&#10;* Root cause identification for failures&#10;* Provision of feasible solutions to developers via Microsoft Teams&#10;* Rapid response time (within 4 minutes of failure detection)&#10;&#10;This integration ensures that developers receive immediate, actionable feedback on potential issues before they even reach the CI pipeline, further reducing development cycle time and improving code quality.&#10;&#10;h3. Required Software Components&#10;Based on analysis of the mavendockerpublish pipeline, the following software components are required for local compilation:&#10;&#10;* *Java Development Kit (JDK)* - Multiple versions including JDK 8 and newer versions&#10;* *Maven* - For building Java applications and running tests&#10;* *Docker* - For containerizing applications and building/publishing images&#10;* *Security Scanning Tools:*&#10;** Snyk CLI - For SCA (Software Composition Analysis), SAST (Static Application Security Testing), and container image scanning&#10;** ClamAV - For malware scanning&#10;** GitLeaks - For secret detection in code&#10;* *Code Quality Tools:*&#10;** SonarQube - For code quality and SAST analysis&#10;* *Artifact Repository Access:*&#10;** JFrog/Artifactory CLI - For checking versions and publishing artifacts&#10;** ECR (Amazon Elastic Container Registry) access tools&#10;* *Image Signing:*&#10;** Cosign - For signing container images&#10;* *PostgreSQL Database* - For certain stages that require database connectivity&#10;* *Git* - For source code management&#10;* *Additional Pipeline Components:*&#10;** FreshClam DB - For ClamAV database updates&#10;** Helm - For Kubernetes chart publication&#10;** OpenAPI tools - For API specification publication&#10;&#10;h2. Security and Access Control&#10;&#10;A secured encrypted file (secret.txt.gpg) contains a simple pass/fail designation. If a repository's secret file contains a fail status, the Jenkins build request is automatically rejected in the ROSE CI pipeline.&#10;&#10;h2. Business Value&#10;&#10;This solution addresses significant efficiency concerns. For repositories such as ledger and upi-psp that require more than an hour to build artifacts, failed builds represent substantial developer time wastage. CICE prevents these productivity losses through early detection of issues." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/cice_complete_workflow.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cice_complete_workflow.txt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/cice_flowchart.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cice_flowchart.txt" />
              <option name="updatedContent" value="```mermaid&#10;flowchart TD&#10;    A[IDE Extension Activation] --&gt; B{Docker Compose Environment Setup}&#10;    B --&gt; C[Load Required Components]&#10;    &#10;    C --&gt; C1[JDK Versions 8+]&#10;    C --&gt; C2[Maven]&#10;    C --&gt; C3[Docker]&#10;    C --&gt; C4[Snyk CLI]&#10;    C --&gt; C5[SonarQube]&#10;    C --&gt; C6[ClamAV + FreshClam]&#10;    C --&gt; C7[GitLeaks]&#10;    C --&gt; C8[JFrog/Artifactory CLI]&#10;    C --&gt; C9[ECR Tools]&#10;    C --&gt; C10[Cosign]&#10;    C --&gt; C11[PostgreSQL DB]&#10;    C --&gt; C12[Git]&#10;    C --&gt; C13[Helm]&#10;    C --&gt; C14[OpenAPI Tools]&#10;    &#10;    C --&gt; D[CIA Agent Integration v1.3.0]&#10;    D --&gt; E[Project Analysis]&#10;    &#10;    E --&gt; F[Code Repository Analysis]&#10;    E --&gt; G[POM Configuration Analysis]&#10;    E --&gt; H[Docker Configuration Analysis]&#10;    &#10;    F --&gt; I[Pre-commit Hook Validation]&#10;    G --&gt; J[JFrog Version Compatibility Check]&#10;    H --&gt; K[Image Build Validation]&#10;    &#10;    I --&gt; L[Validation Results]&#10;    J --&gt; L&#10;    K --&gt; L&#10;    &#10;    L --&gt; M{All Validations Passed?}&#10;    &#10;    M --&gt;|No| N[Identify Issues]&#10;    N --&gt; O[AI-Powered Analysis]&#10;    O --&gt; P[Generate Solutions]&#10;    P --&gt; Q[Present in IDE]&#10;    Q --&gt; R[Developer Fixes Issues]&#10;    R --&gt; E&#10;    &#10;    M --&gt;|Yes| S[Validation Complete]&#10;    &#10;    S --&gt; T{Publish Reports?}&#10;    T --&gt;|Yes| U[Generate Timestamped Reports]&#10;    U --&gt; V[Create Secure Files]&#10;    V --&gt; W[Upload to JFrog Secure Directory]&#10;    W --&gt; X[Update secret.txt.gpg]&#10;    &#10;    T --&gt;|No| Y[Local Validation Complete]&#10;    X --&gt; Y&#10;    &#10;    Y --&gt; Z[Ready for CI Pipeline]&#10;    Z --&gt; AA[Time and Resource Savings]&#10;    &#10;    %% Style definitions&#10;    classDef startNode fill:#90CAF9,stroke:#1565C0,stroke-width:2px&#10;    classDef successNode fill:#A5D6A7,stroke:#2E7D32,stroke-width:2px&#10;    classDef warningNode fill:#FFCC80,stroke:#EF6C00,stroke-width:2px&#10;    classDef securityNode fill:#CE93D8,stroke:#7B1FA2,stroke-width:2px&#10;    classDef endNode fill:#81C784,stroke:#2E7D32,stroke-width:2px&#10;    &#10;    %% Apply styles&#10;    class A startNode&#10;    class S,Y successNode&#10;    class N,O warningNode&#10;    class W,V securityNode&#10;    class AA endNode&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/001_create_migrations_table.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/001_create_migrations_table.sql" />
              <option name="originalContent" value="-- Migration: Create migrations table&#10;CREATE TABLE IF NOT EXISTS migrations (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', 'admin123', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '12345678', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', 'customer1', 'customer')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Migration: Create orders table&#10;CREATE TABLE IF NOT EXISTS orders (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id VARCHAR(50) NOT NULL UNIQUE,&#10;    customer_id BIGINT REFERENCES users(id),&#10;    order_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    items JSONB NOT NULL, -- Stores food items and their prices as JSON&#10;    bill_subtotal NUMERIC(10, 2) NOT NULL,&#10;    cgst_sgst NUMERIC(10, 2) DEFAULT 0, -- Combined CGST and SGST charges&#10;    service_charge NUMERIC(10, 2) DEFAULT 0,&#10;    bill_total NUMERIC(10, 2) NOT NULL,&#10;    payment_status VARCHAR(20) DEFAULT 'PENDING',&#10;    order_status VARCHAR(20) DEFAULT 'PENDING',&#10;    table_number INT,&#10;    special_instructions TEXT&#10;);&#10;&#10;-- Create index on order_id for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_order_id ON orders (order_id);&#10;&#10;-- Create index on customer_id for faster customer order lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders (customer_id);&#10;&#10;-- Create trigger function to automatically calculate CGST and SGST charges&#10;CREATE OR REPLACE FUNCTION calculate_taxes_and_total()&#10;RETURNS TRIGGER AS $$&#10;BEGIN&#10;    -- Calculate service charge (2%)&#10;    NEW.service_charge = ROUND(NEW.bill_subtotal * 0.02, 2);&#10;&#10;    -- Add CGST and SGST charges (fixed Rs.25 if bill &gt; 150)&#10;    IF NEW.bill_subtotal &gt; 150 THEN&#10;        NEW.cgst_sgst = 25.00;&#10;    ELSE&#10;        NEW.cgst_sgst = 0.00;&#10;    END IF;&#10;&#10;    -- Calculate total bill&#10;    NEW.bill_total = NEW.bill_subtotal + NEW.service_charge + NEW.cgst_sgst;&#10;&#10;    RETURN NEW;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;-- Create trigger to automatically calculate taxes and total before insert&#10;DO $$&#10;BEGIN&#10;    IF NOT EXISTS (&#10;        SELECT 1 FROM pg_trigger&#10;        WHERE tgname = 'calculate_order_totals'&#10;    ) THEN&#10;        CREATE TRIGGER calculate_order_totals&#10;        BEFORE INSERT OR UPDATE ON orders&#10;        FOR EACH ROW&#10;        EXECUTE FUNCTION calculate_taxes_and_total();&#10;    END IF;&#10;END $$;&#10;&#10;INSERT INTO orders (order_id, customer_id, items, bill_subtotal)&#10;VALUES (&#10;    'ORD-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8),&#10;    (SELECT id FROM users WHERE email = 'customer1@example.com' LIMIT 1),&#10;    '[&#10;        {&quot;category&quot;: &quot;Veg Starters&quot;, &quot;itemName&quot;: &quot;Paneer Tikka&quot;, &quot;price&quot;: 249, &quot;quantity&quot;: 1},&#10;        {&quot;category&quot;: &quot;Indian Breads&quot;, &quot;itemName&quot;: &quot;Butter Naan&quot;, &quot;price&quot;: 50, &quot;quantity&quot;: 2}&#10;    ]'::JSONB,&#10;    349.00&#10;);&#10;&#10;-- Create tables table for tracking restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    capacity INT NOT NULL DEFAULT 4,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    is_served BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);&#10;&#10;-- Migration: Create table_reservations table&#10;CREATE TABLE IF NOT EXISTS table_reservations (&#10;    id SERIAL PRIMARY KEY,&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    customer_id BIGINT NOT NULL REFERENCES users(id),&#10;    reservation_time TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    status VARCHAR(20) NOT NULL DEFAULT 'active',&#10;    notes TEXT&#10;);&#10;&#10;-- Create indexes for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_table_reservations_table_id ON table_reservations(table_id);&#10;CREATE INDEX IF NOT EXISTS idx_table_reservations_customer_id ON table_reservations(customer_id);&#10;&#10;-- Migration: Create tables table for restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT NOT NULL UNIQUE,&#10;    capacity INT NOT NULL DEFAULT 4,&#10;    is_occupied BOOLEAN NOT NULL DEFAULT FALSE,&#10;    is_served BOOLEAN NOT NULL DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create index for faster lookups by table_number&#10;CREATE INDEX IF NOT EXISTS idx_tables_table_number ON tables(table_number);&#10;&#10;-- Insert 12 restaurant tables with various capacities&#10;INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;VALUES&#10;    (1, 2, FALSE, FALSE),  -- Table 1: Small table for two&#10;    (2, 4, FALSE, FALSE),  -- Table 2: Standard 4-person table&#10;    (3, 4, FALSE, FALSE),  -- Table 3: Standard 4-person table&#10;    (4, 6, FALSE, FALSE),  -- Table 4: Larger 6-person table&#10;    (5, 4, FALSE, FALSE),  -- Table 5: Standard 4-person table&#10;    (6, 8, FALSE, FALSE),  -- Table 6: Large group table&#10;    (7, 2, FALSE, FALSE),  -- Table 7: Small table for two&#10;    (8, 4, FALSE, FALSE),  -- Table 8: Standard 4-person table&#10;    (9, 4, FALSE, FALSE),  -- Table 9: Standard 4-person table&#10;    (10, 6, FALSE, FALSE), -- Table 10: Larger 6-person table&#10;    (11, 10, FALSE, FALSE), -- Table 11: Very large group table&#10;    (12, 4, FALSE, FALSE); -- Table 12: Standard 4-person table&#10;&#10;-- Update table_reservations to include start_time and end_time&#10;ALTER TABLE table_reservations&#10;ADD COLUMN IF NOT EXISTS table_number INT,&#10;ADD COLUMN IF NOT EXISTS start_time TIMESTAMP,&#10;ADD COLUMN IF NOT EXISTS end_time TIMESTAMP;&#10;&#10;-- Set default value for table_number based on table_id&#10;UPDATE table_reservations tr&#10;SET table_number = t.table_number&#10;FROM tables t&#10;WHERE tr.table_id = t.id&#10;AND tr.table_number IS NULL;&#10;&#10;-- Add NOT NULL constraint after data migration&#10;ALTER TABLE table_reservations&#10;ALTER COLUMN table_number SET NOT NULL;&#10;&#10;-- Create index for faster lookups by table_number in reservations&#10;CREATE INDEX IF NOT EXISTS idx_table_reservations_table_number ON table_reservations(table_number);&#10;" />
              <option name="updatedContent" value="-- Migration: Create migrations table&#10;CREATE TABLE IF NOT EXISTS migrations (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', 'admin123', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '12345678', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', 'customer1', 'customer')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Migration: Create orders table&#10;CREATE TABLE IF NOT EXISTS orders (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id VARCHAR(50) NOT NULL UNIQUE,&#10;    customer_id BIGINT REFERENCES users(id),&#10;    order_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    items JSONB NOT NULL, -- Stores food items and their prices as JSON&#10;    bill_subtotal NUMERIC(10, 2) NOT NULL,&#10;    cgst_sgst NUMERIC(10, 2) DEFAULT 0, -- Combined CGST and SGST charges&#10;    service_charge NUMERIC(10, 2) DEFAULT 0,&#10;    bill_total NUMERIC(10, 2) NOT NULL,&#10;    payment_status VARCHAR(20) DEFAULT 'PENDING',&#10;    order_status VARCHAR(20) DEFAULT 'PENDING',&#10;    table_number INT,&#10;    special_instructions TEXT&#10;);&#10;&#10;-- Create index on order_id for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_order_id ON orders (order_id);&#10;&#10;-- Create index on customer_id for faster customer order lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders (customer_id);&#10;&#10;-- Create trigger function to automatically calculate CGST and SGST charges&#10;CREATE OR REPLACE FUNCTION calculate_taxes_and_total()&#10;RETURNS TRIGGER AS $$&#10;BEGIN&#10;    -- Calculate service charge (2%)&#10;    NEW.service_charge = ROUND(NEW.bill_subtotal * 0.02, 2);&#10;&#10;    -- Add CGST and SGST charges (fixed Rs.25 if bill &gt; 150)&#10;    IF NEW.bill_subtotal &gt; 150 THEN&#10;        NEW.cgst_sgst = 25.00;&#10;    ELSE&#10;        NEW.cgst_sgst = 0.00;&#10;    END IF;&#10;&#10;    -- Calculate total bill&#10;    NEW.bill_total = NEW.bill_subtotal + NEW.service_charge + NEW.cgst_sgst;&#10;&#10;    RETURN NEW;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;-- Create trigger to automatically calculate taxes and total before insert&#10;DO $$&#10;BEGIN&#10;    IF NOT EXISTS (&#10;        SELECT 1 FROM pg_trigger&#10;        WHERE tgname = 'calculate_order_totals'&#10;    ) THEN&#10;        CREATE TRIGGER calculate_order_totals&#10;        BEFORE INSERT OR UPDATE ON orders&#10;        FOR EACH ROW&#10;        EXECUTE FUNCTION calculate_taxes_and_total();&#10;    END IF;&#10;END $$;&#10;&#10;-- Insert a sample order, but only if it doesn't exist&#10;DO $$&#10;BEGIN&#10;    IF NOT EXISTS (SELECT 1 FROM orders WHERE items::text LIKE '%Paneer Tikka%') THEN&#10;        INSERT INTO orders (order_id, customer_id, items, bill_subtotal)&#10;        VALUES (&#10;            'ORD-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8),&#10;            (SELECT id FROM users WHERE email = 'customer1@example.com' LIMIT 1),&#10;            '[&#10;                {&quot;category&quot;: &quot;Veg Starters&quot;, &quot;itemName&quot;: &quot;Paneer Tikka&quot;, &quot;price&quot;: 249, &quot;quantity&quot;: 1},&#10;                {&quot;category&quot;: &quot;Indian Breads&quot;, &quot;itemName&quot;: &quot;Butter Naan&quot;, &quot;price&quot;: 50, &quot;quantity&quot;: 2}&#10;            ]'::JSONB,&#10;            349.00&#10;        );&#10;    END IF;&#10;END $$;&#10;&#10;-- Create tables table for tracking restaurant tables with capacity column&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    capacity INT NOT NULL DEFAULT 4,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    is_served BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);&#10;&#10;-- Migration: Create table_reservations table&#10;CREATE TABLE IF NOT EXISTS table_reservations (&#10;    id SERIAL PRIMARY KEY,&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    customer_id BIGINT NOT NULL REFERENCES users(id),&#10;    reservation_time TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    status VARCHAR(20) NOT NULL DEFAULT 'active',&#10;    notes TEXT,&#10;    table_number INT,&#10;    start_time TIMESTAMP,&#10;    end_time TIMESTAMP&#10;);&#10;&#10;-- Create indexes for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_table_reservations_table_id ON table_reservations(table_id);&#10;CREATE INDEX IF NOT EXISTS idx_table_reservations_customer_id ON table_reservations(customer_id);&#10;CREATE INDEX IF NOT EXISTS idx_table_reservations_table_number ON table_reservations(table_number);&#10;&#10;-- Create index for faster lookups by table_number&#10;CREATE INDEX IF NOT EXISTS idx_tables_table_number ON tables(table_number);&#10;&#10;-- Insert restaurant tables with various capacities if they don't exist&#10;DO $$&#10;BEGIN&#10;    -- Table 1: Small table for two&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 1) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (1, 2, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 2: Standard 4-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 2) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (2, 4, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 3: Standard 4-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 3) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (3, 4, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 4: Larger 6-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 4) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (4, 6, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 5: Standard 4-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 5) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (5, 4, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 6: Large group table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 6) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (6, 8, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 7: Small table for two&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 7) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (7, 2, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 8: Standard 4-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 8) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (8, 4, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 9: Standard 4-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 9) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (9, 4, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 10: Larger 6-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 10) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (10, 6, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 11: Very large group table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 11) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (11, 10, FALSE, FALSE);&#10;    END IF;&#10;&#10;    -- Table 12: Standard 4-person table&#10;    IF NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 12) THEN&#10;        INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;        VALUES (12, 4, FALSE, FALSE);&#10;    END IF;&#10;END $$;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/002_create_users_table.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/002_create_users_table.sql" />
              <option name="originalContent" value="-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password: admin123)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', '$2a$10$kK7yXYZNNJ/3MQyK.Qwc6ekhDiwcldY7.5e4qlJUFpiiXIQxbeBJO', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password: 12345678 for all)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'customer')&#10;ON CONFLICT (email) DO NOTHING;&#10;" />
              <option name="updatedContent" value="-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', 'admin123', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '12345678', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', '12345678', 'customer')&#10;ON CONFLICT (email) DO NOTHING;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/003_create_orders_table.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/003_create_orders_table.sql" />
              <option name="updatedContent" value="-- Migration: Create orders table&#10;CREATE TABLE IF NOT EXISTS orders (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id VARCHAR(50) NOT NULL UNIQUE,&#10;    customer_id BIGINT REFERENCES users(id),&#10;    order_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    items JSONB NOT NULL, -- Stores food items and their prices as JSON&#10;    bill_subtotal NUMERIC(10, 2) NOT NULL,&#10;    cgst_sgst NUMERIC(10, 2) DEFAULT 0, -- Combined CGST and SGST charges&#10;    service_charge NUMERIC(10, 2) DEFAULT 0,&#10;    bill_total NUMERIC(10, 2) NOT NULL,&#10;    payment_status VARCHAR(20) DEFAULT 'PENDING',&#10;    order_status VARCHAR(20) DEFAULT 'PENDING',&#10;    table_number INT,&#10;    special_instructions TEXT&#10;);&#10;&#10;-- Create index on order_id for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_order_id ON orders (order_id);&#10;&#10;-- Create index on customer_id for faster customer order lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders (customer_id);&#10;&#10;-- Create trigger function to automatically calculate CGST and SGST charges&#10;CREATE OR REPLACE FUNCTION calculate_taxes_and_total()&#10;RETURNS TRIGGER AS $$&#10;BEGIN&#10;    -- Calculate service charge (2%)&#10;    NEW.service_charge = ROUND(NEW.bill_subtotal * 0.02, 2);&#10;    &#10;    -- Add CGST and SGST charges (fixed Rs.25 if bill &gt; 150)&#10;    IF NEW.bill_subtotal &gt; 150 THEN&#10;        NEW.cgst_sgst = 25.00;&#10;    ELSE&#10;        NEW.cgst_sgst = 0.00;&#10;    END IF;&#10;    &#10;    -- Calculate total bill&#10;    NEW.bill_total = NEW.bill_subtotal + NEW.service_charge + NEW.cgst_sgst;&#10;    &#10;    RETURN NEW;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;-- Create trigger to automatically calculate taxes and total before insert&#10;CREATE TRIGGER calculate_order_totals&#10;BEFORE INSERT OR UPDATE ON orders&#10;FOR EACH ROW&#10;EXECUTE FUNCTION calculate_taxes_and_total();&#10;&#10;-- Sample order for testing (optional)&#10;INSERT INTO orders (order_id, customer_id, items, bill_subtotal)&#10;VALUES (&#10;    'ORD-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8),&#10;    (SELECT id FROM users WHERE email = 'customer1@example.com' LIMIT 1),&#10;    '[&#10;        {&quot;category&quot;: &quot;Veg Starters&quot;, &quot;itemName&quot;: &quot;Paneer Tikka&quot;, &quot;price&quot;: 249, &quot;quantity&quot;: 1},&#10;        {&quot;category&quot;: &quot;Indian Breads&quot;, &quot;itemName&quot;: &quot;Butter Naan&quot;, &quot;price&quot;: 50, &quot;quantity&quot;: 2}&#10;    ]'::JSONB,&#10;    349.00&#10;);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/003_create_restaurant_tables.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/003_create_restaurant_tables.sql" />
              <option name="updatedContent" value="-- Migration: Create tables table for restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT NOT NULL UNIQUE,&#10;    capacity INT NOT NULL DEFAULT 4,&#10;    is_occupied BOOLEAN NOT NULL DEFAULT FALSE,&#10;    is_served BOOLEAN NOT NULL DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create index for faster lookups by table_number&#10;CREATE INDEX IF NOT EXISTS idx_tables_table_number ON tables(table_number);&#10;&#10;-- Insert 12 restaurant tables with various capacities&#10;INSERT INTO tables (table_number, capacity, is_occupied, is_served)&#10;VALUES &#10;    (1, 2, FALSE, FALSE),  -- Table 1: Small table for two&#10;    (2, 4, FALSE, FALSE),  -- Table 2: Standard 4-person table&#10;    (3, 4, FALSE, FALSE),  -- Table 3: Standard 4-person table&#10;    (4, 6, FALSE, FALSE),  -- Table 4: Larger 6-person table&#10;    (5, 4, FALSE, FALSE),  -- Table 5: Standard 4-person table&#10;    (6, 8, FALSE, FALSE),  -- Table 6: Large group table&#10;    (7, 2, FALSE, FALSE),  -- Table 7: Small table for two&#10;    (8, 4, FALSE, FALSE),  -- Table 8: Standard 4-person table&#10;    (9, 4, FALSE, FALSE),  -- Table 9: Standard 4-person table&#10;    (10, 6, FALSE, FALSE), -- Table 10: Larger 6-person table&#10;    (11, 10, FALSE, FALSE), -- Table 11: Very large group table&#10;    (12, 4, FALSE, FALSE); -- Table 12: Standard 4-person table&#10;&#10;-- Update table_reservations to include start_time and end_time&#10;ALTER TABLE table_reservations &#10;ADD COLUMN IF NOT EXISTS table_number INT,&#10;ADD COLUMN IF NOT EXISTS start_time TIMESTAMP,&#10;ADD COLUMN IF NOT EXISTS end_time TIMESTAMP;&#10;&#10;-- Set default value for table_number based on table_id&#10;UPDATE table_reservations tr&#10;SET table_number = t.table_number&#10;FROM tables t&#10;WHERE tr.table_id = t.id&#10;AND tr.table_number IS NULL;&#10;&#10;-- Add NOT NULL constraint after data migration&#10;ALTER TABLE table_reservations&#10;ALTER COLUMN table_number SET NOT NULL;&#10;&#10;-- Create index for faster lookups by table_number in reservations&#10;CREATE INDEX IF NOT EXISTS idx_table_reservations_table_number ON table_reservations(table_number);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/004_insert_restaurant_tables.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/004_insert_restaurant_tables.sql" />
              <option name="updatedContent" value="-- Insert tables for the restaurant (if they don't already exist)&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 1, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 1);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 2, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 2);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 3, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 3);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 4, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 4);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 5, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 5);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 6, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 6);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 7, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 7);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 8, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 8);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 9, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 9);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 10, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 10);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 11, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 11);&#10;&#10;INSERT INTO tables (table_number, is_occupied, is_served) &#10;SELECT 12, FALSE, FALSE&#10;WHERE NOT EXISTS (SELECT 1 FROM tables WHERE table_number = 12);&#10;&#10;-- Verify tables were inserted&#10;SELECT * FROM tables ORDER BY table_number;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/005_create_tables.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/005_create_tables.sql" />
              <option name="originalContent" value="-- Create tables table for tracking restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);&#10;" />
              <option name="updatedContent" value="-- Create tables table for tracking restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    is_served BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/Main.java" />
              <option name="originalContent" value="package zeta.foods;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.AdminService;&#10;import zeta.foods.service.AuthService;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.service.WaiterService;&#10;import zeta.foods.service.impl.AdminServiceImpl;&#10;import zeta.foods.service.impl.CustomerServiceImpl;&#10;import zeta.foods.service.impl.PostgresAuthServiceImpl;&#10;import zeta.foods.service.impl.WaiterServiceImpl;&#10;import zeta.foods.simulation.AuthSimulation;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.Map;&#10;import java.util.Scanner;&#10;import java.util.TreeMap;&#10;&#10;public class Main {&#10;    private static final Logger logger = LoggerFactory.getLogger(Main.class);&#10;    private static AuthService authService;&#10;    private static CustomerService customerService;&#10;    private static AdminService adminService;&#10;    private static WaiterService waiterService;&#10;&#10;    // Banner to display on startup&#10;    private static final String BANNER =&#10;        &quot;\n&quot; +&#10;        &quot; ╔═══════════════════════════════════════════════════════════════╗\n&quot; +&#10;        &quot; ║                                                               ║\n&quot; +&#10;        &quot; ║    ███████╗███████╗ ██████╗  ██████╗ ██████╗ ███████╗         ║\n&quot; +&#10;        &quot; ║    ╚══███╔╝██╔════╝██╔═══██╗██╔═══██╗██╔══██╗██╔════╝         ║\n&quot; +&#10;        &quot; ║      ███╔╝ █████╗  ██║   ██║██║   ██║██║  ██║███████╗         ║\n&quot; +&#10;        &quot; ║     ███╔╝  ██╔══╝  ██║   ██║██║   ██║██║  ██║╚════██║         ║\n&quot; +&#10;        &quot; ║    ███████╗██║     ╚██████╔╝╚██████╔╝██████╔╝███████║         ║\n&quot; +&#10;        &quot; ║    ╚══════╝╚═╝      ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝         ║\n&quot; +&#10;        &quot; ║                                                               ║\n&quot; +&#10;        &quot; ║                  RESTAURANT MANAGEMENT SYSTEM                 ║\n&quot; +&#10;        &quot; ║                                                               ║\n&quot; +&#10;        &quot; ╚═══════════════════════════════════════════════════════════════╝\n&quot;;&#10;&#10;    public static void main(String[] args) {&#10;        logger.info(BANNER);&#10;&#10;        logger.info(&quot;Starting Restaurant Management System...&quot;);&#10;&#10;        try {&#10;            // Print database connection info&#10;            String dbHost = System.getenv().getOrDefault(&quot;DB_HOST&quot;, &quot;localhost&quot;);&#10;            String dbPort = System.getenv().getOrDefault(&quot;DB_PORT&quot;, &quot;5432&quot;);&#10;            String dbName = System.getenv().getOrDefault(&quot;DB_NAME&quot;, &quot;restaurant_management&quot;);&#10;&#10;            // Check for simulation mode from command line or environment&#10;            boolean simulationMode = Boolean.parseBoolean(System.getenv().getOrDefault(&quot;SIMULATION_MODE&quot;, &quot;false&quot;));&#10;            if (args.length &gt; 0 &amp;&amp; &quot;simulate&quot;.equalsIgnoreCase(args[0])) {&#10;                simulationMode = true;&#10;            }&#10;&#10;            // Test database connection&#10;            DatabaseUtil.getConnection();&#10;            logger.info(&quot;Database connection successful&quot;);&#10;&#10;            // Initialize services&#10;            authService = new PostgresAuthServiceImpl();&#10;            customerService = new CustomerServiceImpl();&#10;            adminService = new AdminServiceImpl();&#10;            waiterService = new WaiterServiceImpl();&#10;            logger.info(&quot;Services initialized&quot;);&#10;&#10;            // Run simulation or interactive mode&#10;            if (simulationMode) {&#10;                runSimulation();&#10;            } else {&#10;                startLoginProcess();&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to start Restaurant Management System&quot;, e);&#10;            System.exit(1);&#10;        }&#10;    }&#10;&#10;    private static void runSimulation() {&#10;        logger.info(&quot;=== Starting Authentication Simulation Mode ===&quot;);&#10;        AuthSimulation simulation = new AuthSimulation(authService);&#10;        simulation.runLoginSimulation();&#10;&#10;        // Close database connection when finished&#10;        DatabaseUtil.closeConnection();&#10;        logger.info(&quot;Simulation completed. Exiting application.&quot;);&#10;    }&#10;&#10;    private static void startLoginProcess() {&#10;        logger.info(&quot;=== Restaurant Management System Login ===&quot;);&#10;        logger.info(&quot;Type 'exit' to quit the application&quot;);&#10;&#10;        try {&#10;            // Use the enhanced console login method which is more reliable in Docker&#10;            PostgresAuthServiceImpl authServiceImpl = (PostgresAuthServiceImpl) authService;&#10;            User user = authServiceImpl.consoleLogin();&#10;&#10;            if (user == null) {&#10;                // Check if simulation was requested through the console login&#10;                if (&quot;simulate&quot;.equalsIgnoreCase(System.getenv().getOrDefault(&quot;LAST_COMMAND&quot;, &quot;&quot;))) {&#10;                    runSimulation();&#10;                }&#10;            }&#10;&#10;            // Keep application running until user selects exit&#10;            Scanner scanner = new Scanner(System.in);&#10;            boolean running = user != null;&#10;&#10;            while (running) {&#10;                String input = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(input) || &quot;exit&quot;.equalsIgnoreCase(input)) {&#10;                    logger.info(&quot;Logging out and exiting application&quot;);&#10;                    running = false;&#10;                } else {&#10;                    // Handle menu selection based on user role&#10;                    logger.info(&quot;Selected option: {}&quot;, input);&#10;&#10;                    if (user.getRole().equalsIgnoreCase(&quot;customer&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                customerService.displayRestaurantMenu(scanner);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                processOrderPlacement(user, scanner);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                viewOrderStatus(user, scanner);&#10;                                break;&#10;                            case &quot;4&quot;:&#10;                                bookTableForCustomer(user, scanner);&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else if (user.getRole().equalsIgnoreCase(&quot;waiter&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                takeNewOrderAsWaiter(scanner);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                checkUnservedTables();&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else if (user.getRole().equalsIgnoreCase(&quot;admin&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                System.out.println(&quot;Manage Users - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                System.out.println(&quot;View System Reports - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                fetchCurrentInventory();&#10;                                break;&#10;                            case &quot;4&quot;:&#10;                                restoreCurrentInventory();&#10;                                break;&#10;                            case &quot;5&quot;:&#10;                                System.out.println(&quot;Manage Menu Items - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else {&#10;                        System.out.println(&quot;Processing your request...&quot;);&#10;                        System.out.println(&quot;Feature will be implemented in future updates.&quot;);&#10;                    }&#10;&#10;                    System.out.print(&quot;Enter another option (0 to exit): &quot;);&#10;                }&#10;            }&#10;&#10;            scanner.close();&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during login process: {}&quot;, e.getMessage(), e);&#10;        } finally {&#10;            // Close database connection when app exits&#10;            DatabaseUtil.closeConnection();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Process order placement for a customer&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void processOrderPlacement(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== Place New Order ===&quot;);&#10;&#10;        // Create a new order for the customer&#10;        Order order = customerService.placeOrder(user);&#10;        System.out.println(&quot;Order created! Order ID: &quot; + order.getOrderId());&#10;&#10;        boolean addingItems = true;&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;&#10;        while (addingItems) {&#10;            // Display menu categories&#10;            System.out.println(&quot;\nMenu Categories:&quot;);&#10;            TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;            String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;            for (int i = 0; i &lt; categories.length; i++) {&#10;                System.out.printf(&quot;%d. %s\n&quot;, i + 1, categories[i]);&#10;            }&#10;&#10;            System.out.print(&quot;\nSelect category (0 to finish order): &quot;);&#10;            String categoryInput = scanner.nextLine().trim();&#10;&#10;            if (&quot;0&quot;.equals(categoryInput)) {&#10;                addingItems = false;&#10;                continue;&#10;            }&#10;&#10;            try {&#10;                int categoryIndex = Integer.parseInt(categoryInput) - 1;&#10;                if (categoryIndex &lt; 0 || categoryIndex &gt;= categories.length) {&#10;                    System.out.println(&quot;Invalid category selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedCategory = categories[categoryIndex];&#10;                Map&lt;String, String&gt; items = menu.getCategoryItems(selectedCategory);&#10;&#10;                // Display items in the selected category&#10;                System.out.println(&quot;\n--- &quot; + selectedCategory + &quot; ---&quot;);&#10;                String[] itemNames = items.keySet().toArray(new String[0]);&#10;                for (int i = 0; i &lt; itemNames.length; i++) {&#10;                    System.out.printf(&quot;%d. %s - %s\n&quot;, i + 1, itemNames[i], items.get(itemNames[i]));&#10;                }&#10;&#10;                System.out.print(&quot;\nSelect item (0 to go back): &quot;);&#10;                String itemInput = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(itemInput)) {&#10;                    continue;&#10;                }&#10;&#10;                int itemIndex = Integer.parseInt(itemInput) - 1;&#10;                if (itemIndex &lt; 0 || itemIndex &gt;= itemNames.length) {&#10;                    System.out.println(&quot;Invalid item selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedItem = itemNames[itemIndex];&#10;&#10;                System.out.print(&quot;Enter quantity: &quot;);&#10;                int quantity = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (quantity &lt;= 0) {&#10;                    System.out.println(&quot;Quantity must be greater than zero.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Add item to order&#10;                boolean success = customerServiceImpl.addItemToOrder(order.getOrderId(), selectedCategory, selectedItem, quantity);&#10;                if (success) {&#10;                    System.out.println(quantity + &quot; x &quot; + selectedItem + &quot; added to your order.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Failed to add item to order.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Check if order has items&#10;        if (order.getItems().isEmpty()) {&#10;            System.out.println(&quot;Order cancelled - no items added.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Generate and display bill&#10;        System.out.println(&quot;\nGenerating your bill...&quot;);&#10;        String bill = customerServiceImpl.generateBill(order.getOrderId());&#10;        System.out.println(bill);&#10;&#10;        System.out.println(&quot;Thank you for your order!&quot;);&#10;    }&#10;&#10;&#10;    /**&#10;     * View the status of previous orders&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void viewOrderStatus(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== View Order Status ===&quot;);&#10;&#10;        // Retrieve and display user's order history&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;        customerServiceImpl.viewOrderStatus(user);&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Fetch and display the current inventory&#10;     */&#10;    private static void fetchCurrentInventory() {&#10;        logger.info(&quot;Fetching current inventory data&quot;);&#10;        System.out.println(&quot;\n=== Current Inventory ===&quot;);&#10;&#10;        String inventoryData = adminService.fetchCurrentInventory();&#10;        System.out.println(inventoryData);&#10;&#10;        System.out.println(&quot;Current inventory data has been displayed.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Restore the current inventory from the main inventory&#10;     */&#10;    private static void restoreCurrentInventory() {&#10;        logger.info(&quot;Restoring current inventory from main inventory&quot;);&#10;        System.out.println(&quot;\n=== Restoring Inventory ===&quot;);&#10;&#10;        boolean success = adminService.restoreCurrentInventory();&#10;&#10;        if (success) {&#10;            System.out.println(&quot;Inventory has been successfully restored from the main inventory.&quot;);&#10;        } else {&#10;            System.out.println(&quot;Failed to restore inventory. Please check the logs for details.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Take a new order as a waiter&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void takeNewOrderAsWaiter(Scanner scanner) {&#10;        logger.info(&quot;Taking new order as waiter&quot;);&#10;&#10;        // Use the WaiterService to handle the order taking process&#10;        Order order = waiterService.takeNewOrder(scanner);&#10;&#10;        if (order != null) {&#10;            logger.info(&quot;Order #{} successfully created by waiter&quot;, order.getOrderId());&#10;            System.out.println(&quot;\nOrder #&quot; + order.getOrderId() + &quot; has been successfully created.&quot;);&#10;        } else {&#10;            logger.info(&quot;Order creation cancelled or failed&quot;);&#10;            System.out.println(&quot;\nOrder creation was cancelled or failed.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check and display unserved tables&#10;     */&#10;    private static void checkUnservedTables() {&#10;        logger.info(&quot;Checking unserved tables&quot;);&#10;        System.out.println(&quot;\n=== Unserved Tables ===&quot;);&#10;&#10;        // Use the WaiterService to fetch unserved tables&#10;        java.util.List&lt;zeta.foods.model.Table&gt; unservedTables = waiterService.getUnservedTables();&#10;&#10;        if (unservedTables != null &amp;&amp; !unservedTables.isEmpty()) {&#10;            System.out.println(&quot;Tables waiting to be served:&quot;);&#10;            for (zeta.foods.model.Table table : unservedTables) {&#10;                System.out.println(table.toString());&#10;            }&#10;            System.out.println(&quot;\nTotal unserved tables: &quot; + unservedTables.size());&#10;        } else {&#10;            System.out.println(&quot;All tables are currently served.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Book a table for the customer&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void bookTableForCustomer(User user, Scanner scanner) {&#10;        logger.info(&quot;Customer {} attempting to book a table&quot;, user.getUsername());&#10;        System.out.println(&quot;\n=== Book Table ===&quot;);&#10;&#10;        // Use the customer service to handle the table booking process&#10;        boolean success = customerService.bookTable(user, scanner);&#10;&#10;        if (success) {&#10;            logger.info(&quot;Table successfully booked for customer: {}&quot;, user.getUsername());&#10;        } else {&#10;            logger.info(&quot;Table booking failed or was cancelled for customer: {}&quot;, user.getUsername());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.AdminService;&#10;import zeta.foods.service.AuthService;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.service.WaiterService;&#10;import zeta.foods.service.impl.AdminServiceImpl;&#10;import zeta.foods.service.impl.CustomerServiceImpl;&#10;import zeta.foods.service.impl.PostgresAuthServiceImpl;&#10;import zeta.foods.service.impl.WaiterServiceImpl;&#10;import zeta.foods.simulation.AuthSimulation;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.Map;&#10;import java.util.Scanner;&#10;import java.util.TreeMap;&#10;&#10;public class Main {&#10;    private static final Logger logger = LoggerFactory.getLogger(Main.class);&#10;    private static AuthService authService;&#10;    private static CustomerService customerService;&#10;    private static AdminService adminService;&#10;    private static WaiterService waiterService;&#10;&#10;    // Banner to display on startup&#10;    private static final String BANNER =&#10;        &quot;\n&quot; +&#10;        &quot; ╔═══════════════════════════════════════════════════════════════╗\n&quot; +&#10;        &quot; ║                                                               ║\n&quot; +&#10;        &quot; ║    ███████╗███████╗ ██████╗  ██████╗ ██████╗ ███████╗         ║\n&quot; +&#10;        &quot; ║    ╚══███╔╝██╔════╝██╔═══██╗██╔═══██╗██╔══██╗██╔════╝         ║\n&quot; +&#10;        &quot; ║      ███╔╝ █████╗  ██║   ██║██║   ██║██║  ██║███████╗         ║\n&quot; +&#10;        &quot; ║     ███╔╝  ██╔══╝  ██║   ██║██║   ██║██║  ██║╚════██║         ║\n&quot; +&#10;        &quot; ║    ███████╗██║     ╚██████╔╝╚██████╔╝██████╔╝███████║         ║\n&quot; +&#10;        &quot; ║    ╚══════╝╚═╝      ╚═════╝  ╚═════╝ ╚═════╝ ╚══════╝         ║\n&quot; +&#10;        &quot; ║                                                               ║\n&quot; +&#10;        &quot; ║                  RESTAURANT MANAGEMENT SYSTEM                 ║\n&quot; +&#10;        &quot; ║                                                               ║\n&quot; +&#10;        &quot; ╚═══════════════════════════════════════════════════════════════╝\n&quot;;&#10;&#10;    public static void main(String[] args) {&#10;        logger.info(BANNER);&#10;&#10;        logger.info(&quot;Starting Restaurant Management System...&quot;);&#10;&#10;        try {&#10;            // Print database connection info&#10;            String dbHost = System.getenv().getOrDefault(&quot;DB_HOST&quot;, &quot;localhost&quot;);&#10;            String dbPort = System.getenv().getOrDefault(&quot;DB_PORT&quot;, &quot;5432&quot;);&#10;            String dbName = System.getenv().getOrDefault(&quot;DB_NAME&quot;, &quot;restaurant_management&quot;);&#10;&#10;            // Check for simulation mode from command line or environment&#10;            boolean simulationMode = Boolean.parseBoolean(System.getenv().getOrDefault(&quot;SIMULATION_MODE&quot;, &quot;false&quot;));&#10;            if (args.length &gt; 0 &amp;&amp; &quot;simulate&quot;.equalsIgnoreCase(args[0])) {&#10;                simulationMode = true;&#10;            }&#10;&#10;            // Test database connection&#10;            DatabaseUtil.getConnection();&#10;            logger.info(&quot;Database connection successful&quot;);&#10;&#10;            // Initialize services&#10;            authService = new PostgresAuthServiceImpl();&#10;            customerService = new CustomerServiceImpl();&#10;            adminService = new AdminServiceImpl();&#10;            waiterService = new WaiterServiceImpl();&#10;            logger.info(&quot;Services initialized&quot;);&#10;&#10;            // Run simulation or interactive mode&#10;            if (simulationMode) {&#10;                runSimulation();&#10;            } else {&#10;                startLoginProcess();&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to start Restaurant Management System&quot;, e);&#10;            System.exit(1);&#10;        }&#10;    }&#10;&#10;    private static void runSimulation() {&#10;        logger.info(&quot;=== Starting Authentication Simulation Mode ===&quot;);&#10;        AuthSimulation simulation = new AuthSimulation(authService);&#10;        simulation.runLoginSimulation();&#10;&#10;        // Close database connection when finished&#10;        DatabaseUtil.closeConnection();&#10;        logger.info(&quot;Simulation completed. Exiting application.&quot;);&#10;    }&#10;&#10;    private static void startLoginProcess() {&#10;        logger.info(&quot;=== Restaurant Management System Login ===&quot;);&#10;        logger.info(&quot;Type 'exit' to quit the application&quot;);&#10;&#10;        try {&#10;            // Use the enhanced console login method which is more reliable in Docker&#10;            PostgresAuthServiceImpl authServiceImpl = (PostgresAuthServiceImpl) authService;&#10;            User user = authServiceImpl.consoleLogin();&#10;&#10;            if (user == null) {&#10;                // Check if simulation was requested through the console login&#10;                if (&quot;simulate&quot;.equalsIgnoreCase(System.getenv().getOrDefault(&quot;LAST_COMMAND&quot;, &quot;&quot;))) {&#10;                    runSimulation();&#10;                }&#10;            }&#10;&#10;            // Keep application running until user selects exit&#10;            Scanner scanner = new Scanner(System.in);&#10;            boolean running = user != null;&#10;&#10;            while (running) {&#10;                String input = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(input) || &quot;exit&quot;.equalsIgnoreCase(input)) {&#10;                    logger.info(&quot;Logging out and exiting application&quot;);&#10;                    running = false;&#10;                } else {&#10;                    // Handle menu selection based on user role&#10;                    logger.info(&quot;Selected option: {}&quot;, input);&#10;&#10;                    if (user.getRole().equalsIgnoreCase(&quot;customer&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                customerService.displayRestaurantMenu(scanner);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                processOrderPlacement(user, scanner);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                viewOrderStatus(user, scanner);&#10;                                break;&#10;                            case &quot;4&quot;:&#10;                                bookTableForCustomer(user, scanner);&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else if (user.getRole().equalsIgnoreCase(&quot;waiter&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                takeNewOrderAsWaiter(scanner);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                checkUnservedTables();&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else if (user.getRole().equalsIgnoreCase(&quot;admin&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                System.out.println(&quot;Manage Users - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                System.out.println(&quot;View System Reports - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                fetchCurrentInventory();&#10;                                break;&#10;                            case &quot;4&quot;:&#10;                                restoreCurrentInventory();&#10;                                break;&#10;                            case &quot;5&quot;:&#10;                                System.out.println(&quot;Manage Menu Items - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else {&#10;                        System.out.println(&quot;Processing your request...&quot;);&#10;                        System.out.println(&quot;Feature will be implemented in future updates.&quot;);&#10;                    }&#10;&#10;                    System.out.print(&quot;Enter another option (0 to exit): &quot;);&#10;                }&#10;            }&#10;&#10;            scanner.close();&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during login process: {}&quot;, e.getMessage(), e);&#10;        } finally {&#10;            // Close database connection when app exits&#10;            DatabaseUtil.closeConnection();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Process order placement for a customer&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void processOrderPlacement(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== Place New Order ===&quot;);&#10;&#10;        // Create a new order for the customer&#10;        Order order = customerService.placeOrder(user);&#10;        System.out.println(&quot;Order created! Order ID: &quot; + order.getOrderId());&#10;&#10;        boolean addingItems = true;&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;&#10;        while (addingItems) {&#10;            // Display menu categories&#10;            System.out.println(&quot;\nMenu Categories:&quot;);&#10;            TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;            String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;            for (int i = 0; i &lt; categories.length; i++) {&#10;                System.out.printf(&quot;%d. %s\n&quot;, i + 1, categories[i]);&#10;            }&#10;&#10;            System.out.print(&quot;\nSelect category (0 to finish order): &quot;);&#10;            String categoryInput = scanner.nextLine().trim();&#10;&#10;            if (&quot;0&quot;.equals(categoryInput)) {&#10;                addingItems = false;&#10;                continue;&#10;            }&#10;&#10;            try {&#10;                int categoryIndex = Integer.parseInt(categoryInput) - 1;&#10;                if (categoryIndex &lt; 0 || categoryIndex &gt;= categories.length) {&#10;                    System.out.println(&quot;Invalid category selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedCategory = categories[categoryIndex];&#10;                Map&lt;String, String&gt; items = menu.getCategoryItems(selectedCategory);&#10;&#10;                // Display items in the selected category&#10;                System.out.println(&quot;\n--- &quot; + selectedCategory + &quot; ---&quot;);&#10;                String[] itemNames = items.keySet().toArray(new String[0]);&#10;                for (int i = 0; i &lt; itemNames.length; i++) {&#10;                    System.out.printf(&quot;%d. %s - %s\n&quot;, i + 1, itemNames[i], items.get(itemNames[i]));&#10;                }&#10;&#10;                System.out.print(&quot;\nSelect item (0 to go back): &quot;);&#10;                String itemInput = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(itemInput)) {&#10;                    continue;&#10;                }&#10;&#10;                int itemIndex = Integer.parseInt(itemInput) - 1;&#10;                if (itemIndex &lt; 0 || itemIndex &gt;= itemNames.length) {&#10;                    System.out.println(&quot;Invalid item selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedItem = itemNames[itemIndex];&#10;&#10;                System.out.print(&quot;Enter quantity: &quot;);&#10;                int quantity = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (quantity &lt;= 0) {&#10;                    System.out.println(&quot;Quantity must be greater than zero.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Add item to order&#10;                boolean success = customerServiceImpl.addItemToOrder(order.getOrderId(), selectedCategory, selectedItem, quantity);&#10;                if (success) {&#10;                    System.out.println(quantity + &quot; x &quot; + selectedItem + &quot; added to your order.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Failed to add item to order.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Check if order has items&#10;        if (order.getItems().isEmpty()) {&#10;            System.out.println(&quot;Order cancelled - no items added.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Generate and display bill&#10;        System.out.println(&quot;\nGenerating your bill...&quot;);&#10;        String bill = customerServiceImpl.generateBill(order.getOrderId());&#10;        System.out.println(bill);&#10;&#10;        System.out.println(&quot;Thank you for your order!&quot;);&#10;    }&#10;&#10;&#10;    /**&#10;     * View the status of previous orders&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void viewOrderStatus(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== View Order Status ===&quot;);&#10;&#10;        // Retrieve and display user's order history&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;        customerServiceImpl.viewOrderStatus(user);&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Fetch and display the current inventory&#10;     */&#10;    private static void fetchCurrentInventory() {&#10;        logger.info(&quot;Fetching current inventory data&quot;);&#10;        System.out.println(&quot;\n=== Current Inventory ===&quot;);&#10;&#10;        String inventoryData = adminService.fetchCurrentInventory();&#10;        System.out.println(inventoryData);&#10;&#10;        System.out.println(&quot;Current inventory data has been displayed.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Restore the current inventory from the main inventory&#10;     */&#10;    private static void restoreCurrentInventory() {&#10;        logger.info(&quot;Restoring current inventory from main inventory&quot;);&#10;        System.out.println(&quot;\n=== Restoring Inventory ===&quot;);&#10;&#10;        boolean success = adminService.restoreCurrentInventory();&#10;&#10;        if (success) {&#10;            System.out.println(&quot;Inventory has been successfully restored from the main inventory.&quot;);&#10;        } else {&#10;            System.out.println(&quot;Failed to restore inventory. Please check the logs for details.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Take a new order as a waiter&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void takeNewOrderAsWaiter(Scanner scanner) {&#10;        logger.info(&quot;Taking new order as waiter&quot;);&#10;&#10;        // Use the WaiterService to handle the order taking process&#10;        Order order = waiterService.takeNewOrder(scanner);&#10;&#10;        if (order != null) {&#10;            logger.info(&quot;Order #{} successfully created by waiter&quot;, order.getOrderId());&#10;            System.out.println(&quot;\nOrder #&quot; + order.getOrderId() + &quot; has been successfully created.&quot;);&#10;        } else {&#10;            logger.info(&quot;Order creation cancelled or failed&quot;);&#10;            System.out.println(&quot;\nOrder creation was cancelled or failed.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check and display unserved tables&#10;     */&#10;    private static void checkUnservedTables() {&#10;        logger.info(&quot;Checking unserved tables&quot;);&#10;        System.out.println(&quot;\n=== Unserved Tables ===&quot;);&#10;&#10;        // Use the WaiterService to fetch unserved tables&#10;        java.util.List&lt;zeta.foods.model.Table&gt; unservedTables = waiterService.getUnservedTables();&#10;&#10;        if (unservedTables != null &amp;&amp; !unservedTables.isEmpty()) {&#10;            System.out.println(&quot;Tables waiting to be served:&quot;);&#10;            for (zeta.foods.model.Table table : unservedTables) {&#10;                System.out.println(table.toString());&#10;            }&#10;            System.out.println(&quot;\nTotal unserved tables: &quot; + unservedTables.size());&#10;        } else {&#10;            System.out.println(&quot;All tables are currently served.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handle the booking of a table for a customer&#10;     * @param user Logged in user&#10;     * @param scanner Scanner for input&#10;     */&#10;    private static void bookTableForCustomer(User user, Scanner scanner) {&#10;        logger.info(&quot;Customer {} attempting to book a table&quot;, user.getUsername());&#10;        System.out.println(&quot;\n=== Book Table ===&quot;);&#10;&#10;        // Use the customer service to handle the table booking process&#10;        // Call viewAndBookTable instead of bookTable, as this handles user input for time and table selection&#10;        customerService.viewAndBookTable(user);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/config/FirebaseConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/config/FirebaseConfig.java" />
              <option name="originalContent" value="package zeta.foods.config;&#10;&#10;import com.google.auth.oauth2.GoogleCredentials;&#10;import com.google.firebase.FirebaseApp;&#10;import com.google.firebase.FirebaseOptions;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;public class FirebaseConfig {&#10;    private static final Logger logger = LoggerFactory.getLogger(FirebaseConfig.class);&#10;&#10;    public static void initializeFirebase() {&#10;        try {&#10;            if (FirebaseApp.getApps().isEmpty()) {&#10;                logger.info(&quot;Initializing Firebase in test mode...&quot;);&#10;&#10;                // For development/testing purposes, we'll initialize Firebase with empty credentials&#10;                FirebaseOptions options = FirebaseOptions.builder()&#10;                        .setCredentials(GoogleCredentials.fromAccessToken(&quot;test-token&quot;)) // Use dummy token for test mode&#10;                        .setProjectId(&quot;login-4e5bf&quot;)&#10;                        .setDatabaseUrl(&quot;https://login-4e5bf-default-rtdb.firebaseio.com&quot;)&#10;                        .build();&#10;&#10;                FirebaseApp.initializeApp(options);&#10;                logger.info(&quot;Firebase initialized successfully in test mode&quot;);&#10;            } else {&#10;                logger.info(&quot;Firebase app already initialized&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error initializing Firebase: {}&quot;, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Failed to initialize Firebase&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.config;&#10;&#10;import com.google.auth.oauth2.GoogleCredentials;&#10;import com.google.firebase.FirebaseApp;&#10;import com.google.firebase.FirebaseOptions;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;public class FirebaseConfig {&#10;    private static final Logger logger = LoggerFactory.getLogger(FirebaseConfig.class);&#10;&#10;    public static void initializeFirebase() {&#10;        try {&#10;            if (FirebaseApp.getApps().isEmpty()) {&#10;                logger.info(&quot;Initializing Firebase...&quot;);&#10;&#10;                // Using the Firebase credentials provided&#10;                FirebaseOptions options = FirebaseOptions.builder()&#10;                        .setApiKey(&quot;AIzaSyBc_5c_kifHsQpJl43kgMlTLciTTkCEJ9w&quot;)&#10;                        .setProjectId(&quot;login-4e5bf&quot;)&#10;                        .setDatabaseUrl(&quot;https://login-4e5bf-default-rtdb.firebaseio.com&quot;)&#10;                        .setStorageBucket(&quot;login-4e5bf.firebasestorage.app&quot;)&#10;                        .setApplicationId(&quot;1:492624027559:web:55d0e912122375822aa082&quot;)&#10;                        // Create empty credentials for testing environment&#10;                        .setCredentials(GoogleCredentials.create(null))&#10;                        .build();&#10;&#10;                FirebaseApp.initializeApp(options);&#10;                logger.info(&quot;Firebase initialized successfully&quot;);&#10;            } else {&#10;                logger.info(&quot;Firebase app already initialized&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error initializing Firebase: {}&quot;, e.getMessage(), e);&#10;            logger.info(&quot;Continuing without Firebase initialization&quot;);&#10;            // Don't throw exception - allow the application to continue without Firebase&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/Order.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/Order.java" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;public class Order {&#10;    private String orderId;&#10;    private Long customerId;&#10;    private String customerName;&#10;    private List&lt;OrderItem&gt; items;&#10;    private OrderStatus status;&#10;    private LocalDateTime orderTime;&#10;    private LocalDateTime deliveryTime;&#10;    private double totalAmount;&#10;    private String specialInstructions;&#10;    private int tableNumber;&#10;&#10;    public Order() {&#10;        this.orderId = UUID.randomUUID().toString().substring(0, 8);&#10;        this.items = new ArrayList&lt;&gt;();&#10;        this.status = OrderStatus.PENDING;&#10;        this.orderTime = LocalDateTime.now();&#10;    }&#10;&#10;    public String getOrderId() {&#10;        return orderId;&#10;    }&#10;&#10;    public void setOrderId(String orderId) {&#10;        this.orderId = orderId;&#10;    }&#10;&#10;    public Long getCustomerId() {&#10;        return customerId;&#10;    }&#10;&#10;    public void setCustomerId(Long customerId) {&#10;        this.customerId = customerId;&#10;    }&#10;&#10;    public String getCustomerName() {&#10;        return customerName;&#10;    }&#10;&#10;    public void setCustomerName(String customerName) {&#10;        this.customerName = customerName;&#10;    }&#10;&#10;    public List&lt;OrderItem&gt; getItems() {&#10;        return items;&#10;    }&#10;&#10;    public void setItems(List&lt;OrderItem&gt; items) {&#10;        this.items = items;&#10;    }&#10;&#10;    public void addItem(OrderItem item) {&#10;        this.items.add(item);&#10;        calculateTotal();&#10;    }&#10;&#10;    public OrderStatus getStatus() {&#10;        return status;&#10;    }&#10;&#10;    public void setStatus(OrderStatus status) {&#10;        this.status = status;&#10;    }&#10;&#10;    public LocalDateTime getOrderTime() {&#10;        return orderTime;&#10;    }&#10;&#10;    public void setOrderTime(LocalDateTime orderTime) {&#10;        this.orderTime = orderTime;&#10;    }&#10;&#10;    public LocalDateTime getDeliveryTime() {&#10;        return deliveryTime;&#10;    }&#10;&#10;    public void setDeliveryTime(LocalDateTime deliveryTime) {&#10;        this.deliveryTime = deliveryTime;&#10;    }&#10;&#10;    public double getTotalAmount() {&#10;        return totalAmount;&#10;    }&#10;&#10;    public void calculateTotal() {&#10;        this.totalAmount = items.stream()&#10;                .mapToDouble(item -&gt; item.getPrice() * item.getQuantity())&#10;                .sum();&#10;    }&#10;&#10;    public String getSpecialInstructions() {&#10;        return specialInstructions;&#10;    }&#10;&#10;    public void setSpecialInstructions(String specialInstructions) {&#10;        this.specialInstructions = specialInstructions;&#10;    }&#10;&#10;    public int getTableNumber() {&#10;        return tableNumber;&#10;    }&#10;&#10;    public void setTableNumber(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/OrderItem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/OrderItem.java" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;public class OrderItem {&#10;    private String category;&#10;    private String itemName;&#10;    private int quantity;&#10;    private double price;&#10;&#10;    public OrderItem(String category, String itemName, int quantity, double price) {&#10;        this.category = category;&#10;        this.itemName = itemName;&#10;        this.quantity = quantity;&#10;        this.price = price;&#10;    }&#10;&#10;    public String getCategory() {&#10;        return category;&#10;    }&#10;&#10;    public void setCategory(String category) {&#10;        this.category = category;&#10;    }&#10;&#10;    public String getItemName() {&#10;        return itemName;&#10;    }&#10;&#10;    public void setItemName(String itemName) {&#10;        this.itemName = itemName;&#10;    }&#10;&#10;    public int getQuantity() {&#10;        return quantity;&#10;    }&#10;&#10;    public void setQuantity(int quantity) {&#10;        this.quantity = quantity;&#10;    }&#10;&#10;    public double getPrice() {&#10;        return price;&#10;    }&#10;&#10;    public void setPrice(double price) {&#10;        this.price = price;&#10;    }&#10;&#10;    public double getSubtotal() {&#10;        return price * quantity;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/Table.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/Table.java" />
              <option name="originalContent" value="package zeta.foods.model;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Represents a restaurant table&#10; */&#10;public class Table {&#10;    private int tableNumber;&#10;    private boolean isOccupied;&#10;    private LocalDateTime bookingEndTime;&#10;&#10;    public Table() {&#10;    }&#10;&#10;    public Table(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = false;&#10;    }&#10;    public Table(int tableNumber, boolean isOccupied, LocalDateTime bookingStartTime, LocalDateTime bookingEndTime) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = isOccupied;&#10;    public Table(int tableNumber, boolean isOccupied, LocalDateTime bookingStartTime, LocalDateTime bookingEndTime) {&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;&#10;        return tableNumber;&#10;    }&#10;&#10;    public void setTableNumber(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;    }&#10;&#10;    public boolean isOccupied() {&#10;        return isOccupied;&#10;    }&#10;&#10;    public void setOccupied(boolean occupied) {&#10;        isOccupied = occupied;&#10;    }&#10;&#10;    public LocalDateTime getBookingStartTime() {&#10;        return bookingStartTime;&#10;    }&#10;&#10;    public void setBookingEndTime(LocalDateTime bookingEndTime) {&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Table #&quot; + tableNumber +&#10;               (isOccupied ? &quot; (Occupied since &quot; + bookingStartTime + &quot;)&quot; : &quot; (Available)&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Represents a restaurant table&#10; */&#10;public class Table {&#10;    private int tableNumber;&#10;    private boolean isOccupied;&#10;    private boolean isServed;&#10;    private LocalDateTime bookingStartTime;&#10;    private LocalDateTime bookingEndTime;&#10;&#10;    public Table() {&#10;    }&#10;&#10;    public Table(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = false;&#10;        this.isServed = false;&#10;    }&#10;&#10;    public Table(int tableNumber, boolean isOccupied, boolean isServed, LocalDateTime bookingStartTime, LocalDateTime bookingEndTime) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = isOccupied;&#10;        this.isServed = isServed;&#10;        this.bookingStartTime = bookingStartTime;&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;&#10;    public int getTableNumber() {&#10;        return tableNumber;&#10;    }&#10;&#10;    public void setTableNumber(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;    }&#10;&#10;    public boolean isOccupied() {&#10;        return isOccupied;&#10;    }&#10;&#10;    public void setOccupied(boolean occupied) {&#10;        isOccupied = occupied;&#10;    }&#10;    &#10;    public boolean isServed() {&#10;        return isServed;&#10;    }&#10;    &#10;    public void setServed(boolean served) {&#10;        isServed = served;&#10;    }&#10;&#10;    public LocalDateTime getBookingStartTime() {&#10;        return bookingStartTime;&#10;    }&#10;&#10;    public void setBookingStartTime(LocalDateTime bookingStartTime) {&#10;        this.bookingStartTime = bookingStartTime;&#10;    }&#10;&#10;    public LocalDateTime getBookingEndTime() {&#10;        return bookingEndTime;&#10;    }&#10;&#10;    public void setBookingEndTime(LocalDateTime bookingEndTime) {&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;    &#10;    // Default capacity for restaurant tables (can be modified in future versions)&#10;    private int capacity = 4;&#10;    &#10;    public int getCapacity() {&#10;        return capacity;&#10;    }&#10;    &#10;    public void setCapacity(int capacity) {&#10;        this.capacity = capacity;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Table #&quot; + tableNumber + &#10;               (isOccupied ? &quot; (Occupied)&quot; : &quot; (Available)&quot;) +&#10;               (isServed ? &quot; (Served)&quot; : &quot;&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/User.java" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;import java.time.ZonedDateTime;&#10;&#10;public class User {&#10;    private Long id;&#10;    private String username;&#10;    private String email;&#10;    private String password; // Stored as hashed&#10;    private String role; // &quot;admin&quot;, &quot;waiter&quot;, or &quot;customer&quot;&#10;    private ZonedDateTime createdAt;&#10;    private ZonedDateTime lastLogin;&#10;&#10;    // Constructors&#10;    public User() {}&#10;    &#10;    public User(Long id, String username, String email, String password, String role) {&#10;        this.id = id;&#10;        this.username = username;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.role = role;&#10;    }&#10;&#10;    // Getters and Setters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;&#10;    public void setId(Long id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    public void setUsername(String username) {&#10;        this.username = username;&#10;    }&#10;&#10;    public String getEmail() {&#10;        return email;&#10;    }&#10;&#10;    public void setEmail(String email) {&#10;        this.email = email;&#10;    }&#10;&#10;    public String getPassword() {&#10;        return password;&#10;    }&#10;&#10;    public void setPassword(String password) {&#10;        this.password = password;&#10;    }&#10;&#10;    public String getRole() {&#10;        return role;&#10;    }&#10;&#10;    public void setRole(String role) {&#10;        this.role = role;&#10;    }&#10;&#10;    public ZonedDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    public void setCreatedAt(ZonedDateTime createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    public ZonedDateTime getLastLogin() {&#10;        return lastLogin;&#10;    }&#10;&#10;    public void setLastLogin(ZonedDateTime lastLogin) {&#10;        this.lastLogin = lastLogin;&#10;    }&#10;    &#10;    public boolean isAdmin() {&#10;        return &quot;admin&quot;.equals(role);&#10;    }&#10;    &#10;    public boolean isWaiter() {&#10;        return &quot;waiter&quot;.equals(role);&#10;    }&#10;    &#10;    public boolean isCustomer() {&#10;        return &quot;customer&quot;.equals(role);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/AdminService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/AdminService.java" />
              <option name="updatedContent" value="package zeta.foods.service;&#10;&#10;/**&#10; * Service interface for administrative operations&#10; */&#10;public interface AdminService {&#10;    &#10;    /**&#10;     * Fetch the current inventory data&#10;     * @return A string representation of the current inventory&#10;     */&#10;    String fetchCurrentInventory();&#10;    &#10;    /**&#10;     * Restore the current inventory from backup or default values&#10;     * @return true if restoration was successful, false otherwise&#10;     */&#10;    boolean restoreCurrentInventory();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/CustomerService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/CustomerService.java" />
              <option name="originalContent" value="package zeta.foods.service;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.User;&#10;&#10;import java.util.List;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Service interface for customer-specific operations&#10; */&#10;public interface CustomerService {&#10;&#10;    /**&#10;     * Place a new order for a customer&#10;     * @param user The customer placing the order&#10;     * @return The created order&#10;     */&#10;    Order placeOrder(User user);&#10;&#10;    /**&#10;     * Get all orders for a customer&#10;     * @param customerId Customer ID&#10;     * @return List of customer's orders&#10;     */&#10;    List&lt;Order&gt; getCustomerOrders(Long customerId);&#10;&#10;    /**&#10;     * Get order status by order ID&#10;     * @param orderId Order ID&#10;     * @return The order if found, null otherwise&#10;     */&#10;    Order getOrderStatus(String orderId);&#10;&#10;    /**&#10;     * Get a specified number of previous orders for a customer, sorted by most recent first&#10;     *&#10;     * @param customerId The customer's ID&#10;     * @param limit      Maximum number of orders to retrieve (default is 1 for latest order)&#10;     * @return List of the customer's orders in descending date order&#10;     */&#10;    List&lt;Order&gt; getPreviousOrders(Long customerId, int limit);&#10;&#10;    /**&#10;     * Format a single order for display&#10;     *&#10;     * @param order The order to format&#10;     * @return Formatted order summary as string&#10;     */&#10;    String formatOrderSummary(Order order);&#10;&#10;    /**&#10;     * Display the restaurant menu in a two-page format&#10;     * @param scanner Scanner for user input&#10;     */&#10;    void displayRestaurantMenu(Scanner scanner);&#10;&#10;    /**&#10;     * View order status for a user&#10;     * @param user The user viewing their orders&#10;     */&#10;    void viewOrderStatus(User user);&#10;&#10;    /**&#10;     * Book a table for a customer&#10;     * @param user The customer booking the table&#10;     * @param scanner Scanner for user input&#10;     * @return true if booking was successful, false otherwise&#10;     */&#10;    boolean bookTable(User user, Scanner scanner);&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.Table;&#10;import zeta.foods.model.User;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Service interface for customer-specific operations&#10; */&#10;public interface CustomerService {&#10;&#10;    /**&#10;     * Place a new order for a customer&#10;     * @param user The customer placing the order&#10;     * @return The created order&#10;     */&#10;    Order placeOrder(User user);&#10;&#10;    /**&#10;     * Get all orders for a customer&#10;     * @param customerId Customer ID&#10;     * @return List of customer's orders&#10;     */&#10;    List&lt;Order&gt; getCustomerOrders(Long customerId);&#10;&#10;    /**&#10;     * Get order status by order ID&#10;     * @param orderId Order ID&#10;     * @return The order if found, null otherwise&#10;     */&#10;    Order getOrderStatus(String orderId);&#10;&#10;    /**&#10;     * Get a specified number of previous orders for a customer, sorted by most recent first&#10;     *&#10;     * @param customerId The customer's ID&#10;     * @param limit      Maximum number of orders to retrieve (default is 1 for latest order)&#10;     * @return List of the customer's orders in descending date order&#10;     */&#10;    List&lt;Order&gt; getPreviousOrders(Long customerId, int limit);&#10;&#10;    /**&#10;     * Format a single order for display&#10;     *&#10;     * @param order The order to format&#10;     * @return Formatted order summary as string&#10;     */&#10;    String formatOrderSummary(Order order);&#10;&#10;    /**&#10;     * Display the restaurant menu in a two-page format&#10;     * @param scanner Scanner for user input&#10;     */&#10;    void displayRestaurantMenu(Scanner scanner);&#10;&#10;    /**&#10;     * View order status for a user&#10;     * @param user The user viewing their orders&#10;     */&#10;    void viewOrderStatus(User user);&#10;&#10;    /**&#10;     * Get available tables at a specific timestamp&#10;     *&#10;     * @param requestedDateTime The timestamp when the customer wants to book a table&#10;     * @return List of available tables at that time&#10;     */&#10;    List&lt;Table&gt; getAvailableTablesAtTime(LocalDateTime requestedDateTime);&#10;&#10;    /**&#10;     * Book a table for a customer at a specific time period&#10;     *&#10;     * @param user The user booking the table&#10;     * @param tableNumber The table number to book&#10;     * @param startTime The start time of the booking&#10;     * @param endTime The end time of the booking&#10;     * @return true if booking was successful, false otherwise&#10;     */&#10;    boolean bookTable(User user, int tableNumber, LocalDateTime startTime, LocalDateTime endTime);&#10;&#10;    /**&#10;     * Display available tables at a specific time for a customer to choose from&#10;     *&#10;     * @param user The user viewing available tables&#10;     */&#10;    void viewAndBookTable(User user);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/FirebaseAuthService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/FirebaseAuthService.java" />
              <option name="originalContent" value="package zeta.foods.service;&#10;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;import java.util.concurrent.ExecutionException;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseAuthException;&#10;import com.google.firebase.auth.UserRecord;&#10;import com.google.firebase.auth.UserRecord.CreateRequest;&#10;&#10;public interface FirebaseAuthService {&#10;    /**&#10;     * Authenticate a user with email and password&#10;     * @param email User's email&#10;     * @param password User's password&#10;     * @return UserRecord if authentication successful, null otherwise&#10;     */&#10;    UserRecord authenticateUser(String email, String password);&#10;&#10;    /**&#10;     * Check if the user is an admin&#10;     * @param email User's email&#10;     * @return true if admin, false otherwise&#10;     */&#10;    boolean isAdmin(String email);&#10;&#10;    /**&#10;     * Check if the user is a waiter&#10;     * @param email User's email&#10;     * @return true if waiter, false otherwise&#10;     */&#10;    boolean isWaiter(String email);&#10;&#10;    /**&#10;     * Create a new user&#10;     * @param email User's email&#10;     * @param password User's password&#10;     * @param isAdmin Whether the user is an admin&#10;     * @return UserRecord of created user&#10;     */&#10;    UserRecord createUser(String email, String password, boolean isAdmin);&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service;&#10;&#10;import zeta.foods.model.User;&#10;&#10;public interface AuthService {&#10;    /**&#10;     * Authenticate a user with email and password&#10;     * @param email User's email&#10;     * @param password User's password&#10;     * @return User if authentication successful, null otherwise&#10;     */&#10;    User authenticateUser(String email, String password);&#10;    &#10;    /**&#10;     * Check if a user is an admin&#10;     * @param email User's email&#10;     * @return true if admin, false otherwise&#10;     */&#10;    boolean isAdmin(String email);&#10;    &#10;    /**&#10;     * Check if a user is a waiter&#10;     * @param email User's email&#10;     * @return true if waiter, false otherwise&#10;     */&#10;    boolean isWaiter(String email);&#10;    &#10;    /**&#10;     * Create a new user account&#10;     * @param username Username&#10;     * @param email Email&#10;     * @param password Password (will be hashed)&#10;     * @param role Role (admin, waiter, customer)&#10;     * @return Created user or null if creation failed&#10;     */&#10;    User createUser(String username, String email, String password, String role);&#10;    &#10;    /**&#10;     * Updates the last login time for a user&#10;     * @param userId The user ID&#10;     * @return true if successful, false otherwise&#10;     */&#10;    boolean updateLastLogin(Long userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/CustomerServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/CustomerServiceImpl.java" />
              <option name="originalContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.OrderStatus;&#10;import zeta.foods.model.User;&#10;import zeta.foods.model.Recipe;&#10;import zeta.foods.model.Table;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.utils.CurrentInventory;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;import zeta.foods.utils.recipes;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;import org.json.JSONArray;&#10;import org.json.JSONObject;&#10;&#10;/**&#10; * Implementation of CustomerService for handling customer orders&#10; */&#10;public class CustomerServiceImpl implements CustomerService {&#10;    private static final Logger logger = LoggerFactory.getLogger(CustomerServiceImpl.class);&#10;&#10;    private static final Map&lt;String, Order&gt; orders = new HashMap&lt;&gt;();&#10;    private static final Map&lt;Long, List&lt;Order&gt;&gt; customerOrders = new HashMap&lt;&gt;();&#10;    &#10;    // Fixed number of tables in the restaurant&#10;    private static final int TOTAL_TABLES = 12;&#10;    &#10;    // Store restaurant tables&#10;    private static final List&lt;Table&gt; restaurantTables = new ArrayList&lt;&gt;();&#10;    &#10;    // Initialize tables&#10;    static {&#10;        for (int i = 1; i &lt;= TOTAL_TABLES; i++) {&#10;            restaurantTables.add(new Table(i));&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Order placeOrder(User user) {&#10;        Order order = new Order();&#10;&#10;        // Handle case where user ID might be null (for temporary users created by waiters)&#10;        if (user.getId() != null) {&#10;            order.setCustomerId(user.getId());&#10;        } else {&#10;            // For walk-in customers or when waiter creates an order without a registered user&#10;            order.setCustomerId(0L);  // Use 0 to indicate a walk-in customer or temporary user&#10;        }&#10;&#10;        order.setCustomerName(user.getUsername());&#10;&#10;        boolean dbSaveSuccessful = false;&#10;        // Save order to database (initially empty)&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // Use transaction to ensure consistency&#10;            conn.setAutoCommit(false);&#10;&#10;            String sql = &quot;INSERT INTO orders (order_id, customer_id, items, bill_subtotal, order_status) VALUES (?, ?, ?::jsonb, ?, ?)&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, order.getOrderId());&#10;&#10;                // If user ID is null, use 0 for customer_id in database&#10;                if (user.getId() != null) {&#10;                    stmt.setLong(2, user.getId());&#10;                } else {&#10;                    stmt.setLong(2, 0L);&#10;                }&#10;&#10;                stmt.setString(3, &quot;[]&quot;); // Empty JSON array for items initially&#10;                stmt.setDouble(4, 0.0); // Initial subtotal is 0&#10;                stmt.setString(5, order.getStatus().toString());&#10;&#10;                int rowsAffected = stmt.executeUpdate();&#10;&#10;                if (rowsAffected &gt; 0) {&#10;                    // Verify the order was actually saved&#10;                    try (PreparedStatement verifyStmt = conn.prepareStatement(&quot;SELECT COUNT(*) FROM orders WHERE order_id = ?&quot;)) {&#10;                        verifyStmt.setString(1, order.getOrderId());&#10;                        try (ResultSet rs = verifyStmt.executeQuery()) {&#10;                            if (rs.next() &amp;&amp; rs.getInt(1) &gt; 0) {&#10;                                // Order exists in the database&#10;                                conn.commit();&#10;                                dbSaveSuccessful = true;&#10;                                logger.info(&quot;Order {} successfully saved to database and verified&quot;, order.getOrderId());&#10;                            } else {&#10;                                conn.rollback();&#10;                                logger.error(&quot;Order {} insert appeared successful but verification failed&quot;, order.getOrderId());&#10;                            }&#10;                        }&#10;                    }&#10;                } else {&#10;                    conn.rollback();&#10;                    logger.error(&quot;Failed to save order {} to database (no rows affected)&quot;, order.getOrderId());&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while saving order {}: {}&quot;, order.getOrderId(), e.getMessage(), e);&#10;        }&#10;&#10;        // Only store the order in memory if database save was successful&#10;        if (dbSaveSuccessful) {&#10;            // Store order in memory cache&#10;            if (user.getId() != null) {&#10;                if (!customerOrders.containsKey(user.getId())) {&#10;                    customerOrders.put(user.getId(), new ArrayList&lt;&gt;());&#10;                }&#10;                customerOrders.get(user.getId()).add(order);&#10;            }&#10;            orders.put(order.getOrderId(), order);&#10;&#10;            logger.info(&quot;Created new order with ID: {} for customer: {}&quot;, order.getOrderId(), user.getUsername());&#10;            return order;&#10;        } else {&#10;            logger.error(&quot;Order creation failed due to database error. Order ID: {}&quot;, order.getOrderId());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; getCustomerOrders(Long customerId) {&#10;        // Try to get orders from memory first&#10;        List&lt;Order&gt; cachedOrders = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no cached orders, try to load from database&#10;        if (cachedOrders.isEmpty()) {&#10;            return loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        return cachedOrders;&#10;    }&#10;&#10;    private List&lt;Order&gt; loadOrdersFromDatabase(Long customerId) {&#10;        List&lt;Order&gt; result = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;SELECT * FROM orders WHERE customer_id = ? ORDER BY order_timestamp DESC&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setLong(1, customerId);&#10;&#10;                try (ResultSet rs = stmt.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        Order order = new Order();&#10;                        String orderId = rs.getString(&quot;order_id&quot;);&#10;                        order.setOrderId(orderId);&#10;                        order.setCustomerId(customerId);&#10;                        order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                        order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                        // Parse items from JSON&#10;                        String itemsJson = rs.getString(&quot;items&quot;);&#10;                        parseOrderItems(order, itemsJson);&#10;&#10;                        result.add(order);&#10;&#10;                        // Add to cache&#10;                        orders.put(orderId, order);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Update the cache&#10;            if (!result.isEmpty()) {&#10;                customerOrders.put(customerId, result);&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while loading orders: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    private void parseOrderItems(Order order, String itemsJson) {&#10;        try {&#10;            JSONArray itemsArray = new JSONArray(itemsJson);&#10;            for (int i = 0; i &lt; itemsArray.length(); i++) {&#10;                JSONObject itemObj = itemsArray.getJSONObject(i);&#10;                String category = itemObj.getString(&quot;category&quot;);&#10;                String itemName = itemObj.getString(&quot;itemName&quot;);&#10;                double price = itemObj.getDouble(&quot;price&quot;);&#10;                int quantity = itemObj.getInt(&quot;quantity&quot;);&#10;&#10;                OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;                order.addItem(item);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing order items JSON: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Order getOrderStatus(String orderId) {&#10;        // Try to get from cache first&#10;        Order order = orders.get(orderId);&#10;&#10;        // If not in cache, try to load from database&#10;        if (order == null) {&#10;            try (Connection conn = DatabaseUtil.getConnection()) {&#10;                String sql = &quot;SELECT * FROM orders WHERE order_id = ?&quot;;&#10;&#10;                try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                    stmt.setString(1, orderId);&#10;&#10;                    try (ResultSet rs = stmt.executeQuery()) {&#10;                        if (rs.next()) {&#10;                            order = new Order();&#10;                            order.setOrderId(orderId);&#10;                            order.setCustomerId(rs.getLong(&quot;customer_id&quot;));&#10;                            order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                            order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                            // Parse items from JSON&#10;                            String itemsJson = rs.getString(&quot;items&quot;);&#10;                            parseOrderItems(order, itemsJson);&#10;&#10;                            // Add to cache&#10;                            orders.put(orderId, order);&#10;                        }&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Database error while getting order status: {}&quot;, e.getMessage(), e);&#10;            }&#10;        }&#10;&#10;        return order;&#10;    }&#10;&#10;    /**&#10;     * Add an item to an existing order&#10;     *&#10;     * @param orderId   The order ID&#10;     * @param category   Menu category&#10;     * @param itemName  Item name&#10;     * @param quantity  Quantity&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean addItemToOrder(String orderId, String category, String itemName, int quantity) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            logger.warn(&quot;Order not found: {}&quot;, orderId);&#10;            return false;&#10;        }&#10;&#10;        // Get price from menu&#10;        String priceStr = menu.getItemPrice(category, itemName);&#10;        if (priceStr == null) {&#10;            logger.warn(&quot;Item not found in menu: {} in category {}&quot;, itemName, category);&#10;            return false;&#10;        }&#10;&#10;        // Parse price (remove &quot;Rs.&quot; prefix)&#10;        double price = menu.getPriceValue(priceStr);&#10;&#10;        // Check if we have the necessary ingredients for this item&#10;        OrderItem tempItem = new OrderItem(category, itemName, quantity, price);&#10;        List&lt;OrderItem&gt; itemsToCheck = new ArrayList&lt;&gt;();&#10;        itemsToCheck.add(tempItem);&#10;&#10;        // Check ingredient availability before adding to order&#10;        if (!CurrentInventory.checkIngredientsAvailability(itemsToCheck)) {&#10;            logger.warn(&quot;Cannot add {} to order: insufficient ingredients&quot;, itemName);&#10;            logger.info(&quot;Sorry, we don't have enough ingredients to prepare &quot; + itemName + &quot; at this time.&quot;);&#10;            return false;&#10;        }&#10;&#10;        // Add item to order&#10;        OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;        order.addItem(item);&#10;&#10;        // Update the order in the database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First, get all existing items for this order&#10;            String itemsJson = createItemsJson(order);&#10;            logger.debug(&quot;Order subtotal: {}&quot;, order.getTotalAmount());&#10;&#10;            // Check if order exists in database&#10;            try (PreparedStatement checkStmt = conn.prepareStatement(&quot;SELECT COUNT(*) FROM orders WHERE order_id = ?&quot;)) {&#10;                checkStmt.setString(1, orderId);&#10;                try (ResultSet rs = checkStmt.executeQuery()) {&#10;                    if (rs.next() &amp;&amp; rs.getInt(1) == 0) {&#10;                        logger.error(&quot;Order {} does not exist in database&quot;, orderId);&#10;                        return false;&#10;                    }&#10;                }&#10;            }&#10;&#10;            String sql = &quot;UPDATE orders SET items = ?::jsonb, bill_subtotal = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, itemsJson);&#10;                stmt.setDouble(2, order.getTotalAmount());&#10;                stmt.setString(3, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update order {} in database (No rows affected)&quot;, orderId);&#10;                    return false;&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order {}: {}&quot;, orderId, e.getMessage(), e);&#10;            return false;&#10;        }&#10;&#10;        // Deduct ingredients from current inventory&#10;        CurrentInventory.useIngredientsForOrder(itemsToCheck);&#10;        logger.info(&quot;Added item to order {}: {} x{} ({})&quot;,&#10;                orderId, itemName, quantity, priceStr);&#10;        return true;&#10;    }&#10;&#10;    private String createItemsJson(Order order) {&#10;        JSONArray itemsArray = new JSONArray();&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            JSONObject itemObj = new JSONObject();&#10;            itemObj.put(&quot;category&quot;, item.getCategory());&#10;            itemObj.put(&quot;itemName&quot;, item.getItemName());&#10;            itemObj.put(&quot;price&quot;, item.getPrice());&#10;            itemObj.put(&quot;quantity&quot;, item.getQuantity());&#10;            itemsArray.put(itemObj);&#10;        }&#10;&#10;        return itemsArray.toString();&#10;    }&#10;&#10;    /**&#10;     * Update order status&#10;     *&#10;     * @param orderId Order ID&#10;     * @param status  New status&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean updateOrderStatus(String orderId, OrderStatus status) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return false;&#10;        }&#10;        order.setStatus(status);&#10;&#10;        // Update status in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET order_status = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, status.toString());&#10;                stmt.setString(2, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                return rowsUpdated &gt; 0;&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order status: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a specified number of previous orders for a customer, sorted by most recent first&#10;     *&#10;     * @param customerId The customer's ID&#10;     * @param limit      Maximum number of orders to retrieve (default is 1 for latest order)&#10;     * @return List of the customer's orders in descending date order&#10;     */&#10;    public List&lt;Order&gt; getPreviousOrders(Long customerId, int limit) {&#10;        // Check if we have any orders in memory first&#10;        List&lt;Order&gt; customerOrderList = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no orders in memory, try to load from database&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in memory for customer ID: {}, loading from database...&quot;, customerId);&#10;            customerOrderList = loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        // If still empty after trying to load from DB, return empty list&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in database for customer ID: {}&quot;, customerId);&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        // Sort orders by order time, most recent first&#10;        return customerOrderList.stream()&#10;                .sorted(Comparator.comparing(Order::getOrderTime).reversed())&#10;                .limit(limit &gt; 0 ? limit : 1) // Apply limit, with default of 1 if invalid limit&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Format a single order for display&#10;     *&#10;     * @param order The order to format&#10;     * @return Formatted order summary as string&#10;     */&#10;    public String formatOrderSummary(Order order) {&#10;        if (order == null) {&#10;            return &quot;No order information available.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);&#10;&#10;        StringBuilder summary = new StringBuilder();&#10;        summary.append(&quot;\n=================================\n&quot;);&#10;        summary.append(&quot;ORDER SUMMARY\n&quot;);&#10;        summary.append(&quot;=================================\n&quot;);&#10;        summary.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        summary.append(&quot;Date: &quot;).append(order.getOrderTime().format(dateFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Time: &quot;).append(order.getOrderTime().format(timeFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Status: &quot;).append(order.getStatus()).append(&quot;\n&quot;);&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;&#10;        // List items&#10;        summary.append(&quot;ITEMS ORDERED:\n&quot;);&#10;        for (OrderItem item : order.getItems()) {&#10;            summary.append(String.format(&quot;• %d x %s (Rs.%.2f)\n&quot;,&#10;                    item.getQuantity(), item.getItemName(), item.getPrice()));&#10;        }&#10;&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;        summary.append(String.format(&quot;Subtotal: Rs.%.2f\n&quot;, order.getTotalAmount()));&#10;&#10;        // Calculate additional charges&#10;        double serviceCharge = order.getTotalAmount() * 0.02;&#10;        double taxCharge = order.getTotalAmount() &gt; 150 ? 25.0 : 0.0;&#10;        double grandTotal = order.getTotalAmount() + serviceCharge + taxCharge;&#10;&#10;        summary.append(String.format(&quot;Service Charge (2%%): Rs.%.2f\n&quot;, serviceCharge));&#10;        summary.append(String.format(&quot;CGST &amp; SGST: Rs.%.2f\n&quot;, taxCharge));&#10;        summary.append(String.format(&quot;Grand Total: Rs.%.2f\n&quot;, grandTotal));&#10;        summary.append(&quot;=================================\n&quot;);&#10;&#10;        return summary.toString();&#10;    }&#10;&#10;    /**&#10;     * Format multiple orders for display&#10;     *&#10;     * @param orders List of orders to format&#10;     * @return Formatted list of order summaries as string&#10;     */&#10;    public String formatOrdersList(List&lt;Order&gt; orders) {&#10;        if (orders == null || orders.isEmpty()) {&#10;            return &quot;No previous orders found.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;);&#10;&#10;        StringBuilder result = new StringBuilder();&#10;        result.append(&quot;\n=================================\n&quot;);&#10;        result.append(&quot;YOUR ORDER HISTORY\n&quot;);&#10;        result.append(&quot;=================================\n&quot;);&#10;&#10;        int count = 1;&#10;        for (Order order : orders) {&#10;            result.append(String.format(&quot;%d. Order #%s - %s\n&quot;,&#10;                    count++,&#10;                    order.getOrderId(),&#10;                    order.getOrderTime().format(formatter)));&#10;&#10;            result.append(String.format(&quot;   Status: %s, Total: Rs.%.2f\n&quot;,&#10;                    order.getStatus(),&#10;                    order.getTotalAmount()));&#10;&#10;            // Show item count&#10;            result.append(String.format(&quot;   Items: %d\n&quot;, order.getItems().size()));&#10;        }&#10;&#10;        result.append(&quot;=================================\n&quot;);&#10;        return result.toString();&#10;    }&#10;&#10;    /**&#10;     * View order status for a customer with option to specify number of orders to display&#10;     *&#10;     * @param user The user viewing their order history&#10;     */&#10;    public void viewOrderStatus(User user) {&#10;        Scanner scanner = new Scanner(System.in);&#10;        System.out.println(&quot;\n=== Your Order History ===&quot;);&#10;&#10;        // Ask user how many orders they want to view&#10;        System.out.print(&quot;How many recent orders would you like to view? (default: 1): &quot;);&#10;        String input = scanner.nextLine().trim();&#10;&#10;        // Parse input, default to 1 if empty or invalid&#10;        int limit = 1;&#10;        if (!input.isEmpty()) {&#10;            try {&#10;                limit = Integer.parseInt(input);&#10;                if (limit &lt;= 0) {&#10;                    limit = 1;&#10;                    System.out.println(&quot;Invalid number. Showing the most recent order.&quot;);&#10;                }&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Invalid input. Showing the most recent order.&quot;);&#10;            }&#10;        }&#10;&#10;        // Get previous orders for the customer&#10;        List&lt;Order&gt; previousOrders = getPreviousOrders(user.getId(), limit);&#10;&#10;        if (previousOrders.isEmpty()) {&#10;            System.out.println(&quot;You don't have any orders yet.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Display each order&#10;        System.out.printf(&quot;Showing your %d most recent order(s):\n\n&quot;, previousOrders.size());&#10;        for (int i = 0; i &lt; previousOrders.size(); i++) {&#10;            if (i &gt; 0) {&#10;                System.out.println(&quot;\n&quot; + &quot;-&quot;.repeat(40) + &quot;\n&quot;);&#10;            }&#10;            Order order = previousOrders.get(i);&#10;            String formattedOrder = formatOrderSummary(order);&#10;            System.out.println(formattedOrder);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Display the restaurant menu in a two-page format&#10;     * @param scanner Scanner for user input&#10;     */&#10;    public void displayRestaurantMenu(Scanner scanner) {&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 1      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;        String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;        // First page: first half of categories&#10;        int midpoint = categories.length / 2;&#10;        for (int i = 0; i &lt; midpoint; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to see the next page...&quot;);&#10;        scanner.nextLine();&#10;&#10;        // Second page: second half of categories&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 2      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        for (int i = midpoint; i &lt; categories.length; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Display a single menu category&#10;     * @param categoryName Name of the category&#10;     * @param items Map of items and their prices&#10;     */&#10;    private void displayMenuCategory(String categoryName, Map&lt;String, String&gt; items) {&#10;        System.out.println(&quot;\n--- &quot; + categoryName + &quot; ---&quot;);&#10;        for (Map.Entry&lt;String, String&gt; item : items.entrySet()) {&#10;            System.out.printf(&quot;%-30s %10s\n&quot;, item.getKey(), item.getValue());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generate bill for an order&#10;     *&#10;     * @param orderId The order ID&#10;     * @return Formatted bill as String&#10;     */&#10;    public String generateBill(String orderId) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return &quot;Order not found&quot;;&#10;        }&#10;&#10;        // Calculate additional charges&#10;        double subtotal = order.getTotalAmount();&#10;        double serviceCharge = subtotal * 0.02;&#10;        double gst = subtotal * 0.05;&#10;        double finalAmount = subtotal + serviceCharge + gst;&#10;&#10;        // Update order status and payment info in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET &quot; +&#10;                    &quot;bill_subtotal = ?, &quot; +&#10;                    &quot;service_charge = ?, &quot; +&#10;                    &quot;cgst_sgst = ?, &quot; +&#10;                    &quot;bill_total = ?, &quot; +&#10;                    &quot;payment_status = ?, &quot; +&#10;                    &quot;order_status = ? &quot; +&#10;                    &quot;WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setDouble(1, subtotal);&#10;                stmt.setDouble(2, serviceCharge);&#10;                stmt.setDouble(3, gst);&#10;                stmt.setDouble(4, finalAmount);&#10;                stmt.setString(5, &quot;COMPLETED&quot;);&#10;                stmt.setString(6, &quot;COMPLETED&quot;);&#10;                stmt.setString(7, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update bill information in database for order {}&quot;, orderId);&#10;                } else {&#10;                    logger.info(&quot;Bill information saved to database for order {}&quot;, orderId);&#10;                    // Update status in memory too&#10;                    order.setStatus(OrderStatus.COMPLETED);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while generating bill: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        // Build bill content&#10;        StringBuilder bill = new StringBuilder();&#10;        bill.append(&quot;\n==========================================\n&quot;);&#10;        bill.append(&quot;             RESTAURANT BILL              \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Customer: &quot;).append(order.getCustomerName()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Date: &quot;).append(order.getOrderTime().toLocalDate()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Time: &quot;).append(order.getOrderTime().toLocalTime()).append(&quot;\n&quot;);&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %-8s %-10s %-10s\n&quot;, &quot;Item&quot;, &quot;Qty&quot;, &quot;Price&quot;, &quot;Subtotal&quot;));&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            bill.append(String.format(&quot;%-25s %-8d Rs.%-8.2f Rs.%.2f\n&quot;,&#10;                    item.getItemName(), item.getQuantity(), item.getPrice(), item.getSubtotal()));&#10;        }&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Total Amount&quot;, &quot;&quot;, subtotal));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;GST (5%)&quot;, &quot;&quot;, gst));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Service Charge (2%)&quot;, &quot;&quot;, serviceCharge));&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Grand Total&quot;, &quot;&quot;, finalAmount));&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;          Thank You! Visit Again!         \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;&#10;        return bill.toString();&#10;    }&#10;&#10;    /**&#10;     * Book a table for a customer&#10;     * @param user The customer booking the table&#10;     * @param scanner Scanner for user input&#10;     * @return true if booking was successful, false otherwise&#10;     */&#10;    @Override&#10;    public boolean bookTable(User user, Scanner scanner) {&#10;        logger.info(&quot;Customer {} attempting to book a table&quot;, user.getUsername());&#10;        System.out.println(&quot;\n=== Table Booking ===&quot;);&#10;&#10;        // Get available tables from database&#10;        List&lt;zeta.foods.model.Table&gt; availableTables = getAvailableTables();&#10;&#10;        if (availableTables.isEmpty()) {&#10;            System.out.println(&quot;Sorry, there are no tables available at the moment.&quot;);&#10;            return false;&#10;        }&#10;&#10;        // Display available tables&#10;        System.out.println(&quot;\nAvailable Tables:&quot;);&#10;        for (zeta.foods.model.Table table : availableTables) {&#10;            System.out.println(table.toString());&#10;        }&#10;&#10;        // Ask customer to select a table&#10;        int tableNumber;&#10;        while (true) {&#10;            System.out.print(&quot;\nEnter table number to book (0 to cancel): &quot;);&#10;            try {&#10;                tableNumber = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (tableNumber == 0) {&#10;                    System.out.println(&quot;Booking cancelled.&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Validate table selection&#10;                boolean validTable = false;&#10;                for (zeta.foods.model.Table table : availableTables) {&#10;                    if (table.getTableNumber() == tableNumber) {&#10;                        validTable = true;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (validTable) {&#10;                    break;&#10;                } else {&#10;                    System.out.println(&quot;Invalid table number. Please select from the available tables.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Book the table (update database)&#10;        boolean success = reserveTable(tableNumber, user.getId());&#10;&#10;        if (success) {&#10;            System.out.println(&quot;\nTable #&quot; + tableNumber + &quot; has been successfully booked for you.&quot;);&#10;            System.out.println(&quot;Please arrive within 30 minutes of your reservation time.&quot;);&#10;            return true;&#10;        } else {&#10;            System.out.println(&quot;\nSorry, there was an error booking your table. Please try again later.&quot;);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get list of available (unoccupied) tables&#10;     * @return List of available tables&#10;     */&#10;    private List&lt;zeta.foods.model.Table&gt; getAvailableTables() {&#10;        List&lt;zeta.foods.model.Table&gt; availableTables = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&#10;                     &quot;SELECT * FROM tables WHERE is_occupied = FALSE ORDER BY table_number&quot;)) {&#10;&#10;            while (rs.next()) {&#10;                zeta.foods.model.Table table = new zeta.foods.model.Table();&#10;                table.setTableNumber(rs.getInt(&quot;table_number&quot;));&#10;                table.setOccupied(false);&#10;                table.setServed(false);&#10;&#10;                availableTables.add(table);&#10;            }&#10;&#10;            logger.info(&quot;Retrieved {} available tables from database&quot;, availableTables.size());&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error retrieving available tables: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return availableTables;&#10;    }&#10;&#10;    /**&#10;     * Reserve a table for a customer&#10;     * @param tableNumber The table number to reserve&#10;     * @param customerId The customer ID making the reservation&#10;     * @return true if reservation was successful, false otherwise&#10;     */&#10;    private boolean reserveTable(int tableNumber, Long customerId) {&#10;        logger.info(&quot;Reserving table #{} for customer ID: {}&quot;, tableNumber, customerId);&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // Start transaction&#10;            conn.setAutoCommit(false);&#10;&#10;            // First check if the table is still available&#10;            try (PreparedStatement checkStmt = conn.prepareStatement(&#10;                    &quot;SELECT * FROM tables WHERE table_number = ? AND is_occupied = FALSE&quot;)) {&#10;&#10;                checkStmt.setInt(1, tableNumber);&#10;                ResultSet rs = checkStmt.executeQuery();&#10;&#10;                if (!rs.next()) {&#10;                    logger.warn(&quot;Table #{} is no longer available&quot;, tableNumber);&#10;                    conn.rollback();&#10;                    return false;&#10;                }&#10;&#10;                int tableId = rs.getInt(&quot;id&quot;);&#10;&#10;                // Update table status to occupied&#10;                try (PreparedStatement updateStmt = conn.prepareStatement(&#10;                        &quot;UPDATE tables SET is_occupied = TRUE, booking_start_time = NOW() WHERE id = ?&quot;)) {&#10;&#10;                    updateStmt.setInt(1, tableId);&#10;                    updateStmt.executeUpdate();&#10;                }&#10;&#10;                // Create reservation record&#10;                try (PreparedStatement reserveStmt = conn.prepareStatement(&#10;                        &quot;INSERT INTO table_reservations (table_id, customer_id, reservation_time, status) &quot; +&#10;                                &quot;VALUES (?, ?, NOW(), 'active')&quot;)) {&#10;&#10;                    reserveStmt.setInt(1, tableId);&#10;                    reserveStmt.setLong(2, customerId);&#10;                    reserveStmt.executeUpdate();&#10;                }&#10;&#10;                // Commit transaction&#10;                conn.commit();&#10;                logger.info(&quot;Table #{} successfully reserved for customer ID: {}&quot;, tableNumber, customerId);&#10;                return true;&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error reserving table: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Table&gt; getAvailableTablesAtTime(LocalDateTime requestedDateTime) {&#10;        // Get all bookings that overlap with the requested time&#10;        List&lt;Table&gt; availableTables = new ArrayList&lt;&gt;();&#10;        &#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First load all tables with their current booking status&#10;            loadTablesFromDatabase();&#10;            &#10;            // Check each table if it's available at the requested time&#10;            for (Table table : restaurantTables) {&#10;                boolean isAvailable = true;&#10;                &#10;                // If table has booking times, check if they overlap with requested time&#10;                if (table.getBookingStartTime() != null &amp;&amp; table.getBookingEndTime() != null) {&#10;                    // Check if requested time falls within the booking period&#10;                    if (!(requestedDateTime.isBefore(table.getBookingStartTime()) || &#10;                          requestedDateTime.isAfter(table.getBookingEndTime()))) {&#10;                        isAvailable = false;&#10;                    }&#10;                }&#10;                &#10;                if (isAvailable) {&#10;                    availableTables.add(table);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while checking table availability: {}&quot;, e.getMessage(), e);&#10;        }&#10;        &#10;        return availableTables;&#10;    }&#10;    &#10;    /**&#10;     * Load current table status from database&#10;     */&#10;    private void loadTablesFromDatabase() {&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // Reset all tables first&#10;            for (Table table : restaurantTables) {&#10;                table.setOccupied(false);&#10;                table.setBookingStartTime(null);&#10;                table.setBookingEndTime(null);&#10;            }&#10;            &#10;            String sql = &quot;SELECT * FROM table_reservations WHERE booking_end_time &gt; NOW()&quot;;&#10;&#10;            try (Statement stmt = conn.createStatement();&#10;                 ResultSet rs = stmt.executeQuery(sql)) {&#10;&#10;                while (rs.next()) {&#10;                    int tableNumber = rs.getInt(&quot;table_number&quot;);&#10;                    LocalDateTime startTime = rs.getTimestamp(&quot;booking_start_time&quot;).toLocalDateTime();&#10;                    LocalDateTime endTime = rs.getTimestamp(&quot;booking_end_time&quot;).toLocalDateTime();&#10;&#10;                    // Find the table with this number&#10;                    for (Table table : restaurantTables) {&#10;                        if (table.getTableNumber() == tableNumber) {&#10;                            // If this table already has a booking and it's closer to now than the one we just found,&#10;                            // keep the existing booking&#10;                            if (table.getBookingStartTime() != null &amp;&amp;&#10;                                table.getBookingStartTime().isBefore(startTime)) {&#10;                                continue;&#10;                            }&#10;&#10;                            table.setBookingStartTime(startTime);&#10;                            table.setBookingEndTime(endTime);&#10;&#10;                            // If booking start time is now or in the past, mark as occupied&#10;                            if (startTime.isBefore(LocalDateTime.now()) || startTime.isEqual(LocalDateTime.now())) {&#10;                                table.setOccupied(true);&#10;                            }&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while loading table reservations: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Book a table for a customer at a specific time period&#10;     * @param user The user booking the table&#10;     * @param tableNumber The table number to book&#10;     * @param startTime The start time of the booking&#10;     * @param endTime The end time of the booking&#10;     * @return true if booking was successful, false otherwise&#10;     */&#10;    @Override&#10;    public boolean bookTable(User user, int tableNumber, LocalDateTime startTime, LocalDateTime endTime) {&#10;        logger.info(&quot;Customer {} attempting to book a table {} from {} to {}&quot;,&#10;                user.getUsername(), tableNumber, startTime, endTime);&#10;&#10;        try (Connection connection = DatabaseUtil.getConnection()) {&#10;            // Check if the table exists&#10;            PreparedStatement checkTableStmt = connection.prepareStatement(&#10;                    &quot;SELECT * FROM tables WHERE table_number = ?&quot;);&#10;            checkTableStmt.setInt(1, tableNumber);&#10;            ResultSet tableResult = checkTableStmt.executeQuery();&#10;&#10;            if (!tableResult.next()) {&#10;                logger.warn(&quot;Table {} does not exist&quot;, tableNumber);&#10;                return false;&#10;            }&#10;&#10;            // Check if the table is already booked for the requested time period&#10;            PreparedStatement checkBookingStmt = connection.prepareStatement(&#10;                    &quot;SELECT * FROM table_reservations WHERE table_number = ? AND &quot; +&#10;                    &quot;((start_time &lt;= ? AND end_time &gt;= ?) OR &quot; +&#10;                    &quot;(start_time &lt;= ? AND end_time &gt;= ?) OR &quot; +&#10;                    &quot;(start_time &gt;= ? AND end_time &lt;= ?))&quot;);&#10;&#10;            checkBookingStmt.setInt(1, tableNumber);&#10;            checkBookingStmt.setTimestamp(2, Timestamp.valueOf(startTime));&#10;            checkBookingStmt.setTimestamp(3, Timestamp.valueOf(startTime));&#10;            checkBookingStmt.setTimestamp(4, Timestamp.valueOf(endTime));&#10;            checkBookingStmt.setTimestamp(5, Timestamp.valueOf(endTime));&#10;            checkBookingStmt.setTimestamp(6, Timestamp.valueOf(startTime));&#10;            checkBookingStmt.setTimestamp(7, Timestamp.valueOf(endTime));&#10;&#10;            ResultSet bookingResult = checkBookingStmt.executeQuery();&#10;            if (bookingResult.next()) {&#10;                logger.warn(&quot;Table {} is already booked during the requested time period&quot;, tableNumber);&#10;                return false;&#10;            }&#10;            &#10;            // Book the table&#10;            PreparedStatement bookTableStmt = connection.prepareStatement(&#10;                    &quot;INSERT INTO table_reservations (user_id, table_number, start_time, end_time) VALUES (?, ?, ?, ?)&quot;);&#10;            bookTableStmt.setLong(1, user.getId());&#10;            bookTableStmt.setInt(2, tableNumber);&#10;            bookTableStmt.setTimestamp(3, Timestamp.valueOf(startTime));&#10;            bookTableStmt.setTimestamp(4, Timestamp.valueOf(endTime));&#10;&#10;            int rowsAffected = bookTableStmt.executeUpdate();&#10;&#10;            if (rowsAffected &gt; 0) {&#10;                logger.info(&quot;Table {} successfully booked for user {} from {} to {}&quot;,&#10;                        tableNumber, user.getUsername(), startTime, endTime);&#10;                return true;&#10;            } else {&#10;                logger.warn(&quot;Failed to book table {} for user {}&quot;, tableNumber, user.getUsername());&#10;                return false;&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error booking table: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Display available tables at a specific time for a customer to choose from&#10;     * @param user The user viewing available tables&#10;     */&#10;    @Override&#10;    public void viewAndBookTable(User user) {&#10;        logger.info(&quot;Customer {} viewing available tables&quot;, user.getUsername());&#10;        Scanner scanner = new Scanner(System.in);&#10;        &#10;        System.out.println(&quot;\n=== Table Booking ===&quot;);&#10;        System.out.println(&quot;Enter the date and time for your reservation (YYYY-MM-DD HH:MM): &quot;);&#10;        String dateTimeStr = scanner.nextLine();&#10;&#10;        LocalDateTime requestedDateTime;&#10;        try {&#10;            requestedDateTime = LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;));&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Invalid date/time format. Please use YYYY-MM-DD HH:MM format.&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Calculate end time (assuming 2 hours duration)&#10;        LocalDateTime endDateTime = requestedDateTime.plusHours(2);&#10;&#10;        // Get available tables at the requested time&#10;        List&lt;Table&gt; availableTables = getAvailableTablesAtTime(requestedDateTime);&#10;        &#10;        if (availableTables.isEmpty()) {&#10;            System.out.println(&quot;Sorry, there are no tables available at &quot; + requestedDateTime);&#10;            return;&#10;        }&#10;        &#10;        // Display available tables&#10;        System.out.println(&quot;\nAvailable Tables at &quot; + requestedDateTime + &quot;:&quot;);&#10;        for (Table table : availableTables) {&#10;            System.out.println(&quot;Table &quot; + table.getTableNumber() + &quot; - Seats: &quot; + table.getCapacity());&#10;        }&#10;        &#10;        // Ask for table selection&#10;        System.out.print(&quot;\nEnter table number to book (or 0 to cancel): &quot;);&#10;        int tableNumber;&#10;        try {&#10;            tableNumber = Integer.parseInt(scanner.nextLine());&#10;        } catch (NumberFormatException e) {&#10;            System.out.println(&quot;Invalid input. Please enter a number.&quot;);&#10;            return;&#10;        }&#10;        &#10;        if (tableNumber == 0) {&#10;            System.out.println(&quot;Booking canceled.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Check if selected table is in available tables&#10;        boolean isTableAvailable = availableTables.stream()&#10;                .anyMatch(t -&gt; t.getTableNumber() == tableNumber);&#10;&#10;        if (!isTableAvailable) {&#10;            System.out.println(&quot;Invalid table selection or table not available at the requested time.&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Book the table&#10;        boolean success = bookTable(user, tableNumber, requestedDateTime, endDateTime);&#10;&#10;        if (success) {&#10;            System.out.println(&quot;Table &quot; + tableNumber + &quot; successfully booked for &quot; + dateTimeStr);&#10;        } else {&#10;            System.out.println(&quot;Failed to book the table. Please try again later.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.OrderStatus;&#10;import zeta.foods.model.User;&#10;import zeta.foods.model.Recipe;&#10;import zeta.foods.model.Table;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.utils.CurrentInventory;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;import zeta.foods.utils.recipes;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;import org.json.JSONArray;&#10;import org.json.JSONObject;&#10;&#10;/**&#10; * Implementation of CustomerService for handling customer orders&#10; */&#10;public class CustomerServiceImpl implements CustomerService {&#10;    private static final Logger logger = LoggerFactory.getLogger(CustomerServiceImpl.class);&#10;&#10;    private static final Map&lt;String, Order&gt; orders = new HashMap&lt;&gt;();&#10;    private static final Map&lt;Long, List&lt;Order&gt;&gt; customerOrders = new HashMap&lt;&gt;();&#10;    &#10;    // Fixed number of tables in the restaurant&#10;    private static final int TOTAL_TABLES = 12;&#10;    &#10;    // Store restaurant tables&#10;    private static final List&lt;Table&gt; restaurantTables = new ArrayList&lt;&gt;();&#10;    &#10;    // Initialize tables&#10;    static {&#10;        for (int i = 1; i &lt;= TOTAL_TABLES; i++) {&#10;            restaurantTables.add(new Table(i));&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Order placeOrder(User user) {&#10;        Order order = new Order();&#10;&#10;        // Handle case where user ID might be null (for temporary users created by waiters)&#10;        if (user.getId() != null) {&#10;            order.setCustomerId(user.getId());&#10;        } else {&#10;            // For walk-in customers or when waiter creates an order without a registered user&#10;            order.setCustomerId(0L);  // Use 0 to indicate a walk-in customer or temporary user&#10;        }&#10;&#10;        order.setCustomerName(user.getUsername());&#10;&#10;        boolean dbSaveSuccessful = false;&#10;        // Save order to database (initially empty)&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // Use transaction to ensure consistency&#10;            conn.setAutoCommit(false);&#10;&#10;            String sql = &quot;INSERT INTO orders (order_id, customer_id, items, bill_subtotal, order_status) VALUES (?, ?, ?::jsonb, ?, ?)&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, order.getOrderId());&#10;&#10;                // If user ID is null, use 0 for customer_id in database&#10;                if (user.getId() != null) {&#10;                    stmt.setLong(2, user.getId());&#10;                } else {&#10;                    stmt.setLong(2, 0L);&#10;                }&#10;&#10;                stmt.setString(3, &quot;[]&quot;); // Empty JSON array for items initially&#10;                stmt.setDouble(4, 0.0); // Initial subtotal is 0&#10;                stmt.setString(5, order.getStatus().toString());&#10;&#10;                int rowsAffected = stmt.executeUpdate();&#10;&#10;                if (rowsAffected &gt; 0) {&#10;                    // Verify the order was actually saved&#10;                    try (PreparedStatement verifyStmt = conn.prepareStatement(&quot;SELECT COUNT(*) FROM orders WHERE order_id = ?&quot;)) {&#10;                        verifyStmt.setString(1, order.getOrderId());&#10;                        try (ResultSet rs = verifyStmt.executeQuery()) {&#10;                            if (rs.next() &amp;&amp; rs.getInt(1) &gt; 0) {&#10;                                // Order exists in the database&#10;                                conn.commit();&#10;                                dbSaveSuccessful = true;&#10;                                logger.info(&quot;Order {} successfully saved to database and verified&quot;, order.getOrderId());&#10;                            } else {&#10;                                conn.rollback();&#10;                                logger.error(&quot;Order {} insert appeared successful but verification failed&quot;, order.getOrderId());&#10;                            }&#10;                        }&#10;                    }&#10;                } else {&#10;                    conn.rollback();&#10;                    logger.error(&quot;Failed to save order {} to database (no rows affected)&quot;, order.getOrderId());&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while saving order {}: {}&quot;, order.getOrderId(), e.getMessage(), e);&#10;        }&#10;&#10;        // Only store the order in memory if database save was successful&#10;        if (dbSaveSuccessful) {&#10;            // Store order in memory cache&#10;            if (user.getId() != null) {&#10;                if (!customerOrders.containsKey(user.getId())) {&#10;                    customerOrders.put(user.getId(), new ArrayList&lt;&gt;());&#10;                }&#10;                customerOrders.get(user.getId()).add(order);&#10;            }&#10;            orders.put(order.getOrderId(), order);&#10;&#10;            logger.info(&quot;Created new order with ID: {} for customer: {}&quot;, order.getOrderId(), user.getUsername());&#10;            return order;&#10;        } else {&#10;            logger.error(&quot;Order creation failed due to database error. Order ID: {}&quot;, order.getOrderId());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; getCustomerOrders(Long customerId) {&#10;        // Try to get orders from memory first&#10;        List&lt;Order&gt; cachedOrders = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no cached orders, try to load from database&#10;        if (cachedOrders.isEmpty()) {&#10;            return loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        return cachedOrders;&#10;    }&#10;&#10;    private List&lt;Order&gt; loadOrdersFromDatabase(Long customerId) {&#10;        List&lt;Order&gt; result = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;SELECT * FROM orders WHERE customer_id = ? ORDER BY order_timestamp DESC&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setLong(1, customerId);&#10;&#10;                try (ResultSet rs = stmt.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        Order order = new Order();&#10;                        String orderId = rs.getString(&quot;order_id&quot;);&#10;                        order.setOrderId(orderId);&#10;                        order.setCustomerId(customerId);&#10;                        order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                        order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                        // Parse items from JSON&#10;                        String itemsJson = rs.getString(&quot;items&quot;);&#10;                        parseOrderItems(order, itemsJson);&#10;&#10;                        result.add(order);&#10;&#10;                        // Add to cache&#10;                        orders.put(orderId, order);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Update the cache&#10;            if (!result.isEmpty()) {&#10;                customerOrders.put(customerId, result);&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while loading orders: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    private void parseOrderItems(Order order, String itemsJson) {&#10;        try {&#10;            JSONArray itemsArray = new JSONArray(itemsJson);&#10;            for (int i = 0; i &lt; itemsArray.length(); i++) {&#10;                JSONObject itemObj = itemsArray.getJSONObject(i);&#10;                String category = itemObj.getString(&quot;category&quot;);&#10;                String itemName = itemObj.getString(&quot;itemName&quot;);&#10;                double price = itemObj.getDouble(&quot;price&quot;);&#10;                int quantity = itemObj.getInt(&quot;quantity&quot;);&#10;&#10;                OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;                order.addItem(item);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing order items JSON: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Order getOrderStatus(String orderId) {&#10;        // Try to get from cache first&#10;        Order order = orders.get(orderId);&#10;&#10;        // If not in cache, try to load from database&#10;        if (order == null) {&#10;            try (Connection conn = DatabaseUtil.getConnection()) {&#10;                String sql = &quot;SELECT * FROM orders WHERE order_id = ?&quot;;&#10;&#10;                try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                    stmt.setString(1, orderId);&#10;&#10;                    try (ResultSet rs = stmt.executeQuery()) {&#10;                        if (rs.next()) {&#10;                            order = new Order();&#10;                            order.setOrderId(orderId);&#10;                            order.setCustomerId(rs.getLong(&quot;customer_id&quot;));&#10;                            order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                            order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                            // Parse items from JSON&#10;                            String itemsJson = rs.getString(&quot;items&quot;);&#10;                            parseOrderItems(order, itemsJson);&#10;&#10;                            // Add to cache&#10;                            orders.put(orderId, order);&#10;                        }&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Database error while getting order status: {}&quot;, e.getMessage(), e);&#10;            }&#10;        }&#10;&#10;        return order;&#10;    }&#10;&#10;    /**&#10;     * Add an item to an existing order&#10;     *&#10;     * @param orderId   The order ID&#10;     * @param category   Menu category&#10;     * @param itemName  Item name&#10;     * @param quantity  Quantity&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean addItemToOrder(String orderId, String category, String itemName, int quantity) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            logger.warn(&quot;Order not found: {}&quot;, orderId);&#10;            return false;&#10;        }&#10;&#10;        // Get price from menu&#10;        String priceStr = menu.getItemPrice(category, itemName);&#10;        if (priceStr == null) {&#10;            logger.warn(&quot;Item not found in menu: {} in category {}&quot;, itemName, category);&#10;            return false;&#10;        }&#10;&#10;        // Parse price (remove &quot;Rs.&quot; prefix)&#10;        double price = menu.getPriceValue(priceStr);&#10;&#10;        // Check if we have the necessary ingredients for this item&#10;        OrderItem tempItem = new OrderItem(category, itemName, quantity, price);&#10;        List&lt;OrderItem&gt; itemsToCheck = new ArrayList&lt;&gt;();&#10;        itemsToCheck.add(tempItem);&#10;&#10;        // Check ingredient availability before adding to order&#10;        if (!CurrentInventory.checkIngredientsAvailability(itemsToCheck)) {&#10;            logger.warn(&quot;Cannot add {} to order: insufficient ingredients&quot;, itemName);&#10;            logger.info(&quot;Sorry, we don't have enough ingredients to prepare &quot; + itemName + &quot; at this time.&quot;);&#10;            return false;&#10;        }&#10;&#10;        // Add item to order&#10;        OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;        order.addItem(item);&#10;&#10;        // Update the order in the database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First, get all existing items for this order&#10;            String itemsJson = createItemsJson(order);&#10;            logger.debug(&quot;Order subtotal: {}&quot;, order.getTotalAmount());&#10;&#10;            // Check if order exists in database&#10;            try (PreparedStatement checkStmt = conn.prepareStatement(&quot;SELECT COUNT(*) FROM orders WHERE order_id = ?&quot;)) {&#10;                checkStmt.setString(1, orderId);&#10;                try (ResultSet rs = checkStmt.executeQuery()) {&#10;                    if (rs.next() &amp;&amp; rs.getInt(1) == 0) {&#10;                        logger.error(&quot;Order {} does not exist in database&quot;, orderId);&#10;                        return false;&#10;                    }&#10;                }&#10;            }&#10;&#10;            String sql = &quot;UPDATE orders SET items = ?::jsonb, bill_subtotal = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, itemsJson);&#10;                stmt.setDouble(2, order.getTotalAmount());&#10;                stmt.setString(3, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update order {} in database (No rows affected)&quot;, orderId);&#10;                    return false;&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order {}: {}&quot;, orderId, e.getMessage(), e);&#10;            return false;&#10;        }&#10;&#10;        // Deduct ingredients from current inventory&#10;        CurrentInventory.useIngredientsForOrder(itemsToCheck);&#10;        logger.info(&quot;Added item to order {}: {} x{} ({})&quot;,&#10;                orderId, itemName, quantity, priceStr);&#10;        return true;&#10;    }&#10;&#10;    private String createItemsJson(Order order) {&#10;        JSONArray itemsArray = new JSONArray();&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            JSONObject itemObj = new JSONObject();&#10;            itemObj.put(&quot;category&quot;, item.getCategory());&#10;            itemObj.put(&quot;itemName&quot;, item.getItemName());&#10;            itemObj.put(&quot;price&quot;, item.getPrice());&#10;            itemObj.put(&quot;quantity&quot;, item.getQuantity());&#10;            itemsArray.put(itemObj);&#10;        }&#10;&#10;        return itemsArray.toString();&#10;    }&#10;&#10;    /**&#10;     * Update order status&#10;     *&#10;     * @param orderId Order ID&#10;     * @param status  New status&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean updateOrderStatus(String orderId, OrderStatus status) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return false;&#10;        }&#10;        order.setStatus(status);&#10;&#10;        // Update status in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET order_status = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, status.toString());&#10;                stmt.setString(2, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                return rowsUpdated &gt; 0;&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order status: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a specified number of previous orders for a customer, sorted by most recent first&#10;     *&#10;     * @param customerId The customer's ID&#10;     * @param limit      Maximum number of orders to retrieve (default is 1 for latest order)&#10;     * @return List of the customer's orders in descending date order&#10;     */&#10;    public List&lt;Order&gt; getPreviousOrders(Long customerId, int limit) {&#10;        // Check if we have any orders in memory first&#10;        List&lt;Order&gt; customerOrderList = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no orders in memory, try to load from database&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in memory for customer ID: {}, loading from database...&quot;, customerId);&#10;            customerOrderList = loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        // If still empty after trying to load from DB, return empty list&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in database for customer ID: {}&quot;, customerId);&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        // Sort orders by order time, most recent first&#10;        return customerOrderList.stream()&#10;                .sorted(Comparator.comparing(Order::getOrderTime).reversed())&#10;                .limit(limit &gt; 0 ? limit : 1) // Apply limit, with default of 1 if invalid limit&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Format a single order for display&#10;     *&#10;     * @param order The order to format&#10;     * @return Formatted order summary as string&#10;     */&#10;    public String formatOrderSummary(Order order) {&#10;        if (order == null) {&#10;            return &quot;No order information available.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);&#10;&#10;        StringBuilder summary = new StringBuilder();&#10;        summary.append(&quot;\n=================================\n&quot;);&#10;        summary.append(&quot;ORDER SUMMARY\n&quot;);&#10;        summary.append(&quot;=================================\n&quot;);&#10;        summary.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        summary.append(&quot;Date: &quot;).append(order.getOrderTime().format(dateFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Time: &quot;).append(order.getOrderTime().format(timeFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Status: &quot;).append(order.getStatus()).append(&quot;\n&quot;);&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;&#10;        // List items&#10;        summary.append(&quot;ITEMS ORDERED:\n&quot;);&#10;        for (OrderItem item : order.getItems()) {&#10;            summary.append(String.format(&quot;• %d x %s (Rs.%.2f)\n&quot;,&#10;                    item.getQuantity(), item.getItemName(), item.getPrice()));&#10;        }&#10;&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;        summary.append(String.format(&quot;Subtotal: Rs.%.2f\n&quot;, order.getTotalAmount()));&#10;&#10;        // Calculate additional charges&#10;        double serviceCharge = order.getTotalAmount() * 0.02;&#10;        double taxCharge = order.getTotalAmount() &gt; 150 ? 25.0 : 0.0;&#10;        double grandTotal = order.getTotalAmount() + serviceCharge + taxCharge;&#10;&#10;        summary.append(String.format(&quot;Service Charge (2%%): Rs.%.2f\n&quot;, serviceCharge));&#10;        summary.append(String.format(&quot;CGST &amp; SGST: Rs.%.2f\n&quot;, taxCharge));&#10;        summary.append(String.format(&quot;Grand Total: Rs.%.2f\n&quot;, grandTotal));&#10;        summary.append(&quot;=================================\n&quot;);&#10;&#10;        return summary.toString();&#10;    }&#10;&#10;    /**&#10;     * Format multiple orders for display&#10;     *&#10;     * @param orders List of orders to format&#10;     * @return Formatted list of order summaries as string&#10;     */&#10;    public String formatOrdersList(List&lt;Order&gt; orders) {&#10;        if (orders == null || orders.isEmpty()) {&#10;            return &quot;No previous orders found.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;);&#10;&#10;        StringBuilder result = new StringBuilder();&#10;        result.append(&quot;\n=================================\n&quot;);&#10;        result.append(&quot;YOUR ORDER HISTORY\n&quot;);&#10;        result.append(&quot;=================================\n&quot;);&#10;&#10;        int count = 1;&#10;        for (Order order : orders) {&#10;            result.append(String.format(&quot;%d. Order #%s - %s\n&quot;,&#10;                    count++,&#10;                    order.getOrderId(),&#10;                    order.getOrderTime().format(formatter)));&#10;&#10;            result.append(String.format(&quot;   Status: %s, Total: Rs.%.2f\n&quot;,&#10;                    order.getStatus(),&#10;                    order.getTotalAmount()));&#10;&#10;            // Show item count&#10;            result.append(String.format(&quot;   Items: %d\n&quot;, order.getItems().size()));&#10;        }&#10;&#10;        result.append(&quot;=================================\n&quot;);&#10;        return result.toString();&#10;    }&#10;&#10;    /**&#10;     * View order status for a customer with option to specify number of orders to display&#10;     *&#10;     * @param user The user viewing their order history&#10;     */&#10;    public void viewOrderStatus(User user) {&#10;        Scanner scanner = new Scanner(System.in);&#10;        System.out.println(&quot;\n=== Your Order History ===&quot;);&#10;&#10;        // Ask user how many orders they want to view&#10;        System.out.print(&quot;How many recent orders would you like to view? (default: 1): &quot;);&#10;        String input = scanner.nextLine().trim();&#10;&#10;        // Parse input, default to 1 if empty or invalid&#10;        int limit = 1;&#10;        if (!input.isEmpty()) {&#10;            try {&#10;                limit = Integer.parseInt(input);&#10;                if (limit &lt;= 0) {&#10;                    limit = 1;&#10;                    System.out.println(&quot;Invalid number. Showing the most recent order.&quot;);&#10;                }&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Invalid input. Showing the most recent order.&quot;);&#10;            }&#10;        }&#10;&#10;        // Get previous orders for the customer&#10;        List&lt;Order&gt; previousOrders = getPreviousOrders(user.getId(), limit);&#10;&#10;        if (previousOrders.isEmpty()) {&#10;            System.out.println(&quot;You don't have any orders yet.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Display each order&#10;        System.out.printf(&quot;Showing your %d most recent order(s):\n\n&quot;, previousOrders.size());&#10;        for (int i = 0; i &lt; previousOrders.size(); i++) {&#10;            if (i &gt; 0) {&#10;                System.out.println(&quot;\n&quot; + &quot;-&quot;.repeat(40) + &quot;\n&quot;);&#10;            }&#10;            Order order = previousOrders.get(i);&#10;            String formattedOrder = formatOrderSummary(order);&#10;            System.out.println(formattedOrder);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Display the restaurant menu in a two-page format&#10;     * @param scanner Scanner for user input&#10;     */&#10;    public void displayRestaurantMenu(Scanner scanner) {&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 1      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;        String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;        // First page: first half of categories&#10;        int midpoint = categories.length / 2;&#10;        for (int i = 0; i &lt; midpoint; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to see the next page...&quot;);&#10;        scanner.nextLine();&#10;&#10;        // Second page: second half of categories&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 2      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        for (int i = midpoint; i &lt; categories.length; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Display a single menu category&#10;     * @param categoryName Name of the category&#10;     * @param items Map of items and their prices&#10;     */&#10;    private void displayMenuCategory(String categoryName, Map&lt;String, String&gt; items) {&#10;        System.out.println(&quot;\n--- &quot; + categoryName + &quot; ---&quot;);&#10;        for (Map.Entry&lt;String, String&gt; item : items.entrySet()) {&#10;            System.out.printf(&quot;%-30s %10s\n&quot;, item.getKey(), item.getValue());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generate bill for an order&#10;     *&#10;     * @param orderId The order ID&#10;     * @return Formatted bill as String&#10;     */&#10;    public String generateBill(String orderId) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return &quot;Order not found&quot;;&#10;        }&#10;&#10;        // Calculate additional charges&#10;        double subtotal = order.getTotalAmount();&#10;        double serviceCharge = subtotal * 0.02;&#10;        double gst = subtotal * 0.05;&#10;        double finalAmount = subtotal + serviceCharge + gst;&#10;&#10;        // Update order status and payment info in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET &quot; +&#10;                    &quot;bill_subtotal = ?, &quot; +&#10;                    &quot;service_charge = ?, &quot; +&#10;                    &quot;cgst_sgst = ?, &quot; +&#10;                    &quot;bill_total = ?, &quot; +&#10;                    &quot;payment_status = ?, &quot; +&#10;                    &quot;order_status = ? &quot; +&#10;                    &quot;WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setDouble(1, subtotal);&#10;                stmt.setDouble(2, serviceCharge);&#10;                stmt.setDouble(3, gst);&#10;                stmt.setDouble(4, finalAmount);&#10;                stmt.setString(5, &quot;COMPLETED&quot;);&#10;                stmt.setString(6, &quot;COMPLETED&quot;);&#10;                stmt.setString(7, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update bill information in database for order {}&quot;, orderId);&#10;                } else {&#10;                    logger.info(&quot;Bill information saved to database for order {}&quot;, orderId);&#10;                    // Update status in memory too&#10;                    order.setStatus(OrderStatus.COMPLETED);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while generating bill: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        // Build bill content&#10;        StringBuilder bill = new StringBuilder();&#10;        bill.append(&quot;\n==========================================\n&quot;);&#10;        bill.append(&quot;             RESTAURANT BILL              \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Customer: &quot;).append(order.getCustomerName()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Date: &quot;).append(order.getOrderTime().toLocalDate()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Time: &quot;).append(order.getOrderTime().toLocalTime()).append(&quot;\n&quot;);&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %-8s %-10s %-10s\n&quot;, &quot;Item&quot;, &quot;Qty&quot;, &quot;Price&quot;, &quot;Subtotal&quot;));&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            bill.append(String.format(&quot;%-25s %-8d Rs.%-8.2f Rs.%.2f\n&quot;,&#10;                    item.getItemName(), item.getQuantity(), item.getPrice(), item.getSubtotal()));&#10;        }&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Total Amount&quot;, &quot;&quot;, subtotal));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;GST (5%)&quot;, &quot;&quot;, gst));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Service Charge (2%)&quot;, &quot;&quot;, serviceCharge));&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Grand Total&quot;, &quot;&quot;, finalAmount));&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;          Thank You! Visit Again!         \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;&#10;        return bill.toString();&#10;    }&#10;&#10;    /**&#10;     * Book a table for a customer&#10;     * @param user The customer booking the table&#10;     * @param scanner Scanner for user input&#10;     * @return true if booking was successful, false otherwise&#10;     */&#10;    public boolean bookTable(User user, Scanner scanner) {&#10;        logger.info(&quot;Customer {} attempting to book a table&quot;, user.getUsername());&#10;        System.out.println(&quot;\n=== Table Booking ===&quot;);&#10;&#10;        // Get available tables from database&#10;        List&lt;zeta.foods.model.Table&gt; availableTables = getAvailableTables();&#10;&#10;        if (availableTables.isEmpty()) {&#10;            System.out.println(&quot;Sorry, there are no tables available at the moment.&quot;);&#10;            return false;&#10;        }&#10;&#10;        // Display available tables&#10;        System.out.println(&quot;\nAvailable Tables:&quot;);&#10;        for (zeta.foods.model.Table table : availableTables) {&#10;            System.out.println(table.toString());&#10;        }&#10;&#10;        // Ask customer to select a table&#10;        int tableNumber;&#10;        while (true) {&#10;            System.out.print(&quot;\nEnter table number to book (0 to cancel): &quot;);&#10;            try {&#10;                tableNumber = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (tableNumber == 0) {&#10;                    System.out.println(&quot;Booking cancelled.&quot;);&#10;                    return false;&#10;                }&#10;&#10;                // Validate table selection&#10;                boolean validTable = false;&#10;                for (zeta.foods.model.Table table : availableTables) {&#10;                    if (table.getTableNumber() == tableNumber) {&#10;                        validTable = true;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (validTable) {&#10;                    break;&#10;                } else {&#10;                    System.out.println(&quot;Invalid table number. Please select from the available tables.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Book the table (update database)&#10;        boolean success = reserveTable(tableNumber, user.getId());&#10;&#10;        if (success) {&#10;            System.out.println(&quot;\nTable #&quot; + tableNumber + &quot; has been successfully booked for you.&quot;);&#10;            System.out.println(&quot;Please arrive within 30 minutes of your reservation time.&quot;);&#10;            return true;&#10;        } else {&#10;            System.out.println(&quot;\nSorry, there was an error booking your table. Please try again later.&quot;);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get list of available (unoccupied) tables&#10;     * @return List of available tables&#10;     */&#10;    private List&lt;zeta.foods.model.Table&gt; getAvailableTables() {&#10;        List&lt;zeta.foods.model.Table&gt; availableTables = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&#10;                     &quot;SELECT * FROM tables WHERE is_occupied = FALSE ORDER BY table_number&quot;)) {&#10;&#10;            while (rs.next()) {&#10;                zeta.foods.model.Table table = new zeta.foods.model.Table();&#10;                table.setTableNumber(rs.getInt(&quot;table_number&quot;));&#10;                table.setOccupied(false);&#10;                table.setServed(false);&#10;&#10;                availableTables.add(table);&#10;            }&#10;&#10;            logger.info(&quot;Retrieved {} available tables from database&quot;, availableTables.size());&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error retrieving available tables: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return availableTables;&#10;    }&#10;&#10;    /**&#10;     * Reserve a table for a customer&#10;     * @param tableNumber The table number to reserve&#10;     * @param customerId The customer ID making the reservation&#10;     * @return true if reservation was successful, false otherwise&#10;     */&#10;    private boolean reserveTable(int tableNumber, Long customerId) {&#10;        logger.info(&quot;Reserving table #{} for customer ID: {}&quot;, tableNumber, customerId);&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // Start transaction&#10;            conn.setAutoCommit(false);&#10;&#10;            // First check if the table is still available&#10;            try (PreparedStatement checkStmt = conn.prepareStatement(&#10;                    &quot;SELECT * FROM tables WHERE table_number = ? AND is_occupied = FALSE&quot;)) {&#10;&#10;                checkStmt.setInt(1, tableNumber);&#10;                ResultSet rs = checkStmt.executeQuery();&#10;&#10;                if (!rs.next()) {&#10;                    logger.warn(&quot;Table #{} is no longer available&quot;, tableNumber);&#10;                    conn.rollback();&#10;                    return false;&#10;                }&#10;&#10;                int tableId = rs.getInt(&quot;id&quot;);&#10;&#10;                // Update table status to occupied&#10;                try (PreparedStatement updateStmt = conn.prepareStatement(&#10;                        &quot;UPDATE tables SET is_occupied = TRUE, booking_start_time = NOW() WHERE id = ?&quot;)) {&#10;&#10;                    updateStmt.setInt(1, tableId);&#10;                    updateStmt.executeUpdate();&#10;                }&#10;&#10;                // Create reservation record&#10;                try (PreparedStatement reserveStmt = conn.prepareStatement(&#10;                        &quot;INSERT INTO table_reservations (table_id, customer_id, reservation_time, status) &quot; +&#10;                                &quot;VALUES (?, ?, NOW(), 'active')&quot;)) {&#10;&#10;                    reserveStmt.setInt(1, tableId);&#10;                    reserveStmt.setLong(2, customerId);&#10;                    reserveStmt.executeUpdate();&#10;                }&#10;&#10;                // Commit transaction&#10;                conn.commit();&#10;                logger.info(&quot;Table #{} successfully reserved for customer ID: {}&quot;, tableNumber, customerId);&#10;                return true;&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error reserving table: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Table&gt; getAvailableTablesAtTime(LocalDateTime requestedDateTime) {&#10;        // Get all bookings that overlap with the requested time&#10;        List&lt;Table&gt; availableTables = new ArrayList&lt;&gt;();&#10;        &#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First load all tables with their current booking status&#10;            loadTablesFromDatabase();&#10;            &#10;            // Check each table if it's available at the requested time&#10;            for (Table table : restaurantTables) {&#10;                boolean isAvailable = true;&#10;                &#10;                // If table has booking times, check if they overlap with requested time&#10;                if (table.getBookingStartTime() != null &amp;&amp; table.getBookingEndTime() != null) {&#10;                    // Check if requested time falls within the booking period&#10;                    if (!(requestedDateTime.isBefore(table.getBookingStartTime()) || &#10;                          requestedDateTime.isAfter(table.getBookingEndTime()))) {&#10;                        isAvailable = false;&#10;                    }&#10;                }&#10;                &#10;                if (isAvailable) {&#10;                    availableTables.add(table);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while checking table availability: {}&quot;, e.getMessage(), e);&#10;        }&#10;        &#10;        return availableTables;&#10;    }&#10;    &#10;    /**&#10;     * Load current table status from database&#10;     */&#10;    private void loadTablesFromDatabase() {&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // Reset all tables first&#10;            for (Table table : restaurantTables) {&#10;                table.setOccupied(false);&#10;                table.setBookingStartTime(null);&#10;                table.setBookingEndTime(null);&#10;            }&#10;            &#10;            // Get all tables and their status&#10;            String sql = &quot;SELECT * FROM tables&quot;;&#10;            try (Statement stmt = conn.createStatement();&#10;                 ResultSet rs = stmt.executeQuery(sql)) {&#10;                &#10;                while (rs.next()) {&#10;                    int tableNumber = rs.getInt(&quot;table_number&quot;);&#10;                    boolean isOccupied = rs.getBoolean(&quot;is_occupied&quot;);&#10;                    &#10;                    // Find matching table in our list&#10;                    for (Table table : restaurantTables) {&#10;                        if (table.getTableNumber() == tableNumber) {&#10;                            table.setOccupied(isOccupied);&#10;                            &#10;                            // Set booking time if available&#10;                            Timestamp bookingTime = rs.getTimestamp(&quot;booking_start_time&quot;);&#10;                            if (bookingTime != null) {&#10;                                LocalDateTime startTime = bookingTime.toLocalDateTime();&#10;                                table.setBookingStartTime(startTime);&#10;                                // Estimate end time as 2 hours after start time&#10;                                table.setBookingEndTime(startTime.plusHours(2));&#10;                            }&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while loading tables: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Book a table for a customer at a specific time period&#10;     * @param user The user booking the table&#10;     * @param tableNumber The table number to book&#10;     * @param startTime The start time of the booking&#10;     * @param endTime The end time of the booking&#10;     * @return true if booking was successful, false otherwise&#10;     */&#10;    @Override&#10;    public boolean bookTable(User user, int tableNumber, LocalDateTime startTime, LocalDateTime endTime) {&#10;        logger.info(&quot;Customer {} attempting to book a table {} from {} to {}&quot;, &#10;                user.getUsername(), tableNumber, startTime, endTime);&#10;        &#10;        try (Connection connection = DatabaseUtil.getConnection()) {&#10;            // First check if the table exists&#10;            PreparedStatement checkTableStmt = connection.prepareStatement(&#10;                    &quot;SELECT id FROM tables WHERE table_number = ?&quot;);&#10;            checkTableStmt.setInt(1, tableNumber);&#10;            ResultSet tableResult = checkTableStmt.executeQuery();&#10;            &#10;            if (!tableResult.next()) {&#10;                logger.warn(&quot;Table {} does not exist&quot;, tableNumber);&#10;                return false;&#10;            }&#10;            &#10;            int tableId = tableResult.getInt(&quot;id&quot;);&#10;            &#10;            // Check if the table is already occupied&#10;            PreparedStatement checkOccupiedStmt = connection.prepareStatement(&#10;                    &quot;SELECT is_occupied FROM tables WHERE id = ?&quot;);&#10;            checkOccupiedStmt.setInt(1, tableId);&#10;            ResultSet occupiedResult = checkOccupiedStmt.executeQuery();&#10;            &#10;            if (occupiedResult.next() &amp;&amp; occupiedResult.getBoolean(&quot;is_occupied&quot;)) {&#10;                logger.warn(&quot;Table {} is already occupied&quot;, tableNumber);&#10;                return false;&#10;            }&#10;            &#10;            // Set table as occupied and update booking_start_time&#10;            PreparedStatement updateTableStmt = connection.prepareStatement(&#10;                    &quot;UPDATE tables SET is_occupied = TRUE, booking_start_time = ? WHERE id = ?&quot;);&#10;            updateTableStmt.setTimestamp(1, Timestamp.valueOf(startTime));&#10;            updateTableStmt.setInt(2, tableId);&#10;            updateTableStmt.executeUpdate();&#10;            &#10;            // Insert reservation record&#10;            PreparedStatement reservationStmt = connection.prepareStatement(&#10;                    &quot;INSERT INTO table_reservations (table_id, customer_id, reservation_time, status) VALUES (?, ?, ?, 'active')&quot;);&#10;            reservationStmt.setInt(1, tableId);&#10;            reservationStmt.setLong(2, user.getId());&#10;            reservationStmt.setTimestamp(3, Timestamp.valueOf(startTime));&#10;            int rowsAffected = reservationStmt.executeUpdate();&#10;            &#10;            if (rowsAffected &gt; 0) {&#10;                logger.info(&quot;Table {} successfully booked for user {} from {} to {}&quot;, &#10;                        tableNumber, user.getUsername(), startTime, endTime);&#10;                return true;&#10;            } else {&#10;                logger.warn(&quot;Failed to book table {} for user {}&quot;, tableNumber, user.getUsername());&#10;                return false;&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error booking table: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Display available tables at a specific time for a customer to choose from&#10;     * @param user The user viewing available tables&#10;     */&#10;    @Override&#10;    public void viewAndBookTable(User user) {&#10;        logger.info(&quot;Customer {} viewing available tables&quot;, user.getUsername());&#10;        Scanner scanner = new Scanner(System.in);&#10;        &#10;        System.out.println(&quot;\n=== Table Booking ===&quot;);&#10;        System.out.println(&quot;Enter the date and time for your reservation (YYYY-MM-DD HH:MM): &quot;);&#10;        String dateTimeStr = scanner.nextLine();&#10;&#10;        LocalDateTime requestedDateTime;&#10;        try {&#10;            requestedDateTime = LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;));&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Invalid date/time format. Please use YYYY-MM-DD HH:MM format.&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Calculate end time (assuming 2 hours duration)&#10;        LocalDateTime endDateTime = requestedDateTime.plusHours(2);&#10;&#10;        // Get available tables at the requested time&#10;        List&lt;Table&gt; availableTables = getAvailableTablesAtTime(requestedDateTime);&#10;        &#10;        if (availableTables.isEmpty()) {&#10;            System.out.println(&quot;Sorry, there are no tables available at &quot; + requestedDateTime);&#10;            return;&#10;        }&#10;        &#10;        // Display available tables&#10;        System.out.println(&quot;\nAvailable Tables at &quot; + requestedDateTime + &quot;:&quot;);&#10;        for (Table table : availableTables) {&#10;            System.out.println(&quot;Table &quot; + table.getTableNumber() + &quot; - Seats: &quot; + table.getCapacity());&#10;        }&#10;        &#10;        // Ask for table selection&#10;        System.out.print(&quot;\nEnter table number to book (or 0 to cancel): &quot;);&#10;        int tableNumber;&#10;        try {&#10;            tableNumber = Integer.parseInt(scanner.nextLine());&#10;        } catch (NumberFormatException e) {&#10;            System.out.println(&quot;Invalid input. Please enter a number.&quot;);&#10;            return;&#10;        }&#10;        &#10;        if (tableNumber == 0) {&#10;            System.out.println(&quot;Booking canceled.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Check if selected table is in available tables&#10;        boolean isTableAvailable = availableTables.stream()&#10;                .anyMatch(t -&gt; t.getTableNumber() == tableNumber);&#10;&#10;        if (!isTableAvailable) {&#10;            System.out.println(&quot;Invalid table selection or table not available at the requested time.&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Book the table&#10;        boolean success = bookTable(user, tableNumber, requestedDateTime, endDateTime);&#10;&#10;        if (success) {&#10;            System.out.println(&quot;Table &quot; + tableNumber + &quot; successfully booked for &quot; + dateTimeStr);&#10;        } else {&#10;            System.out.println(&quot;Failed to book the table. Please try again later.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/FirebaseAuthServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/FirebaseAuthServiceImpl.java" />
              <option name="originalContent" value="package zeta.foods.service.impl;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseAuthException;&#10;import com.google.firebase.auth.UserRecord;&#10;import com.google.firebase.auth.UserRecord.CreateRequest;&#10;import zeta.foods.service.FirebaseAuthService;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class FirebaseAuthServiceImpl implements FirebaseAuthService {&#10;&#10;    private static final String ADMIN_EMAIL = &quot;ambatisaiteja123@gmail.com&quot;;&#10;&#10;    // Predefined waiter accounts&#10;    private static final Map&lt;String, String&gt; WAITERS = new HashMap&lt;&gt;();&#10;&#10;    static {&#10;        // Initialize waiters with email and password &quot;12345678&quot;&#10;        WAITERS.put(&quot;waiter1@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter2@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter3@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter4@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter5@restaurant.com&quot;, &quot;12345678&quot;);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord authenticateUser(String email, String password) {&#10;        try {&#10;            // For admin authentication&#10;            if (email.equals(ADMIN_EMAIL) || WAITERS.containsKey(email)) {&#10;                // In real implementation, this would verify the password with Firebase&#10;                // Here we're just checking if it's a known user&#10;                return FirebaseAuth.getInstance().getUserByEmail(email);&#10;            }&#10;            return null;&#10;        } catch (FirebaseAuthException e) {&#10;            System.err.println(&quot;Authentication failed: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean isAdmin(String email) {&#10;        return email.equals(ADMIN_EMAIL);&#10;    }&#10;&#10;    @Override&#10;    public boolean isWaiter(String email) {&#10;        return WAITERS.containsKey(email);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord createUser(String email, String password, boolean isAdmin) {&#10;        CreateRequest request = new CreateRequest()&#10;                .setEmail(email)&#10;                .setPassword(password)&#10;                .setEmailVerified(true);&#10;&#10;        try {&#10;            UserRecord userRecord = FirebaseAuth.getInstance().createUser(request);&#10;&#10;            // Add custom claims for role-based access&#10;            Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();&#10;            claims.put(&quot;admin&quot;, isAdmin);&#10;            claims.put(&quot;waiter&quot;, !isAdmin);&#10;&#10;            FirebaseAuth.getInstance().setCustomUserClaims(userRecord.getUid(), claims);&#10;&#10;            return userRecord;&#10;        } catch (FirebaseAuthException e) {&#10;            System.err.println(&quot;Error creating user: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    // Method to create predefined users if they don't exist&#10;    public void setupPredefinedUsers() {&#10;        try {&#10;            // Try to create admin&#10;            try {&#10;                FirebaseAuth.getInstance().getUserByEmail(ADMIN_EMAIL);&#10;            } catch (FirebaseAuthException e) {&#10;                // User doesn't exist, create it&#10;                createUser(ADMIN_EMAIL, &quot;admin123&quot;, true);&#10;                System.out.println(&quot;Created admin user: &quot; + ADMIN_EMAIL);&#10;            }&#10;&#10;            // Create waiter accounts&#10;            for (String waiterEmail : WAITERS.keySet()) {&#10;                try {&#10;                    FirebaseAuth.getInstance().getUserByEmail(waiterEmail);&#10;                } catch (FirebaseAuthException e) {&#10;                    // User doesn't exist, create it&#10;                    createUser(waiterEmail, WAITERS.get(waiterEmail), false);&#10;                    System.out.println(&quot;Created waiter user: &quot; + waiterEmail);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error setting up predefined users: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service.impl;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseAuthException;&#10;import com.google.firebase.auth.UserRecord;&#10;import com.google.firebase.auth.UserRecord.CreateRequest;&#10;import zeta.foods.service.FirebaseAuthService;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class FirebaseAuthServiceImpl implements FirebaseAuthService {&#10;&#10;    private static final String ADMIN_EMAIL = &quot;ambatisaiteja123@gmail.com&quot;;&#10;&#10;    // Predefined waiter accounts&#10;    private static final Map&lt;String, String&gt; WAITERS = new HashMap&lt;&gt;();&#10;&#10;    static {&#10;        // Initialize waiters with email and password &quot;12345678&quot;&#10;        WAITERS.put(&quot;waiter1@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter2@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter3@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter4@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter5@restaurant.com&quot;, &quot;12345678&quot;);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord authenticateUser(String email, String password) {&#10;        try {&#10;            // For test mode, we'll simulate authentication with predefined accounts&#10;            if ((email.equals(ADMIN_EMAIL) || WAITERS.containsKey(email)) &amp;&amp;&#10;                    password.equals(&quot;12345678&quot;)) {&#10;&#10;                // Create a mock UserRecord for testing purposes&#10;                // In production, this would verify with Firebase&#10;                System.out.println(&quot;Test authentication successful for: &quot; + email);&#10;                return createMockUserRecord(email);&#10;            }&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Authentication failed: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private UserRecord createMockUserRecord(String email) {&#10;        // Use anonymous class to create a mock UserRecord&#10;        return new UserRecord() {&#10;            @Override&#10;            public String getUid() {&#10;                return &quot;test-uid-&quot; + email.hashCode();&#10;            }&#10;&#10;            @Override&#10;            public String getEmail() {&#10;                return email;&#10;            }&#10;&#10;            @Override&#10;            public boolean isEmailVerified() {&#10;                return true;&#10;            }&#10;&#10;            // Implement other required methods with defaults&#10;            @Override&#10;            public String getDisplayName() {&#10;                return null;&#10;            }&#10;&#10;            @Override&#10;            public String getPhotoUrl() {&#10;                return null;&#10;            }&#10;&#10;            @Override&#10;            public String getPhoneNumber() {&#10;                return null;&#10;            }&#10;&#10;            @Override&#10;            public boolean isDisabled() {&#10;                return false;&#10;            }&#10;&#10;            @Override&#10;            public UserRecord.UserMetadata getUserMetadata() {&#10;                return new UserRecord.UserMetadata(System.currentTimeMillis(), System.currentTimeMillis());&#10;            }&#10;&#10;            @Override&#10;            public UserRecord.ProviderUserInfo[] getProviderData() {&#10;                return new UserRecord.ProviderUserInfo[0];&#10;            }&#10;&#10;            @Override&#10;            public Map&lt;String, Object&gt; getCustomClaims() {&#10;                return new HashMap&lt;&gt;();&#10;            }&#10;&#10;            @Override&#10;            public long getTokensValidAfterTimestamp() {&#10;                return 0;&#10;            }&#10;&#10;            @Override&#10;            public String getTenantId() {&#10;                return null;&#10;            }&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public boolean isAdmin(String email) {&#10;        return email.equals(ADMIN_EMAIL);&#10;    }&#10;&#10;    @Override&#10;    public boolean isWaiter(String email) {&#10;        return WAITERS.containsKey(email);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord createUser(String email, String password, boolean isAdmin) {&#10;        CreateRequest request = new CreateRequest()&#10;                .setEmail(email)&#10;                .setPassword(password)&#10;                .setEmailVerified(true);&#10;&#10;        try {&#10;            UserRecord userRecord = FirebaseAuth.getInstance().createUser(request);&#10;&#10;            // Add custom claims for role-based access&#10;            Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();&#10;            claims.put(&quot;admin&quot;, isAdmin);&#10;            claims.put(&quot;waiter&quot;, !isAdmin);&#10;&#10;            FirebaseAuth.getInstance().setCustomUserClaims(userRecord.getUid(), claims);&#10;&#10;            return userRecord;&#10;        } catch (FirebaseAuthException e) {&#10;            System.err.println(&quot;Error creating user: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    // Method to create predefined users if they don't exist&#10;    public void setupPredefinedUsers() {&#10;        try {&#10;            // Try to create admin&#10;            try {&#10;                FirebaseAuth.getInstance().getUserByEmail(ADMIN_EMAIL);&#10;            } catch (FirebaseAuthException e) {&#10;                // User doesn't exist, create it&#10;                createUser(ADMIN_EMAIL, &quot;admin123&quot;, true);&#10;                System.out.println(&quot;Created admin user: &quot; + ADMIN_EMAIL);&#10;            }&#10;&#10;            // Create waiter accounts&#10;            for (String waiterEmail : WAITERS.keySet()) {&#10;                try {&#10;                    FirebaseAuth.getInstance().getUserByEmail(waiterEmail);&#10;                } catch (FirebaseAuthException e) {&#10;                    // User doesn't exist, create it&#10;                    createUser(waiterEmail, WAITERS.get(waiterEmail), false);&#10;                    System.out.println(&quot;Created waiter user: &quot; + waiterEmail);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error setting up predefined users: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>