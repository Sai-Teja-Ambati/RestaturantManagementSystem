<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="FROM maven:3.8-eclipse-temurin-17 AS build&#10;&#10;# Set up working directory for building&#10;WORKDIR /app&#10;&#10;# Copy project files&#10;COPY pom.xml .&#10;COPY src ./src&#10;&#10;# Build the application with explicit output&#10;RUN echo &quot;Starting Maven build...&quot; &amp;&amp; \&#10;    mvn clean compile package -DskipTests -X &amp;&amp; \&#10;    echo &quot;Build completed. Checking target directory:&quot; &amp;&amp; \&#10;    ls -la /app/target/&#10;&#10;# Verify the JAR file was created&#10;RUN if [ ! -f &quot;/app/target/restaurant-management-system-1.0.0.jar&quot; ]; then \&#10;        echo &quot;ERROR: JAR file not found! Available files:&quot;; \&#10;        ls -la /app/target/; \&#10;        exit 1; \&#10;    else \&#10;        echo &quot;SUCCESS: JAR file created successfully&quot;; \&#10;        ls -la /app/target/restaurant-management-system-1.0.0.jar; \&#10;    fi&#10;&#10;# Runtime stage&#10;FROM eclipse-temurin:17-jre&#10;&#10;# Install PostgreSQL client and other utilities&#10;RUN apt-get update &amp;&amp; \&#10;    apt-get install -y postgresql-client curl &amp;&amp; \&#10;    apt-get clean &amp;&amp; \&#10;    rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Copy the JAR file from build stage&#10;COPY --from=build /app/target/restaurant-management-system-1.0.0.jar /app/app.jar&#10;&#10;# Copy resources&#10;COPY --from=build /app/src/main/resources/ /app/resources/&#10;&#10;# Verify JAR file exists in runtime&#10;RUN ls -la /app/ &amp;&amp; \&#10;    echo &quot;Verifying JAR contents:&quot; &amp;&amp; \&#10;    jar -tf /app/app.jar | head -20&#10;&#10;# Expose the port&#10;EXPOSE 8080&#10;&#10;# Set environment variables&#10;ENV JAVA_OPTS=&quot;-Xmx512m -Xms256m&quot;&#10;&#10;# Run the application&#10;CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]&#10;&#10;" />
              <option name="updatedContent" value="FROM maven:3.8-eclipse-temurin-17 AS build&#10;&#10;# Set up working directory for building&#10;WORKDIR /app&#10;&#10;# Copy project files&#10;COPY pom.xml .&#10;COPY src ./src&#10;&#10;# Build the application with explicit output&#10;RUN echo &quot;Starting Maven build...&quot; &amp;&amp; \&#10;    mvn clean compile package -DskipTests -X &amp;&amp; \&#10;    echo &quot;Build completed. Checking target directory:&quot; &amp;&amp; \&#10;    ls -la /app/target/&#10;&#10;# Verify the JAR file was created&#10;RUN if [ ! -f &quot;/app/target/restaurant-management-system-1.0.0.jar&quot; ]; then \&#10;        echo &quot;ERROR: JAR file not found! Available files:&quot;; \&#10;        ls -la /app/target/; \&#10;        exit 1; \&#10;    else \&#10;        echo &quot;SUCCESS: JAR file created successfully&quot;; \&#10;        ls -la /app/target/restaurant-management-system-1.0.0.jar; \&#10;    fi&#10;&#10;# Runtime stage&#10;FROM eclipse-temurin:17-jre&#10;&#10;# Install PostgreSQL client and other utilities&#10;RUN apt-get update &amp;&amp; \&#10;    apt-get install -y postgresql-client curl &amp;&amp; \&#10;    apt-get clean &amp;&amp; \&#10;    rm -rf /var/lib/apt/lists/*&#10;&#10;WORKDIR /app&#10;&#10;# Copy the JAR file from build stage&#10;COPY --from=build /app/target/restaurant-management-system-1.0.0.jar /app/app.jar&#10;&#10;# Copy resources&#10;COPY --from=build /app/src/main/resources/ /app/resources/&#10;&#10;# Verify JAR file exists in runtime&#10;RUN ls -la /app/ &amp;&amp; \&#10;    echo &quot;Verifying JAR contents:&quot; &amp;&amp; \&#10;    jar -tf /app/app.jar | head -20&#10;&#10;# Expose the port&#10;EXPOSE 8080&#10;&#10;# Set proper terminal environment for interactive input&#10;ENV TERM=xterm&#10;&#10;# Set command to run with the -i flag to ensure System.in works properly&#10;ENTRYPOINT [&quot;java&quot;, &quot;-Dfile.encoding=UTF-8&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/001_create_migrations_table.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/001_create_migrations_table.sql" />
              <option name="originalContent" value="-- Migration: Create migrations table&#10;CREATE TABLE IF NOT EXISTS migrations (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', 'admin123', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '12345678', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', 'customer1', 'customer')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Migration: Create orders table&#10;CREATE TABLE IF NOT EXISTS orders (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id VARCHAR(50) NOT NULL UNIQUE,&#10;    customer_id BIGINT REFERENCES users(id),&#10;    order_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    items JSONB NOT NULL, -- Stores food items and their prices as JSON&#10;    bill_subtotal NUMERIC(10, 2) NOT NULL,&#10;    cgst_sgst NUMERIC(10, 2) DEFAULT 0, -- Combined CGST and SGST charges&#10;    service_charge NUMERIC(10, 2) DEFAULT 0,&#10;    bill_total NUMERIC(10, 2) NOT NULL,&#10;    payment_status VARCHAR(20) DEFAULT 'PENDING',&#10;    order_status VARCHAR(20) DEFAULT 'PENDING',&#10;    table_number INT,&#10;    special_instructions TEXT&#10;);&#10;&#10;-- Create index on order_id for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_order_id ON orders (order_id);&#10;&#10;-- Create index on customer_id for faster customer order lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders (customer_id);&#10;&#10;-- Create trigger function to automatically calculate CGST and SGST charges&#10;CREATE OR REPLACE FUNCTION calculate_taxes_and_total()&#10;RETURNS TRIGGER AS $$&#10;BEGIN&#10;    -- Calculate service charge (2%)&#10;    NEW.service_charge = ROUND(NEW.bill_subtotal * 0.02, 2);&#10;&#10;    -- Add CGST and SGST charges (fixed Rs.25 if bill &gt; 150)&#10;    IF NEW.bill_subtotal &gt; 150 THEN&#10;        NEW.cgst_sgst = 25.00;&#10;    ELSE&#10;        NEW.cgst_sgst = 0.00;&#10;    END IF;&#10;&#10;    -- Calculate total bill&#10;    NEW.bill_total = NEW.bill_subtotal + NEW.service_charge + NEW.cgst_sgst;&#10;&#10;    RETURN NEW;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;-- Create trigger to automatically calculate taxes and total before insert&#10;CREATE TRIGGER calculate_order_totals&#10;BEFORE INSERT OR UPDATE ON orders&#10;FOR EACH ROW&#10;EXECUTE FUNCTION calculate_taxes_and_total();&#10;&#10;INSERT INTO orders (order_id, customer_id, items, bill_subtotal)&#10;VALUES (&#10;    'ORD-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8),&#10;    (SELECT id FROM users WHERE email = 'customer1@example.com' LIMIT 1),&#10;    '[&#10;        {&quot;category&quot;: &quot;Veg Starters&quot;, &quot;itemName&quot;: &quot;Paneer Tikka&quot;, &quot;price&quot;: 249, &quot;quantity&quot;: 1},&#10;        {&quot;category&quot;: &quot;Indian Breads&quot;, &quot;itemName&quot;: &quot;Butter Naan&quot;, &quot;price&quot;: 50, &quot;quantity&quot;: 2}&#10;    ]'::JSONB,&#10;    349.00&#10;);&#10;&#10;-- Create tables table for tracking restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    is_served BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);&#10;" />
              <option name="updatedContent" value="-- Migration: Create migrations table&#10;CREATE TABLE IF NOT EXISTS migrations (&#10;    id SERIAL PRIMARY KEY,&#10;    name VARCHAR(255) NOT NULL,&#10;    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;);&#10;&#10;-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', 'admin123', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '12345678', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', 'customer1', 'customer')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Migration: Create orders table&#10;CREATE TABLE IF NOT EXISTS orders (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id VARCHAR(50) NOT NULL UNIQUE,&#10;    customer_id BIGINT REFERENCES users(id),&#10;    order_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    items JSONB NOT NULL, -- Stores food items and their prices as JSON&#10;    bill_subtotal NUMERIC(10, 2) NOT NULL,&#10;    cgst_sgst NUMERIC(10, 2) DEFAULT 0, -- Combined CGST and SGST charges&#10;    service_charge NUMERIC(10, 2) DEFAULT 0,&#10;    bill_total NUMERIC(10, 2) NOT NULL,&#10;    payment_status VARCHAR(20) DEFAULT 'PENDING',&#10;    order_status VARCHAR(20) DEFAULT 'PENDING',&#10;    table_number INT,&#10;    special_instructions TEXT&#10;);&#10;&#10;-- Create index on order_id for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_order_id ON orders (order_id);&#10;&#10;-- Create index on customer_id for faster customer order lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders (customer_id);&#10;&#10;-- Create trigger function to automatically calculate CGST and SGST charges&#10;CREATE OR REPLACE FUNCTION calculate_taxes_and_total()&#10;RETURNS TRIGGER AS $$&#10;BEGIN&#10;    -- Calculate service charge (2%)&#10;    NEW.service_charge = ROUND(NEW.bill_subtotal * 0.02, 2);&#10;&#10;    -- Add CGST and SGST charges (fixed Rs.25 if bill &gt; 150)&#10;    IF NEW.bill_subtotal &gt; 150 THEN&#10;        NEW.cgst_sgst = 25.00;&#10;    ELSE&#10;        NEW.cgst_sgst = 0.00;&#10;    END IF;&#10;&#10;    -- Calculate total bill&#10;    NEW.bill_total = NEW.bill_subtotal + NEW.service_charge + NEW.cgst_sgst;&#10;&#10;    RETURN NEW;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;-- Create trigger to automatically calculate taxes and total before insert&#10;DO $$&#10;BEGIN&#10;    IF NOT EXISTS (&#10;        SELECT 1 FROM pg_trigger &#10;        WHERE tgname = 'calculate_order_totals'&#10;    ) THEN&#10;        CREATE TRIGGER calculate_order_totals&#10;        BEFORE INSERT OR UPDATE ON orders&#10;        FOR EACH ROW&#10;        EXECUTE FUNCTION calculate_taxes_and_total();&#10;    END IF;&#10;END $$;&#10;&#10;INSERT INTO orders (order_id, customer_id, items, bill_subtotal)&#10;VALUES (&#10;    'ORD-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8),&#10;    (SELECT id FROM users WHERE email = 'customer1@example.com' LIMIT 1),&#10;    '[&#10;        {&quot;category&quot;: &quot;Veg Starters&quot;, &quot;itemName&quot;: &quot;Paneer Tikka&quot;, &quot;price&quot;: 249, &quot;quantity&quot;: 1},&#10;        {&quot;category&quot;: &quot;Indian Breads&quot;, &quot;itemName&quot;: &quot;Butter Naan&quot;, &quot;price&quot;: 50, &quot;quantity&quot;: 2}&#10;    ]'::JSONB,&#10;    349.00&#10;);&#10;&#10;-- Create tables table for tracking restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    is_served BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/002_create_users_table.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/002_create_users_table.sql" />
              <option name="originalContent" value="-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password: admin123)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', '$2a$10$kK7yXYZNNJ/3MQyK.Qwc6ekhDiwcldY7.5e4qlJUFpiiXIQxbeBJO', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password: 12345678 for all)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', '$2a$10$KS1TP5aH0ulsaHxODfvdveDpjGDjO7jlBs3KDGa8CigmJ2em1LC9G', 'customer')&#10;ON CONFLICT (email) DO NOTHING;&#10;" />
              <option name="updatedContent" value="-- Migration: Create users table&#10;CREATE TABLE IF NOT EXISTS users (&#10;    id SERIAL PRIMARY KEY,&#10;    username VARCHAR(100) NOT NULL UNIQUE,&#10;    email VARCHAR(100) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'waiter', 'customer')),&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    last_login TIMESTAMP WITH TIME ZONE&#10;);&#10;&#10;-- Create an admin user (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('admin', 'ambatisaiteja123@gmail.com', 'admin123', 'admin')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create waiter users (password in plain text)&#10;INSERT INTO users (username, email, password, role)&#10;VALUES&#10;    ('waiter1', 'waiter1@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter2', 'waiter2@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter3', 'waiter3@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter4', 'waiter4@restaurant.com', '12345678', 'waiter'),&#10;    ('waiter5', 'waiter5@restaurant.com', '12345678', 'waiter')&#10;ON CONFLICT (email) DO NOTHING;&#10;&#10;-- Create a sample customer&#10;INSERT INTO users (username, email, password, role)&#10;VALUES ('customer1', 'customer1@example.com', '12345678', 'customer')&#10;ON CONFLICT (email) DO NOTHING;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/003_create_orders_table.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/003_create_orders_table.sql" />
              <option name="updatedContent" value="-- Migration: Create orders table&#10;CREATE TABLE IF NOT EXISTS orders (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id VARCHAR(50) NOT NULL UNIQUE,&#10;    customer_id BIGINT REFERENCES users(id),&#10;    order_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,&#10;    items JSONB NOT NULL, -- Stores food items and their prices as JSON&#10;    bill_subtotal NUMERIC(10, 2) NOT NULL,&#10;    cgst_sgst NUMERIC(10, 2) DEFAULT 0, -- Combined CGST and SGST charges&#10;    service_charge NUMERIC(10, 2) DEFAULT 0,&#10;    bill_total NUMERIC(10, 2) NOT NULL,&#10;    payment_status VARCHAR(20) DEFAULT 'PENDING',&#10;    order_status VARCHAR(20) DEFAULT 'PENDING',&#10;    table_number INT,&#10;    special_instructions TEXT&#10;);&#10;&#10;-- Create index on order_id for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_order_id ON orders (order_id);&#10;&#10;-- Create index on customer_id for faster customer order lookups&#10;CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders (customer_id);&#10;&#10;-- Create trigger function to automatically calculate CGST and SGST charges&#10;CREATE OR REPLACE FUNCTION calculate_taxes_and_total()&#10;RETURNS TRIGGER AS $$&#10;BEGIN&#10;    -- Calculate service charge (2%)&#10;    NEW.service_charge = ROUND(NEW.bill_subtotal * 0.02, 2);&#10;    &#10;    -- Add CGST and SGST charges (fixed Rs.25 if bill &gt; 150)&#10;    IF NEW.bill_subtotal &gt; 150 THEN&#10;        NEW.cgst_sgst = 25.00;&#10;    ELSE&#10;        NEW.cgst_sgst = 0.00;&#10;    END IF;&#10;    &#10;    -- Calculate total bill&#10;    NEW.bill_total = NEW.bill_subtotal + NEW.service_charge + NEW.cgst_sgst;&#10;    &#10;    RETURN NEW;&#10;END;&#10;$$ LANGUAGE plpgsql;&#10;&#10;-- Create trigger to automatically calculate taxes and total before insert&#10;CREATE TRIGGER calculate_order_totals&#10;BEFORE INSERT OR UPDATE ON orders&#10;FOR EACH ROW&#10;EXECUTE FUNCTION calculate_taxes_and_total();&#10;&#10;-- Sample order for testing (optional)&#10;INSERT INTO orders (order_id, customer_id, items, bill_subtotal)&#10;VALUES (&#10;    'ORD-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 8),&#10;    (SELECT id FROM users WHERE email = 'customer1@example.com' LIMIT 1),&#10;    '[&#10;        {&quot;category&quot;: &quot;Veg Starters&quot;, &quot;itemName&quot;: &quot;Paneer Tikka&quot;, &quot;price&quot;: 249, &quot;quantity&quot;: 1},&#10;        {&quot;category&quot;: &quot;Indian Breads&quot;, &quot;itemName&quot;: &quot;Butter Naan&quot;, &quot;price&quot;: 50, &quot;quantity&quot;: 2}&#10;    ]'::JSONB,&#10;    349.00&#10;);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/005_create_tables.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/005_create_tables.sql" />
              <option name="originalContent" value="-- Create tables table for tracking restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);&#10;" />
              <option name="updatedContent" value="-- Create tables table for tracking restaurant tables&#10;CREATE TABLE IF NOT EXISTS tables (&#10;    id SERIAL PRIMARY KEY,&#10;    table_number INT UNIQUE NOT NULL,&#10;    is_occupied BOOLEAN DEFAULT FALSE,&#10;    is_served BOOLEAN DEFAULT FALSE,&#10;    booking_start_time TIMESTAMP,&#10;    booking_end_time TIMESTAMP&#10;);&#10;&#10;-- Create order_tables table for linking orders to tables&#10;CREATE TABLE IF NOT EXISTS order_tables (&#10;    id SERIAL PRIMARY KEY,&#10;    order_id BIGINT NOT NULL REFERENCES orders(id),&#10;    table_id INT NOT NULL REFERENCES tables(id),&#10;    created_at TIMESTAMP DEFAULT NOW()&#10;);&#10;&#10;-- Add index for faster lookups&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_order_id ON order_tables(order_id);&#10;CREATE INDEX IF NOT EXISTS idx_order_tables_table_id ON order_tables(table_id);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/init-db.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/init-db.sh" />
              <option name="originalContent" value="#!/bin/bash&#10;set -e&#10;&#10;# Create database and users before migrations run&#10;psql -v ON_ERROR_STOP=1 --username &quot;$POSTGRES_USER&quot; --dbname &quot;$POSTGRES_DB&quot; &lt;&lt;-EOSQL&#10;    CREATE DATABASE restaurant_management;&#10;    CREATE USER restaurant_user WITH PASSWORD 'restaurant_password';&#10;    GRANT ALL PRIVILEGES ON DATABASE restaurant_management TO restaurant_user;&#10;EOSQL&#10;psql -v ON_ERROR_STOP=1 --username &quot;$POSTGRES_USER&quot; --dbname &quot;$POSTGRES_DB&quot; &lt;&lt;-EOSQL&#10;# Apply schema migrations to the restaurant_management database&#10;echo &quot;Running initial schema migrations...&quot;&#10;for f in /docker-entrypoint-initdb.d/*.sql; do&#10;  if [ -f &quot;\$f&quot; ]; then&#10;    echo &quot;Applying migration: \$f&quot;&#10;    psql -v ON_ERROR_STOP=1 --username &quot;$POSTGRES_USER&quot; --dbname restaurant_management -f &quot;\$f&quot;&#10;echo &quot;Running initial schema migrations...&quot;&#10;for f in /docker-entrypoint-initdb.d/*.sql; do&#10;  if [ -f &quot;\$f&quot; ]; then&#10;    echo &quot;Applying migration: \$f&quot;&#10;    psql -v ON_ERROR_STOP=1 --username &quot;$POSTGRES_USER&quot; --dbname restaurant_management -f &quot;\$f&quot;&#10;  fi&#10;done&#10;&#10;echo &quot;Database initialization completed successfully&quot;&#10;" />
              <option name="updatedContent" value="#!/bin/bash&#10;set -e&#10;&#10;echo &quot;Running database initialization script...&quot;&#10;&#10;# Apply all SQL migrations&#10;for file in /docker-entrypoint-initdb.d/*.sql; do&#10;  if [ -f &quot;$file&quot; ]; then&#10;    echo &quot;Applying migration: $file&quot;&#10;    psql -v ON_ERROR_STOP=1 --username &quot;$POSTGRES_USER&quot; --dbname &quot;$POSTGRES_DB&quot; -f &quot;$file&quot;&#10;    echo &quot;Migration $file applied successfully&quot;&#10;  fi&#10;done&#10;&#10;echo &quot;Database initialization completed successfully&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;zeta.foods&lt;/groupId&gt;&#10;    &lt;artifactId&gt;restaurant-management-system&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;Restaurant Management System&lt;/name&gt;&#10;    &lt;description&gt;A Java-based Restaurant Management System with Firebase integration&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Firebase Admin SDK --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.google.firebase&lt;/groupId&gt;&#10;            &lt;artifactId&gt;firebase-admin&lt;/artifactId&gt;&#10;            &lt;version&gt;9.2.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Firebase Admin SDK --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.google.firebase&lt;/groupId&gt;&#10;            &lt;artifactId&gt;firebase-admin&lt;/artifactId&gt;&#10;            &lt;version&gt;9.2.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.json&lt;/groupId&gt;&#10;            &lt;artifactId&gt;json&lt;/artifactId&gt;&#10;            &lt;version&gt;20230618&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;2.0.7&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;1.4.8&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Test dependencies --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.9.3&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.4.1&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.1.2&lt;/version&gt;&#10;            &lt;/plugin&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;zeta.foods&lt;/groupId&gt;&#10;    &lt;artifactId&gt;restaurant-management-system&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;packaging&gt;jar&lt;/packaging&gt;&#10;&#10;    &lt;name&gt;Restaurant Management System&lt;/name&gt;&#10;    &lt;description&gt;A Java-based Restaurant Management System with PostgreSQL integration&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- PostgreSQL JDBC Driver --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;&#10;            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&#10;            &lt;version&gt;42.6.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- BCrypt for password hashing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.mindrot&lt;/groupId&gt;&#10;            &lt;artifactId&gt;jbcrypt&lt;/artifactId&gt;&#10;            &lt;version&gt;0.4&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- JSON Processing --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.json&lt;/groupId&gt;&#10;            &lt;artifactId&gt;json&lt;/artifactId&gt;&#10;            &lt;version&gt;20230618&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Logging --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;&#10;            &lt;version&gt;2.0.7&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;&#10;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&#10;            &lt;version&gt;1.4.8&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Test dependencies --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;&#10;            &lt;version&gt;5.9.3&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.4.1&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;filters&gt;&#10;                                &lt;filter&gt;&#10;                                    &lt;artifact&gt;*:*&lt;/artifact&gt;&#10;                                    &lt;excludes&gt;&#10;                                        &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;&#10;                                        &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;&#10;                                        &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;&#10;                                        &lt;exclude&gt;META-INF/MANIFEST.MF&lt;/exclude&gt;&#10;                                    &lt;/excludes&gt;&#10;                                &lt;/filter&gt;&#10;                            &lt;/filters&gt;&#10;                            &lt;transformers&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&#10;                                    &lt;mainClass&gt;zeta.foods.Main&lt;/mainClass&gt;&#10;                                &lt;/transformer&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;&#10;                            &lt;/transformers&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.1.2&lt;/version&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/Main.java" />
              <option name="originalContent" value="package zeta.foods;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.AdminService;&#10;import zeta.foods.service.AuthService;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.service.impl.AdminServiceImpl;&#10;import zeta.foods.service.impl.CustomerServiceImpl;&#10;import zeta.foods.service.impl.PostgresAuthServiceImpl;&#10;import zeta.foods.simulation.AuthSimulation;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.Map;&#10;import java.util.Scanner;&#10;import java.util.TreeMap;&#10;&#10;public class Main {&#10;    private static final Logger logger = LoggerFactory.getLogger(Main.class);&#10;    private static AuthService authService;&#10;    private static CustomerService customerService;&#10;    private static AdminService adminService;&#10;&#10;    public static void main(String[] args) {&#10;        logger.info(&quot;Starting Restaurant Management System...&quot;);&#10;&#10;        try {&#10;            // Print database connection info&#10;            String dbHost = System.getenv().getOrDefault(&quot;DB_HOST&quot;, &quot;localhost&quot;);&#10;            String dbPort = System.getenv().getOrDefault(&quot;DB_PORT&quot;, &quot;5432&quot;);&#10;            String dbName = System.getenv().getOrDefault(&quot;DB_NAME&quot;, &quot;restaurant_management&quot;);&#10;&#10;            logger.info(&quot;Database Configuration:&quot;);&#10;            logger.info(&quot;  Host: {}&quot;, dbHost);&#10;            logger.info(&quot;  Port: {}&quot;, dbPort);&#10;            logger.info(&quot;  Database: {}&quot;, dbName);&#10;&#10;            // Check for simulation mode from command line or environment&#10;            boolean simulationMode = Boolean.parseBoolean(System.getenv().getOrDefault(&quot;SIMULATION_MODE&quot;, &quot;false&quot;));&#10;            if (args.length &gt; 0 &amp;&amp; &quot;simulate&quot;.equalsIgnoreCase(args[0])) {&#10;                simulationMode = true;&#10;            }&#10;&#10;            // Test database connection&#10;            DatabaseUtil.getConnection();&#10;            logger.info(&quot;Database connection successful&quot;);&#10;&#10;            // Initialize services&#10;            authService = new PostgresAuthServiceImpl();&#10;            customerService = new CustomerServiceImpl();&#10;            adminService = new AdminServiceImpl();&#10;            logger.info(&quot;Services initialized&quot;);&#10;&#10;            logger.info(&quot;Restaurant Management System is running successfully!&quot;);&#10;            logger.info(&quot;Application is ready to serve requests on port 8080&quot;);&#10;&#10;            // Run simulation or interactive mode&#10;            if (simulationMode) {&#10;                runSimulation();&#10;            } else {&#10;                startLoginProcess();&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to start Restaurant Management System&quot;, e);&#10;            System.exit(1);&#10;        }&#10;    }&#10;&#10;    private static void runSimulation() {&#10;        logger.info(&quot;=== Starting Authentication Simulation Mode ===&quot;);&#10;        AuthSimulation simulation = new AuthSimulation(authService);&#10;        simulation.runLoginSimulation();&#10;&#10;        // Close database connection when finished&#10;        DatabaseUtil.closeConnection();&#10;        logger.info(&quot;Simulation completed. Exiting application.&quot;);&#10;    }&#10;&#10;    private static void startLoginProcess() {&#10;        logger.info(&quot;=== Restaurant Management System Login ===&quot;);&#10;        logger.info(&quot;Type 'exit' to quit the application&quot;);&#10;&#10;        try {&#10;            // Use the enhanced console login method which is more reliable in Docker&#10;            PostgresAuthServiceImpl authServiceImpl = (PostgresAuthServiceImpl) authService;&#10;            User user = authServiceImpl.consoleLogin();&#10;&#10;            if (user == null) {&#10;                // Check if simulation was requested through the console login&#10;                if (&quot;simulate&quot;.equalsIgnoreCase(System.getenv().getOrDefault(&quot;LAST_COMMAND&quot;, &quot;&quot;))) {&#10;                    runSimulation();&#10;                }&#10;            }&#10;&#10;            // Keep application running until user selects exit&#10;            Scanner scanner = new Scanner(System.in);&#10;            boolean running = user != null;&#10;&#10;            while (running) {&#10;                String input = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(input) || &quot;exit&quot;.equalsIgnoreCase(input)) {&#10;                    logger.info(&quot;Logging out and exiting application&quot;);&#10;                    running = false;&#10;                } else {&#10;                    // Handle menu selection based on user role&#10;                    logger.info(&quot;Selected option: {}&quot;, input);&#10;&#10;                    if (user.getRole().equalsIgnoreCase(&quot;customer&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                customerService.displayRestaurantMenu(scanner);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                processOrderPlacement(user, scanner);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                viewOrderStatus(user, scanner);&#10;                                break;&#10;                            case &quot;4&quot;:&#10;//                                CustomerService.bookTable(user, scanner);&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else if (user.getRole().equalsIgnoreCase(&quot;admin&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                System.out.println(&quot;Manage Users - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                System.out.println(&quot;View System Reports - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                fetchCurrentInventory();&#10;                                break;&#10;                            case &quot;4&quot;:&#10;                                restoreCurrentInventory();&#10;                                break;&#10;                            case &quot;5&quot;:&#10;                                System.out.println(&quot;Manage Menu Items - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else {&#10;                        System.out.println(&quot;Processing your request...&quot;);&#10;                        System.out.println(&quot;Feature will be implemented in future updates.&quot;);&#10;                    }&#10;&#10;                    System.out.print(&quot;Enter another option (0 to exit): &quot;);&#10;                }&#10;            }&#10;&#10;            scanner.close();&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during login process: {}&quot;, e.getMessage(), e);&#10;        } finally {&#10;            // Close database connection when app exits&#10;            DatabaseUtil.closeConnection();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Process order placement for a customer&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void processOrderPlacement(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== Place New Order ===&quot;);&#10;&#10;        // Create a new order for the customer&#10;        Order order = customerService.placeOrder(user);&#10;        System.out.println(&quot;Order created! Order ID: &quot; + order.getOrderId());&#10;&#10;        boolean addingItems = true;&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;&#10;        while (addingItems) {&#10;            // Display menu categories&#10;            System.out.println(&quot;\nMenu Categories:&quot;);&#10;            TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;            String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;            for (int i = 0; i &lt; categories.length; i++) {&#10;                System.out.printf(&quot;%d. %s\n&quot;, i + 1, categories[i]);&#10;            }&#10;&#10;            System.out.print(&quot;\nSelect category (0 to finish order): &quot;);&#10;            String categoryInput = scanner.nextLine().trim();&#10;&#10;            if (&quot;0&quot;.equals(categoryInput)) {&#10;                addingItems = false;&#10;                continue;&#10;            }&#10;&#10;            try {&#10;                int categoryIndex = Integer.parseInt(categoryInput) - 1;&#10;                if (categoryIndex &lt; 0 || categoryIndex &gt;= categories.length) {&#10;                    System.out.println(&quot;Invalid category selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedCategory = categories[categoryIndex];&#10;                Map&lt;String, String&gt; items = menu.getCategoryItems(selectedCategory);&#10;&#10;                // Display items in the selected category&#10;                System.out.println(&quot;\n--- &quot; + selectedCategory + &quot; ---&quot;);&#10;                String[] itemNames = items.keySet().toArray(new String[0]);&#10;                for (int i = 0; i &lt; itemNames.length; i++) {&#10;                    System.out.printf(&quot;%d. %s - %s\n&quot;, i + 1, itemNames[i], items.get(itemNames[i]));&#10;                }&#10;&#10;                System.out.print(&quot;\nSelect item (0 to go back): &quot;);&#10;                String itemInput = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(itemInput)) {&#10;                    continue;&#10;                }&#10;&#10;                int itemIndex = Integer.parseInt(itemInput) - 1;&#10;                if (itemIndex &lt; 0 || itemIndex &gt;= itemNames.length) {&#10;                    System.out.println(&quot;Invalid item selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedItem = itemNames[itemIndex];&#10;&#10;                System.out.print(&quot;Enter quantity: &quot;);&#10;                int quantity = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (quantity &lt;= 0) {&#10;                    System.out.println(&quot;Quantity must be greater than zero.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Add item to order&#10;                boolean success = customerServiceImpl.addItemToOrder(order.getOrderId(), selectedCategory, selectedItem, quantity);&#10;                if (success) {&#10;                    System.out.println(quantity + &quot; x &quot; + selectedItem + &quot; added to your order.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Failed to add item to order.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Check if order has items&#10;        if (order.getItems().isEmpty()) {&#10;            System.out.println(&quot;Order cancelled - no items added.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Generate and display bill&#10;        System.out.println(&quot;\nGenerating your bill...&quot;);&#10;        String bill = customerServiceImpl.generateBill(order.getOrderId());&#10;        System.out.println(bill);&#10;&#10;        System.out.println(&quot;Thank you for your order!&quot;);&#10;    }&#10;&#10;&#10;    /**&#10;     * View the status of previous orders&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void viewOrderStatus(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== View Order Status ===&quot;);&#10;&#10;        // Retrieve and display user's order history&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;        customerServiceImpl.viewOrderStatus(user);&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Fetch and display the current inventory&#10;     */&#10;    private static void fetchCurrentInventory() {&#10;        logger.info(&quot;Fetching current inventory data&quot;);&#10;        System.out.println(&quot;\n=== Current Inventory ===&quot;);&#10;&#10;        String inventoryData = adminService.fetchCurrentInventory();&#10;        System.out.println(inventoryData);&#10;&#10;        System.out.println(&quot;Current inventory data has been displayed.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Restore the current inventory from the main inventory&#10;     */&#10;    private static void restoreCurrentInventory() {&#10;        logger.info(&quot;Restoring current inventory from main inventory&quot;);&#10;        System.out.println(&quot;\n=== Restoring Inventory ===&quot;);&#10;&#10;        boolean success = adminService.restoreCurrentInventory();&#10;&#10;        if (success) {&#10;            System.out.println(&quot;Inventory has been successfully restored from the main inventory.&quot;);&#10;        } else {&#10;            System.out.println(&quot;Failed to restore inventory. Please check the logs for details.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.AdminService;&#10;import zeta.foods.service.AuthService;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.service.WaiterService;&#10;import zeta.foods.service.impl.AdminServiceImpl;&#10;import zeta.foods.service.impl.CustomerServiceImpl;&#10;import zeta.foods.service.impl.PostgresAuthServiceImpl;&#10;import zeta.foods.service.impl.WaiterServiceImpl;&#10;import zeta.foods.simulation.AuthSimulation;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.Map;&#10;import java.util.Scanner;&#10;import java.util.TreeMap;&#10;&#10;public class Main {&#10;    private static final Logger logger = LoggerFactory.getLogger(Main.class);&#10;    private static AuthService authService;&#10;    private static CustomerService customerService;&#10;    private static AdminService adminService;&#10;    private static WaiterService waiterService;&#10;&#10;    public static void main(String[] args) {&#10;        logger.info(&quot;Starting Restaurant Management System...&quot;);&#10;&#10;        try {&#10;            // Print database connection info&#10;            String dbHost = System.getenv().getOrDefault(&quot;DB_HOST&quot;, &quot;localhost&quot;);&#10;            String dbPort = System.getenv().getOrDefault(&quot;DB_PORT&quot;, &quot;5432&quot;);&#10;            String dbName = System.getenv().getOrDefault(&quot;DB_NAME&quot;, &quot;restaurant_management&quot;);&#10;&#10;            logger.info(&quot;Database Configuration:&quot;);&#10;            logger.info(&quot;  Host: {}&quot;, dbHost);&#10;            logger.info(&quot;  Port: {}&quot;, dbPort);&#10;            logger.info(&quot;  Database: {}&quot;, dbName);&#10;&#10;            // Check for simulation mode from command line or environment&#10;            boolean simulationMode = Boolean.parseBoolean(System.getenv().getOrDefault(&quot;SIMULATION_MODE&quot;, &quot;false&quot;));&#10;            if (args.length &gt; 0 &amp;&amp; &quot;simulate&quot;.equalsIgnoreCase(args[0])) {&#10;                simulationMode = true;&#10;            }&#10;&#10;            // Test database connection&#10;            DatabaseUtil.getConnection();&#10;            logger.info(&quot;Database connection successful&quot;);&#10;&#10;            // Initialize services&#10;            authService = new PostgresAuthServiceImpl();&#10;            customerService = new CustomerServiceImpl();&#10;            adminService = new AdminServiceImpl();&#10;            waiterService = new WaiterServiceImpl();&#10;            logger.info(&quot;Services initialized&quot;);&#10;&#10;            logger.info(&quot;Restaurant Management System is running successfully!&quot;);&#10;            logger.info(&quot;Application is ready to serve requests on port 8080&quot;);&#10;&#10;            // Run simulation or interactive mode&#10;            if (simulationMode) {&#10;                runSimulation();&#10;            } else {&#10;                startLoginProcess();&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Failed to start Restaurant Management System&quot;, e);&#10;            System.exit(1);&#10;        }&#10;    }&#10;&#10;    private static void runSimulation() {&#10;        logger.info(&quot;=== Starting Authentication Simulation Mode ===&quot;);&#10;        AuthSimulation simulation = new AuthSimulation(authService);&#10;        simulation.runLoginSimulation();&#10;&#10;        // Close database connection when finished&#10;        DatabaseUtil.closeConnection();&#10;        logger.info(&quot;Simulation completed. Exiting application.&quot;);&#10;    }&#10;&#10;    private static void startLoginProcess() {&#10;        logger.info(&quot;=== Restaurant Management System Login ===&quot;);&#10;        logger.info(&quot;Type 'exit' to quit the application&quot;);&#10;&#10;        try {&#10;            // Use the enhanced console login method which is more reliable in Docker&#10;            PostgresAuthServiceImpl authServiceImpl = (PostgresAuthServiceImpl) authService;&#10;            User user = authServiceImpl.consoleLogin();&#10;&#10;            if (user == null) {&#10;                // Check if simulation was requested through the console login&#10;                if (&quot;simulate&quot;.equalsIgnoreCase(System.getenv().getOrDefault(&quot;LAST_COMMAND&quot;, &quot;&quot;))) {&#10;                    runSimulation();&#10;                }&#10;            }&#10;&#10;            // Keep application running until user selects exit&#10;            Scanner scanner = new Scanner(System.in);&#10;            boolean running = user != null;&#10;&#10;            while (running) {&#10;                String input = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(input) || &quot;exit&quot;.equalsIgnoreCase(input)) {&#10;                    logger.info(&quot;Logging out and exiting application&quot;);&#10;                    running = false;&#10;                } else {&#10;                    // Handle menu selection based on user role&#10;                    logger.info(&quot;Selected option: {}&quot;, input);&#10;&#10;                    if (user.getRole().equalsIgnoreCase(&quot;customer&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                customerService.displayRestaurantMenu(scanner);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                processOrderPlacement(user, scanner);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                viewOrderStatus(user, scanner);&#10;                                break;&#10;                            case &quot;4&quot;:&#10;//                                CustomerService.bookTable(user, scanner);&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else if (user.getRole().equalsIgnoreCase(&quot;waiter&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                takeNewOrderAsWaiter(scanner);&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else if (user.getRole().equalsIgnoreCase(&quot;admin&quot;)) {&#10;                        switch (input) {&#10;                            case &quot;1&quot;:&#10;                                System.out.println(&quot;Manage Users - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;2&quot;:&#10;                                System.out.println(&quot;View System Reports - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            case &quot;3&quot;:&#10;                                fetchCurrentInventory();&#10;                                break;&#10;                            case &quot;4&quot;:&#10;                                restoreCurrentInventory();&#10;                                break;&#10;                            case &quot;5&quot;:&#10;                                System.out.println(&quot;Manage Menu Items - Feature will be implemented in future updates.&quot;);&#10;                                break;&#10;                            default:&#10;                                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;                                break;&#10;                        }&#10;                    } else {&#10;                        System.out.println(&quot;Processing your request...&quot;);&#10;                        System.out.println(&quot;Feature will be implemented in future updates.&quot;);&#10;                    }&#10;&#10;                    System.out.print(&quot;Enter another option (0 to exit): &quot;);&#10;                }&#10;            }&#10;&#10;            scanner.close();&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during login process: {}&quot;, e.getMessage(), e);&#10;        } finally {&#10;            // Close database connection when app exits&#10;            DatabaseUtil.closeConnection();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Process order placement for a customer&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void processOrderPlacement(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== Place New Order ===&quot;);&#10;&#10;        // Create a new order for the customer&#10;        Order order = customerService.placeOrder(user);&#10;        System.out.println(&quot;Order created! Order ID: &quot; + order.getOrderId());&#10;&#10;        boolean addingItems = true;&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;&#10;        while (addingItems) {&#10;            // Display menu categories&#10;            System.out.println(&quot;\nMenu Categories:&quot;);&#10;            TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;            String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;            for (int i = 0; i &lt; categories.length; i++) {&#10;                System.out.printf(&quot;%d. %s\n&quot;, i + 1, categories[i]);&#10;            }&#10;&#10;            System.out.print(&quot;\nSelect category (0 to finish order): &quot;);&#10;            String categoryInput = scanner.nextLine().trim();&#10;&#10;            if (&quot;0&quot;.equals(categoryInput)) {&#10;                addingItems = false;&#10;                continue;&#10;            }&#10;&#10;            try {&#10;                int categoryIndex = Integer.parseInt(categoryInput) - 1;&#10;                if (categoryIndex &lt; 0 || categoryIndex &gt;= categories.length) {&#10;                    System.out.println(&quot;Invalid category selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedCategory = categories[categoryIndex];&#10;                Map&lt;String, String&gt; items = menu.getCategoryItems(selectedCategory);&#10;&#10;                // Display items in the selected category&#10;                System.out.println(&quot;\n--- &quot; + selectedCategory + &quot; ---&quot;);&#10;                String[] itemNames = items.keySet().toArray(new String[0]);&#10;                for (int i = 0; i &lt; itemNames.length; i++) {&#10;                    System.out.printf(&quot;%d. %s - %s\n&quot;, i + 1, itemNames[i], items.get(itemNames[i]));&#10;                }&#10;&#10;                System.out.print(&quot;\nSelect item (0 to go back): &quot;);&#10;                String itemInput = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(itemInput)) {&#10;                    continue;&#10;                }&#10;&#10;                int itemIndex = Integer.parseInt(itemInput) - 1;&#10;                if (itemIndex &lt; 0 || itemIndex &gt;= itemNames.length) {&#10;                    System.out.println(&quot;Invalid item selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedItem = itemNames[itemIndex];&#10;&#10;                System.out.print(&quot;Enter quantity: &quot;);&#10;                int quantity = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (quantity &lt;= 0) {&#10;                    System.out.println(&quot;Quantity must be greater than zero.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Add item to order&#10;                boolean success = customerServiceImpl.addItemToOrder(order.getOrderId(), selectedCategory, selectedItem, quantity);&#10;                if (success) {&#10;                    System.out.println(quantity + &quot; x &quot; + selectedItem + &quot; added to your order.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Failed to add item to order.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Check if order has items&#10;        if (order.getItems().isEmpty()) {&#10;            System.out.println(&quot;Order cancelled - no items added.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Generate and display bill&#10;        System.out.println(&quot;\nGenerating your bill...&quot;);&#10;        String bill = customerServiceImpl.generateBill(order.getOrderId());&#10;        System.out.println(bill);&#10;&#10;        System.out.println(&quot;Thank you for your order!&quot;);&#10;    }&#10;&#10;&#10;    /**&#10;     * View the status of previous orders&#10;     * @param user The current logged-in user&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void viewOrderStatus(User user, Scanner scanner) {&#10;        System.out.println(&quot;\n=== View Order Status ===&quot;);&#10;&#10;        // Retrieve and display user's order history&#10;        CustomerServiceImpl customerServiceImpl = (CustomerServiceImpl) customerService;&#10;        customerServiceImpl.viewOrderStatus(user);&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Fetch and display the current inventory&#10;     */&#10;    private static void fetchCurrentInventory() {&#10;        logger.info(&quot;Fetching current inventory data&quot;);&#10;        System.out.println(&quot;\n=== Current Inventory ===&quot;);&#10;&#10;        String inventoryData = adminService.fetchCurrentInventory();&#10;        System.out.println(inventoryData);&#10;&#10;        System.out.println(&quot;Current inventory data has been displayed.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Restore the current inventory from the main inventory&#10;     */&#10;    private static void restoreCurrentInventory() {&#10;        logger.info(&quot;Restoring current inventory from main inventory&quot;);&#10;        System.out.println(&quot;\n=== Restoring Inventory ===&quot;);&#10;&#10;        boolean success = adminService.restoreCurrentInventory();&#10;&#10;        if (success) {&#10;            System.out.println(&quot;Inventory has been successfully restored from the main inventory.&quot;);&#10;        } else {&#10;            System.out.println(&quot;Failed to restore inventory. Please check the logs for details.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Take a new order as a waiter&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private static void takeNewOrderAsWaiter(Scanner scanner) {&#10;        logger.info(&quot;Taking new order as waiter&quot;);&#10;        &#10;        // Use the WaiterService to handle the order taking process&#10;        Order order = waiterService.takeNewOrder(scanner);&#10;        &#10;        if (order != null) {&#10;            logger.info(&quot;Order #{} successfully created by waiter&quot;, order.getOrderId());&#10;            System.out.println(&quot;\nOrder #&quot; + order.getOrderId() + &quot; has been successfully created.&quot;);&#10;        } else {&#10;            logger.info(&quot;Order creation cancelled or failed&quot;);&#10;            System.out.println(&quot;\nOrder creation was cancelled or failed.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/config/FirebaseConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/config/FirebaseConfig.java" />
              <option name="originalContent" value="package zeta.foods.config;&#10;&#10;import com.google.auth.oauth2.GoogleCredentials;&#10;import com.google.firebase.FirebaseApp;&#10;import com.google.firebase.FirebaseOptions;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;public class FirebaseConfig {&#10;    private static final Logger logger = LoggerFactory.getLogger(FirebaseConfig.class);&#10;&#10;    public static void initializeFirebase() {&#10;        try {&#10;            if (FirebaseApp.getApps().isEmpty()) {&#10;                logger.info(&quot;Initializing Firebase in test mode...&quot;);&#10;&#10;                // For development/testing purposes, we'll initialize Firebase with empty credentials&#10;                FirebaseOptions options = FirebaseOptions.builder()&#10;                        .setCredentials(GoogleCredentials.fromAccessToken(&quot;test-token&quot;)) // Use dummy token for test mode&#10;                        .setProjectId(&quot;login-4e5bf&quot;)&#10;                        .setDatabaseUrl(&quot;https://login-4e5bf-default-rtdb.firebaseio.com&quot;)&#10;                        .build();&#10;&#10;                FirebaseApp.initializeApp(options);&#10;                logger.info(&quot;Firebase initialized successfully in test mode&quot;);&#10;            } else {&#10;                logger.info(&quot;Firebase app already initialized&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error initializing Firebase: {}&quot;, e.getMessage(), e);&#10;            throw new RuntimeException(&quot;Failed to initialize Firebase&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.config;&#10;&#10;import com.google.auth.oauth2.GoogleCredentials;&#10;import com.google.firebase.FirebaseApp;&#10;import com.google.firebase.FirebaseOptions;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;public class FirebaseConfig {&#10;    private static final Logger logger = LoggerFactory.getLogger(FirebaseConfig.class);&#10;&#10;    public static void initializeFirebase() {&#10;        try {&#10;            if (FirebaseApp.getApps().isEmpty()) {&#10;                logger.info(&quot;Initializing Firebase...&quot;);&#10;&#10;                // Using the Firebase credentials provided&#10;                FirebaseOptions options = FirebaseOptions.builder()&#10;                        .setApiKey(&quot;AIzaSyBc_5c_kifHsQpJl43kgMlTLciTTkCEJ9w&quot;)&#10;                        .setProjectId(&quot;login-4e5bf&quot;)&#10;                        .setDatabaseUrl(&quot;https://login-4e5bf-default-rtdb.firebaseio.com&quot;)&#10;                        .setStorageBucket(&quot;login-4e5bf.firebasestorage.app&quot;)&#10;                        .setApplicationId(&quot;1:492624027559:web:55d0e912122375822aa082&quot;)&#10;                        // Create empty credentials for testing environment&#10;                        .setCredentials(GoogleCredentials.create(null))&#10;                        .build();&#10;&#10;                FirebaseApp.initializeApp(options);&#10;                logger.info(&quot;Firebase initialized successfully&quot;);&#10;            } else {&#10;                logger.info(&quot;Firebase app already initialized&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error initializing Firebase: {}&quot;, e.getMessage(), e);&#10;            logger.info(&quot;Continuing without Firebase initialization&quot;);&#10;            // Don't throw exception - allow the application to continue without Firebase&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/Order.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/Order.java" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;public class Order {&#10;    private String orderId;&#10;    private Long customerId;&#10;    private String customerName;&#10;    private List&lt;OrderItem&gt; items;&#10;    private OrderStatus status;&#10;    private LocalDateTime orderTime;&#10;    private LocalDateTime deliveryTime;&#10;    private double totalAmount;&#10;    private String specialInstructions;&#10;    private int tableNumber;&#10;&#10;    public Order() {&#10;        this.orderId = UUID.randomUUID().toString().substring(0, 8);&#10;        this.items = new ArrayList&lt;&gt;();&#10;        this.status = OrderStatus.PENDING;&#10;        this.orderTime = LocalDateTime.now();&#10;    }&#10;&#10;    public String getOrderId() {&#10;        return orderId;&#10;    }&#10;&#10;    public void setOrderId(String orderId) {&#10;        this.orderId = orderId;&#10;    }&#10;&#10;    public Long getCustomerId() {&#10;        return customerId;&#10;    }&#10;&#10;    public void setCustomerId(Long customerId) {&#10;        this.customerId = customerId;&#10;    }&#10;&#10;    public String getCustomerName() {&#10;        return customerName;&#10;    }&#10;&#10;    public void setCustomerName(String customerName) {&#10;        this.customerName = customerName;&#10;    }&#10;&#10;    public List&lt;OrderItem&gt; getItems() {&#10;        return items;&#10;    }&#10;&#10;    public void setItems(List&lt;OrderItem&gt; items) {&#10;        this.items = items;&#10;    }&#10;&#10;    public void addItem(OrderItem item) {&#10;        this.items.add(item);&#10;        calculateTotal();&#10;    }&#10;&#10;    public OrderStatus getStatus() {&#10;        return status;&#10;    }&#10;&#10;    public void setStatus(OrderStatus status) {&#10;        this.status = status;&#10;    }&#10;&#10;    public LocalDateTime getOrderTime() {&#10;        return orderTime;&#10;    }&#10;&#10;    public void setOrderTime(LocalDateTime orderTime) {&#10;        this.orderTime = orderTime;&#10;    }&#10;&#10;    public LocalDateTime getDeliveryTime() {&#10;        return deliveryTime;&#10;    }&#10;&#10;    public void setDeliveryTime(LocalDateTime deliveryTime) {&#10;        this.deliveryTime = deliveryTime;&#10;    }&#10;&#10;    public double getTotalAmount() {&#10;        return totalAmount;&#10;    }&#10;&#10;    public void calculateTotal() {&#10;        this.totalAmount = items.stream()&#10;                .mapToDouble(item -&gt; item.getPrice() * item.getQuantity())&#10;                .sum();&#10;    }&#10;&#10;    public String getSpecialInstructions() {&#10;        return specialInstructions;&#10;    }&#10;&#10;    public void setSpecialInstructions(String specialInstructions) {&#10;        this.specialInstructions = specialInstructions;&#10;    }&#10;&#10;    public int getTableNumber() {&#10;        return tableNumber;&#10;    }&#10;&#10;    public void setTableNumber(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/OrderItem.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/OrderItem.java" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;public class OrderItem {&#10;    private String category;&#10;    private String itemName;&#10;    private int quantity;&#10;    private double price;&#10;&#10;    public OrderItem(String category, String itemName, int quantity, double price) {&#10;        this.category = category;&#10;        this.itemName = itemName;&#10;        this.quantity = quantity;&#10;        this.price = price;&#10;    }&#10;&#10;    public String getCategory() {&#10;        return category;&#10;    }&#10;&#10;    public void setCategory(String category) {&#10;        this.category = category;&#10;    }&#10;&#10;    public String getItemName() {&#10;        return itemName;&#10;    }&#10;&#10;    public void setItemName(String itemName) {&#10;        this.itemName = itemName;&#10;    }&#10;&#10;    public int getQuantity() {&#10;        return quantity;&#10;    }&#10;&#10;    public void setQuantity(int quantity) {&#10;        this.quantity = quantity;&#10;    }&#10;&#10;    public double getPrice() {&#10;        return price;&#10;    }&#10;&#10;    public void setPrice(double price) {&#10;        this.price = price;&#10;    }&#10;&#10;    public double getSubtotal() {&#10;        return price * quantity;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/Table.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/Table.java" />
              <option name="originalContent" value="package zeta.foods.model;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Represents a restaurant table&#10; */&#10;public class Table {&#10;    private int tableNumber;&#10;    private boolean isOccupied;&#10;    private LocalDateTime bookingStartTime;&#10;    private LocalDateTime bookingEndTime;&#10;&#10;    public Table() {&#10;    }&#10;&#10;    public Table(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = false;&#10;    }&#10;&#10;    public Table(int tableNumber, boolean isOccupied, LocalDateTime bookingStartTime, LocalDateTime bookingEndTime) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = isOccupied;&#10;        this.bookingStartTime = bookingStartTime;&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;&#10;    public int getTableNumber() {&#10;        return tableNumber;&#10;    }&#10;&#10;    public void setTableNumber(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;    }&#10;&#10;    public boolean isOccupied() {&#10;        return isOccupied;&#10;    }&#10;&#10;    public void setOccupied(boolean occupied) {&#10;        isOccupied = occupied;&#10;    }&#10;&#10;    public LocalDateTime getBookingStartTime() {&#10;        return bookingStartTime;&#10;    }&#10;&#10;    public void setBookingStartTime(LocalDateTime bookingStartTime) {&#10;        this.bookingStartTime = bookingStartTime;&#10;    }&#10;&#10;    public LocalDateTime getBookingEndTime() {&#10;        return bookingEndTime;&#10;    }&#10;&#10;    public void setBookingEndTime(LocalDateTime bookingEndTime) {&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Table #&quot; + tableNumber +&#10;               (isOccupied ? &quot; (Occupied since &quot; + bookingStartTime + &quot;)&quot; : &quot; (Available)&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * Represents a restaurant table&#10; */&#10;public class Table {&#10;    private int tableNumber;&#10;    private boolean isOccupied;&#10;    private boolean isServed;&#10;    private LocalDateTime bookingStartTime;&#10;    private LocalDateTime bookingEndTime;&#10;&#10;    public Table() {&#10;    }&#10;&#10;    public Table(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = false;&#10;        this.isServed = false;&#10;    }&#10;&#10;    public Table(int tableNumber, boolean isOccupied, boolean isServed, LocalDateTime bookingStartTime, LocalDateTime bookingEndTime) {&#10;        this.tableNumber = tableNumber;&#10;        this.isOccupied = isOccupied;&#10;        this.isServed = isServed;&#10;        this.bookingStartTime = bookingStartTime;&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;&#10;    public int getTableNumber() {&#10;        return tableNumber;&#10;    }&#10;&#10;    public void setTableNumber(int tableNumber) {&#10;        this.tableNumber = tableNumber;&#10;    }&#10;&#10;    public boolean isOccupied() {&#10;        return isOccupied;&#10;    }&#10;&#10;    public void setOccupied(boolean occupied) {&#10;        isOccupied = occupied;&#10;    }&#10;    &#10;    public boolean isServed() {&#10;        return isServed;&#10;    }&#10;    &#10;    public void setServed(boolean served) {&#10;        isServed = served;&#10;    }&#10;&#10;    public LocalDateTime getBookingStartTime() {&#10;        return bookingStartTime;&#10;    }&#10;&#10;    public void setBookingStartTime(LocalDateTime bookingStartTime) {&#10;        this.bookingStartTime = bookingStartTime;&#10;    }&#10;&#10;    public LocalDateTime getBookingEndTime() {&#10;        return bookingEndTime;&#10;    }&#10;&#10;    public void setBookingEndTime(LocalDateTime bookingEndTime) {&#10;        this.bookingEndTime = bookingEndTime;&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        String status = isOccupied ? (isServed ? &quot; (Occupied, Served)&quot; : &quot; (Occupied, Not Served)&quot;) : &quot; (Available)&quot;;&#10;        return &quot;Table #&quot; + tableNumber + status;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/model/User.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/model/User.java" />
              <option name="updatedContent" value="package zeta.foods.model;&#10;&#10;import java.time.ZonedDateTime;&#10;&#10;public class User {&#10;    private Long id;&#10;    private String username;&#10;    private String email;&#10;    private String password; // Stored as hashed&#10;    private String role; // &quot;admin&quot;, &quot;waiter&quot;, or &quot;customer&quot;&#10;    private ZonedDateTime createdAt;&#10;    private ZonedDateTime lastLogin;&#10;&#10;    // Constructors&#10;    public User() {}&#10;    &#10;    public User(Long id, String username, String email, String password, String role) {&#10;        this.id = id;&#10;        this.username = username;&#10;        this.email = email;&#10;        this.password = password;&#10;        this.role = role;&#10;    }&#10;&#10;    // Getters and Setters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;&#10;    public void setId(Long id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public String getUsername() {&#10;        return username;&#10;    }&#10;&#10;    public void setUsername(String username) {&#10;        this.username = username;&#10;    }&#10;&#10;    public String getEmail() {&#10;        return email;&#10;    }&#10;&#10;    public void setEmail(String email) {&#10;        this.email = email;&#10;    }&#10;&#10;    public String getPassword() {&#10;        return password;&#10;    }&#10;&#10;    public void setPassword(String password) {&#10;        this.password = password;&#10;    }&#10;&#10;    public String getRole() {&#10;        return role;&#10;    }&#10;&#10;    public void setRole(String role) {&#10;        this.role = role;&#10;    }&#10;&#10;    public ZonedDateTime getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    public void setCreatedAt(ZonedDateTime createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    public ZonedDateTime getLastLogin() {&#10;        return lastLogin;&#10;    }&#10;&#10;    public void setLastLogin(ZonedDateTime lastLogin) {&#10;        this.lastLogin = lastLogin;&#10;    }&#10;    &#10;    public boolean isAdmin() {&#10;        return &quot;admin&quot;.equals(role);&#10;    }&#10;    &#10;    public boolean isWaiter() {&#10;        return &quot;waiter&quot;.equals(role);&#10;    }&#10;    &#10;    public boolean isCustomer() {&#10;        return &quot;customer&quot;.equals(role);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/AdminService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/AdminService.java" />
              <option name="updatedContent" value="package zeta.foods.service;&#10;&#10;/**&#10; * Service interface for administrative operations&#10; */&#10;public interface AdminService {&#10;    &#10;    /**&#10;     * Fetch the current inventory data&#10;     * @return A string representation of the current inventory&#10;     */&#10;    String fetchCurrentInventory();&#10;    &#10;    /**&#10;     * Restore the current inventory from backup or default values&#10;     * @return true if restoration was successful, false otherwise&#10;     */&#10;    boolean restoreCurrentInventory();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/AuthService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/AuthService.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package zeta.foods.service;&#10;&#10;import zeta.foods.model.User;&#10;&#10;public interface AuthService {&#10;    /**&#10;     * Authenticate a user with email and password&#10;     * @param email User's email&#10;     * @param password User's password&#10;     * @return User if authentication successful, null otherwise&#10;     */&#10;    User authenticateUser(String email, String password);&#10;&#10;    /**&#10;     * Check if a user is an admin&#10;     * @param email User's email&#10;     * @return true if admin, false otherwise&#10;     */&#10;    boolean isAdmin(String email);&#10;&#10;    /**&#10;     * Check if a user is a waiter&#10;     * @param email User's email&#10;     * @return true if waiter, false otherwise&#10;     */&#10;    boolean isWaiter(String email);&#10;&#10;    /**&#10;     * Create a new user account&#10;     * @param username Username&#10;     * @param email Email&#10;     * @param password Password (will be hashed)&#10;     * @param role Role (admin, waiter, customer)&#10;     * @return Created user or null if creation failed&#10;     */&#10;    User createUser(String username, String email, String password, String role);&#10;    &#10;    /**&#10;     * Register a new user account (primarily for customers)&#10;     * @param username Username&#10;     * @param email Email&#10;     * @param password Password&#10;     * @param role User role&#10;     * @return User if registration successful, null otherwise&#10;     */&#10;    User registerUser(String username, String email, String password, String role);&#10;&#10;    /**&#10;     * Updates the last login time for a user&#10;     * @param userId The user ID&#10;     * @return true if successful, false otherwise&#10;     */&#10;    boolean updateLastLogin(Long userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/FirebaseAuthService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/FirebaseAuthService.java" />
              <option name="originalContent" value="package zeta.foods.service;&#10;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;import java.util.concurrent.ExecutionException;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseAuthException;&#10;import com.google.firebase.auth.UserRecord;&#10;import com.google.firebase.auth.UserRecord.CreateRequest;&#10;&#10;public interface FirebaseAuthService {&#10;    /**&#10;     * Authenticate a user with email and password&#10;     * @param email User's email&#10;     * @param password User's password&#10;     * @return UserRecord if authentication successful, null otherwise&#10;     */&#10;    UserRecord authenticateUser(String email, String password);&#10;&#10;    /**&#10;     * Check if the user is an admin&#10;     * @param email User's email&#10;     * @return true if admin, false otherwise&#10;     */&#10;    boolean isAdmin(String email);&#10;&#10;    /**&#10;     * Check if the user is a waiter&#10;     * @param email User's email&#10;     * @return true if waiter, false otherwise&#10;     */&#10;    boolean isWaiter(String email);&#10;&#10;    /**&#10;     * Create a new user&#10;     * @param email User's email&#10;     * @param password User's password&#10;     * @param isAdmin Whether the user is an admin&#10;     * @return UserRecord of created user&#10;     */&#10;    UserRecord createUser(String email, String password, boolean isAdmin);&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service;&#10;&#10;import zeta.foods.model.User;&#10;&#10;public interface AuthService {&#10;    /**&#10;     * Authenticate a user with email and password&#10;     * @param email User's email&#10;     * @param password User's password&#10;     * @return User if authentication successful, null otherwise&#10;     */&#10;    User authenticateUser(String email, String password);&#10;    &#10;    /**&#10;     * Check if a user is an admin&#10;     * @param email User's email&#10;     * @return true if admin, false otherwise&#10;     */&#10;    boolean isAdmin(String email);&#10;    &#10;    /**&#10;     * Check if a user is a waiter&#10;     * @param email User's email&#10;     * @return true if waiter, false otherwise&#10;     */&#10;    boolean isWaiter(String email);&#10;    &#10;    /**&#10;     * Create a new user account&#10;     * @param username Username&#10;     * @param email Email&#10;     * @param password Password (will be hashed)&#10;     * @param role Role (admin, waiter, customer)&#10;     * @return Created user or null if creation failed&#10;     */&#10;    User createUser(String username, String email, String password, String role);&#10;    &#10;    /**&#10;     * Updates the last login time for a user&#10;     * @param userId The user ID&#10;     * @return true if successful, false otherwise&#10;     */&#10;    boolean updateLastLogin(Long userId);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/WaiterService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/WaiterService.java" />
              <option name="originalContent" value="package zeta.foods.service;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.Table;&#10;&#10;import java.util.List;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Service interface for waiter operations in the restaurant&#10; */&#10;public interface WaiterService {&#10;&#10;    /**&#10;     * Take a new order for a customer&#10;     * @param scanner Scanner for user input&#10;     * @return The newly created order&#10;     */&#10;    Order takeNewOrder(Scanner scanner);&#10;&#10;    /**&#10;     * Get all tables with their current status&#10;     * @return List of tables with occupation status&#10;     */&#10;    List&lt;Table&gt; getAllTables();&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service;&#10;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.Table;&#10;&#10;import java.util.List;&#10;import java.util.Scanner;&#10;&#10;/**&#10; * Service interface for waiter operations in the restaurant&#10; */&#10;public interface WaiterService {&#10;&#10;    /**&#10;     * Take a new order for a customer&#10;     * @param scanner Scanner for user input&#10;     * @return The newly created order&#10;     */&#10;    Order takeNewOrder(Scanner scanner);&#10;&#10;    /**&#10;     * Get all tables with their current status&#10;     * @return List of tables with occupation status&#10;     */&#10;    List&lt;Table&gt; getAllTables();&#10;&#10;    /**&#10;     * Get all tables that are occupied but not yet served&#10;     * @return List of unserved tables&#10;     */&#10;    List&lt;Table&gt; getUnservedTables();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/AdminServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/AdminServiceImpl.java" />
              <option name="updatedContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.service.AdminService;&#10;import zeta.foods.utils.CurrentInventory;&#10;&#10;import java.io.BufferedReader;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.util.Map;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Implementation of AdminService for restaurant management system&#10; */&#10;public class AdminServiceImpl implements AdminService {&#10;    &#10;    private static final Logger logger = LoggerFactory.getLogger(AdminServiceImpl.class);&#10;    private static final String CURRENT_INVENTORY_FILE_PATH = &quot;src/main/resources/CurrentInventory.txt&quot;;&#10;    &#10;    /**&#10;     * Fetch the current inventory data&#10;     * @return A string representation of the current inventory&#10;     */&#10;    @Override&#10;    public String fetchCurrentInventory() {&#10;        logger.info(&quot;Fetching current inventory data&quot;);&#10;        &#10;        try {&#10;            StringBuilder inventoryData = new StringBuilder();&#10;            &#10;            // Read the file contents&#10;            try (BufferedReader reader = new BufferedReader(new FileReader(CURRENT_INVENTORY_FILE_PATH))) {&#10;                String line;&#10;                while ((line = reader.readLine()) != null) {&#10;                    inventoryData.append(line).append(&quot;\n&quot;);&#10;                }&#10;            }&#10;            &#10;            return inventoryData.toString();&#10;            &#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error fetching current inventory: {}&quot;, e.getMessage(), e);&#10;            return &quot;Error fetching inventory data: &quot; + e.getMessage();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Restore the current inventory from backup or default values&#10;     * @return true if restoration was successful, false otherwise&#10;     */&#10;    @Override&#10;    public boolean restoreCurrentInventory() {&#10;        logger.info(&quot;Restoring current inventory from main inventory&quot;);&#10;        try {&#10;            // Call the private method in CurrentInventory to refresh from main inventory&#10;            CurrentInventory.initializeCurrentInventory();&#10;            return true;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error restoring current inventory: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/CustomerServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/CustomerServiceImpl.java" />
              <option name="originalContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.OrderStatus;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;&#10;import java.sql.*;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;import org.json.JSONArray;&#10;import org.json.JSONObject;&#10;&#10;/**&#10; * Implementation of CustomerService for handling customer orders&#10; */&#10;public class CustomerServiceImpl implements CustomerService {&#10;    private static final Logger logger = LoggerFactory.getLogger(CustomerServiceImpl.class);&#10;&#10;    private static final Map&lt;String, Order&gt; orders = new HashMap&lt;&gt;();&#10;    private static final Map&lt;Long, List&lt;Order&gt;&gt; customerOrders = new HashMap&lt;&gt;();&#10;&#10;    @Override&#10;    public Order placeOrder(User user) {&#10;        Order order = new Order();&#10;        order.setCustomerId(user.getId());&#10;        order.setCustomerName(user.getUsername());&#10;&#10;        // Store order in memory cache&#10;        if (!customerOrders.containsKey(user.getId())) {&#10;            customerOrders.put(user.getId(), new ArrayList&lt;&gt;());&#10;        }&#10;        customerOrders.get(user.getId()).add(order);&#10;        orders.put(order.getOrderId(), order);&#10;&#10;        // Save order to database (initially empty)&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;INSERT INTO orders (order_id, customer_id, items, bill_subtotal, order_status) VALUES (?, ?, ?::jsonb, ?, ?)&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, order.getOrderId());&#10;                stmt.setLong(2, user.getId());&#10;                stmt.setString(3, &quot;[]&quot;); // Empty JSON array for items initially&#10;                stmt.setDouble(4, 0.0); // Initial subtotal is 0&#10;                stmt.setString(5, order.getStatus().toString());&#10;&#10;                int rowsAffected = stmt.executeUpdate();&#10;                if (rowsAffected &gt; 0) {&#10;                    logger.info(&quot;Order {} saved to database&quot;, order.getOrderId());&#10;                } else {&#10;                    logger.error(&quot;Failed to save order {} to database&quot;, order.getOrderId());&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while saving order: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        logger.info(&quot;Created new order with ID: {} for customer: {}&quot;, order.getOrderId(), user.getUsername());&#10;        return order;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; getCustomerOrders(Long customerId) {&#10;        // Try to get orders from memory first&#10;        List&lt;Order&gt; cachedOrders = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no cached orders, try to load from database&#10;        if (cachedOrders.isEmpty()) {&#10;            return loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        return cachedOrders;&#10;    }&#10;&#10;    private List&lt;Order&gt; loadOrdersFromDatabase(Long customerId) {&#10;        List&lt;Order&gt; result = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;SELECT * FROM orders WHERE customer_id = ? ORDER BY order_timestamp DESC&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setLong(1, customerId);&#10;&#10;                try (ResultSet rs = stmt.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        Order order = new Order();&#10;                        String orderId = rs.getString(&quot;order_id&quot;);&#10;                        order.setOrderId(orderId);&#10;                        order.setCustomerId(customerId);&#10;                        order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                        order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                        // Parse items from JSON&#10;                        String itemsJson = rs.getString(&quot;items&quot;);&#10;                        parseOrderItems(order, itemsJson);&#10;&#10;                        result.add(order);&#10;&#10;                        // Add to cache&#10;                        orders.put(orderId, order);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Update the cache&#10;            if (!result.isEmpty()) {&#10;                customerOrders.put(customerId, result);&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while loading orders: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    private void parseOrderItems(Order order, String itemsJson) {&#10;        try {&#10;            JSONArray itemsArray = new JSONArray(itemsJson);&#10;            for (int i = 0; i &lt; itemsArray.length(); i++) {&#10;                JSONObject itemObj = itemsArray.getJSONObject(i);&#10;                String category = itemObj.getString(&quot;category&quot;);&#10;                String itemName = itemObj.getString(&quot;itemName&quot;);&#10;                double price = itemObj.getDouble(&quot;price&quot;);&#10;                int quantity = itemObj.getInt(&quot;quantity&quot;);&#10;&#10;                OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;                order.addItem(item);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing order items JSON: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Order getOrderStatus(String orderId) {&#10;        // Try to get from cache first&#10;        Order order = orders.get(orderId);&#10;&#10;        // If not in cache, try to load from database&#10;        if (order == null) {&#10;            try (Connection conn = DatabaseUtil.getConnection()) {&#10;                String sql = &quot;SELECT * FROM orders WHERE order_id = ?&quot;;&#10;&#10;                try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                    stmt.setString(1, orderId);&#10;&#10;                    try (ResultSet rs = stmt.executeQuery()) {&#10;                        if (rs.next()) {&#10;                            order = new Order();&#10;                            order.setOrderId(orderId);&#10;                            order.setCustomerId(rs.getLong(&quot;customer_id&quot;));&#10;                            order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                            order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                            // Parse items from JSON&#10;                            String itemsJson = rs.getString(&quot;items&quot;);&#10;                            parseOrderItems(order, itemsJson);&#10;&#10;                            // Add to cache&#10;                            orders.put(orderId, order);&#10;                        }&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Database error while getting order status: {}&quot;, e.getMessage(), e);&#10;            }&#10;        }&#10;&#10;        return order;&#10;    }&#10;&#10;    /**&#10;     * Add an item to an existing order&#10;     *&#10;     * @param orderId   The order ID&#10;     * @param category   Menu category&#10;     * @param itemName  Item name&#10;     * @param quantity  Quantity&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean addItemToOrder(String orderId, String category, String itemName, int quantity) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            logger.warn(&quot;Order not found: {}&quot;, orderId);&#10;            return false;&#10;        }&#10;&#10;        // Get price from menu&#10;        String priceStr = menu.getItemPrice(category, itemName);&#10;        if (priceStr == null) {&#10;            logger.warn(&quot;Item not found in menu: {} in category {}&quot;, itemName, category);&#10;            return false;&#10;        }&#10;&#10;        // Parse price (remove &quot;Rs.&quot; prefix)&#10;        double price = menu.getPriceValue(priceStr);&#10;&#10;        // Add item to order&#10;        OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;        order.addItem(item);&#10;&#10;        // Update the order in the database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First, get all existing items for this order&#10;            String itemsJson = createItemsJson(order);&#10;&#10;            String sql = &quot;UPDATE orders SET items = ?::jsonb, bill_subtotal = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, itemsJson);&#10;                stmt.setDouble(2, order.getTotalAmount());&#10;                stmt.setString(3, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update order {} in database&quot;, orderId);&#10;                    return false;&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;&#10;        logger.info(&quot;Added item to order {}: {} x{} ({})&quot;,&#10;                orderId, itemName, quantity, priceStr);&#10;        return true;&#10;    }&#10;&#10;    private String createItemsJson(Order order) {&#10;        JSONArray itemsArray = new JSONArray();&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            JSONObject itemObj = new JSONObject();&#10;            itemObj.put(&quot;category&quot;, item.getCategory());&#10;            itemObj.put(&quot;itemName&quot;, item.getItemName());&#10;            itemObj.put(&quot;price&quot;, item.getPrice());&#10;            itemObj.put(&quot;quantity&quot;, item.getQuantity());&#10;            itemsArray.put(itemObj);&#10;        }&#10;&#10;        return itemsArray.toString();&#10;    }&#10;&#10;    /**&#10;     * Update order status&#10;     *&#10;     * @param orderId Order ID&#10;     * @param status  New status&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean updateOrderStatus(String orderId, OrderStatus status) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return false;&#10;        }&#10;        order.setStatus(status);&#10;&#10;        // Update status in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET order_status = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, status.toString());&#10;                stmt.setString(2, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                return rowsUpdated &gt; 0;&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order status: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a specified number of previous orders for a customer, sorted by most recent first&#10;     *&#10;     * @param customerId The customer's ID&#10;     * @param limit      Maximum number of orders to retrieve (default is 1 for latest order)&#10;     * @return List of the customer's orders in descending date order&#10;     */&#10;    public List&lt;Order&gt; getPreviousOrders(Long customerId, int limit) {&#10;        // Check if we have any orders in memory first&#10;        List&lt;Order&gt; customerOrderList = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no orders in memory, try to load from database&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in memory for customer ID: {}, loading from database...&quot;, customerId);&#10;            customerOrderList = loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        // If still empty after trying to load from DB, return empty list&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in database for customer ID: {}&quot;, customerId);&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        // Sort orders by order time, most recent first&#10;        return customerOrderList.stream()&#10;                .sorted(Comparator.comparing(Order::getOrderTime).reversed())&#10;                .limit(limit &gt; 0 ? limit : 1) // Apply limit, with default of 1 if invalid limit&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Format a single order for display&#10;     *&#10;     * @param order The order to format&#10;     * @return Formatted order summary as string&#10;     */&#10;    public String formatOrderSummary(Order order) {&#10;        if (order == null) {&#10;            return &quot;No order information available.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);&#10;&#10;        StringBuilder summary = new StringBuilder();&#10;        summary.append(&quot;\n=================================\n&quot;);&#10;        summary.append(&quot;ORDER SUMMARY\n&quot;);&#10;        summary.append(&quot;=================================\n&quot;);&#10;        summary.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        summary.append(&quot;Date: &quot;).append(order.getOrderTime().format(dateFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Time: &quot;).append(order.getOrderTime().format(timeFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Status: &quot;).append(order.getStatus()).append(&quot;\n&quot;);&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;&#10;        // List items&#10;        summary.append(&quot;ITEMS ORDERED:\n&quot;);&#10;        for (OrderItem item : order.getItems()) {&#10;            summary.append(String.format(&quot; %d x %s (Rs.%.2f)\n&quot;,&#10;                    item.getQuantity(), item.getItemName(), item.getPrice()));&#10;        }&#10;&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;        summary.append(String.format(&quot;Subtotal: Rs.%.2f\n&quot;, order.getTotalAmount()));&#10;&#10;        // Calculate additional charges&#10;        double serviceCharge = order.getTotalAmount() * 0.02;&#10;        double taxCharge = order.getTotalAmount() &gt; 150 ? 25.0 : 0.0;&#10;        double grandTotal = order.getTotalAmount() + serviceCharge + taxCharge;&#10;&#10;        summary.append(String.format(&quot;Service Charge (2%%): Rs.%.2f\n&quot;, serviceCharge));&#10;        summary.append(String.format(&quot;CGST &amp; SGST: Rs.%.2f\n&quot;, taxCharge));&#10;        summary.append(String.format(&quot;Grand Total: Rs.%.2f\n&quot;, grandTotal));&#10;        summary.append(&quot;=================================\n&quot;);&#10;&#10;        return summary.toString();&#10;    }&#10;&#10;    /**&#10;     * Format multiple orders for display&#10;     *&#10;     * @param orders List of orders to format&#10;     * @return Formatted list of order summaries as string&#10;     */&#10;    public String formatOrdersList(List&lt;Order&gt; orders) {&#10;        if (orders == null || orders.isEmpty()) {&#10;            return &quot;No previous orders found.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;);&#10;&#10;        StringBuilder result = new StringBuilder();&#10;        result.append(&quot;\n=================================\n&quot;);&#10;        result.append(&quot;YOUR ORDER HISTORY\n&quot;);&#10;        result.append(&quot;=================================\n&quot;);&#10;&#10;        int count = 1;&#10;        for (Order order : orders) {&#10;            result.append(String.format(&quot;%d. Order #%s - %s\n&quot;,&#10;                    count++,&#10;                    order.getOrderId(),&#10;                    order.getOrderTime().format(formatter)));&#10;&#10;            result.append(String.format(&quot;   Status: %s, Total: Rs.%.2f\n&quot;,&#10;                    order.getStatus(),&#10;                    order.getTotalAmount()));&#10;&#10;            // Show item count&#10;            result.append(String.format(&quot;   Items: %d\n&quot;, order.getItems().size()));&#10;        }&#10;&#10;        result.append(&quot;=================================\n&quot;);&#10;        return result.toString();&#10;    }&#10;&#10;    /**&#10;     * View order status for a customer with option to specify number of orders to display&#10;     *&#10;     * @param user The user viewing their order history&#10;     */&#10;    public void viewOrderStatus(User user) {&#10;        Scanner scanner = new Scanner(System.in);&#10;        System.out.println(&quot;\n=== Your Order History ===&quot;);&#10;&#10;        // Ask user how many orders they want to view&#10;        System.out.print(&quot;How many recent orders would you like to view? (default: 1): &quot;);&#10;        String input = scanner.nextLine().trim();&#10;&#10;        // Parse input, default to 1 if empty or invalid&#10;        int limit = 1;&#10;        if (!input.isEmpty()) {&#10;            try {&#10;                limit = Integer.parseInt(input);&#10;                if (limit &lt;= 0) {&#10;                    limit = 1;&#10;                    System.out.println(&quot;Invalid number. Showing the most recent order.&quot;);&#10;                }&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Invalid input. Showing the most recent order.&quot;);&#10;            }&#10;        }&#10;&#10;        // Get previous orders for the customer&#10;        List&lt;Order&gt; previousOrders = getPreviousOrders(user.getId(), limit);&#10;&#10;        if (previousOrders.isEmpty()) {&#10;            System.out.println(&quot;You don't have any orders yet.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Display each order&#10;        System.out.printf(&quot;Showing your %d most recent order(s):\n\n&quot;, previousOrders.size());&#10;        for (int i = 0; i &lt; previousOrders.size(); i++) {&#10;            if (i &gt; 0) {&#10;                System.out.println(&quot;\n&quot; + &quot;-&quot;.repeat(40) + &quot;\n&quot;);&#10;            }&#10;            Order order = previousOrders.get(i);&#10;            String formattedOrder = formatOrderSummary(order);&#10;            System.out.println(formattedOrder);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Display the restaurant menu in a two-page format&#10;     * @param scanner Scanner for user input&#10;     */&#10;    public void displayRestaurantMenu(Scanner scanner) {&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 1      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;        String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;        // First page: first half of categories&#10;        int midpoint = categories.length / 2;&#10;        for (int i = 0; i &lt; midpoint; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to see the next page...&quot;);&#10;        scanner.nextLine();&#10;&#10;        // Second page: second half of categories&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 2      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        for (int i = midpoint; i &lt; categories.length; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Display a single menu category&#10;     * @param categoryName Name of the category&#10;     * @param items Map of items and their prices&#10;     */&#10;    private void displayMenuCategory(String categoryName, Map&lt;String, String&gt; items) {&#10;        System.out.println(&quot;\n--- &quot; + categoryName + &quot; ---&quot;);&#10;        for (Map.Entry&lt;String, String&gt; item : items.entrySet()) {&#10;            System.out.printf(&quot;%-30s %10s\n&quot;, item.getKey(), item.getValue());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generate bill for an order&#10;     *&#10;     * @param orderId The order ID&#10;     * @return Formatted bill as String&#10;     */&#10;    public String generateBill(String orderId) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return &quot;Order not found&quot;;&#10;        }&#10;&#10;        // Calculate additional charges&#10;        double subtotal = order.getTotalAmount();&#10;        double serviceCharge = subtotal * 0.02;&#10;        double gst = subtotal * 0.05;&#10;        double finalAmount = subtotal + serviceCharge + gst;&#10;&#10;        // Update order status and payment info in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET &quot; +&#10;                    &quot;bill_subtotal = ?, &quot; +&#10;                    &quot;service_charge = ?, &quot; +&#10;                    &quot;cgst_sgst = ?, &quot; +&#10;                    &quot;bill_total = ?, &quot; +&#10;                    &quot;payment_status = ?, &quot; +&#10;                    &quot;order_status = ? &quot; +&#10;                    &quot;WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setDouble(1, subtotal);&#10;                stmt.setDouble(2, serviceCharge);&#10;                stmt.setDouble(3, gst);&#10;                stmt.setDouble(4, finalAmount);&#10;                stmt.setString(5, &quot;COMPLETED&quot;);&#10;                stmt.setString(6, &quot;COMPLETED&quot;);&#10;                stmt.setString(7, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update bill information in database for order {}&quot;, orderId);&#10;                } else {&#10;                    logger.info(&quot;Bill information saved to database for order {}&quot;, orderId);&#10;                    // Update status in memory too&#10;                    order.setStatus(OrderStatus.COMPLETED);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while generating bill: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        StringBuilder bill = new StringBuilder();&#10;        bill.append(&quot;\n==========================================\n&quot;);&#10;        bill.append(&quot;             RESTAURANT BILL              \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Customer: &quot;).append(order.getCustomerName()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Date: &quot;).append(order.getOrderTime().toLocalDate()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Time: &quot;).append(order.getOrderTime().toLocalTime()).append(&quot;\n&quot;);&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %-8s %-10s %-10s\n&quot;, &quot;Item&quot;, &quot;Qty&quot;, &quot;Price&quot;, &quot;Subtotal&quot;));&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            bill.append(String.format(&quot;%-25s %-8d Rs.%-8.2f Rs.%.2f\n&quot;,&#10;                    item.getItemName(), item.getQuantity(), item.getPrice(), item.getSubtotal()));&#10;        }&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Total Amount&quot;, &quot;&quot;, subtotal));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;GST (5%)&quot;, &quot;&quot;, gst));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Service Charge (2%)&quot;, &quot;&quot;, serviceCharge));&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Grand Total&quot;, &quot;&quot;, finalAmount));&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;          Thank You! Visit Again!         \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;&#10;        return bill.toString();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.OrderStatus;&#10;import zeta.foods.model.User;&#10;import zeta.foods.model.Recipe;&#10;import zeta.foods.service.CustomerService;&#10;import zeta.foods.utils.CurrentInventory;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;import zeta.foods.utils.recipes;&#10;&#10;import java.sql.*;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.stream.Collectors;&#10;import org.json.JSONArray;&#10;import org.json.JSONObject;&#10;&#10;/**&#10; * Implementation of CustomerService for handling customer orders&#10; */&#10;public class CustomerServiceImpl implements CustomerService {&#10;    private static final Logger logger = LoggerFactory.getLogger(CustomerServiceImpl.class);&#10;&#10;    private static final Map&lt;String, Order&gt; orders = new HashMap&lt;&gt;();&#10;    private static final Map&lt;Long, List&lt;Order&gt;&gt; customerOrders = new HashMap&lt;&gt;();&#10;&#10;    @Override&#10;    public Order placeOrder(User user) {&#10;        Order order = new Order();&#10;        &#10;        // Handle case where user ID might be null (for temporary users created by waiters)&#10;        if (user.getId() != null) {&#10;            order.setCustomerId(user.getId());&#10;        } else {&#10;            // For walk-in customers or when waiter creates an order without a registered user&#10;            order.setCustomerId(0L);  // Use 0 to indicate a walk-in customer or temporary user&#10;        }&#10;        &#10;        order.setCustomerName(user.getUsername());&#10;&#10;        // Store order in memory cache&#10;        if (user.getId() != null) {&#10;            if (!customerOrders.containsKey(user.getId())) {&#10;                customerOrders.put(user.getId(), new ArrayList&lt;&gt;());&#10;            }&#10;            customerOrders.get(user.getId()).add(order);&#10;        }&#10;        orders.put(order.getOrderId(), order);&#10;&#10;        // Save order to database (initially empty)&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;INSERT INTO orders (order_id, customer_id, items, bill_subtotal, order_status) VALUES (?, ?, ?::jsonb, ?, ?)&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, order.getOrderId());&#10;                &#10;                // If user ID is null, use 0 for customer_id in database&#10;                if (user.getId() != null) {&#10;                    stmt.setLong(2, user.getId());&#10;                } else {&#10;                    stmt.setLong(2, 0L);&#10;                }&#10;                &#10;                stmt.setString(3, &quot;[]&quot;); // Empty JSON array for items initially&#10;                stmt.setDouble(4, 0.0); // Initial subtotal is 0&#10;                stmt.setString(5, order.getStatus().toString());&#10;&#10;                int rowsAffected = stmt.executeUpdate();&#10;                if (rowsAffected &gt; 0) {&#10;                    logger.info(&quot;Order {} saved to database&quot;, order.getOrderId());&#10;                } else {&#10;                    logger.error(&quot;Failed to save order {} to database&quot;, order.getOrderId());&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while saving order: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        logger.info(&quot;Created new order with ID: {} for customer: {}&quot;, order.getOrderId(), user.getUsername());&#10;        return order;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; getCustomerOrders(Long customerId) {&#10;        // Try to get orders from memory first&#10;        List&lt;Order&gt; cachedOrders = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no cached orders, try to load from database&#10;        if (cachedOrders.isEmpty()) {&#10;            return loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        return cachedOrders;&#10;    }&#10;&#10;    private List&lt;Order&gt; loadOrdersFromDatabase(Long customerId) {&#10;        List&lt;Order&gt; result = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;SELECT * FROM orders WHERE customer_id = ? ORDER BY order_timestamp DESC&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setLong(1, customerId);&#10;&#10;                try (ResultSet rs = stmt.executeQuery()) {&#10;                    while (rs.next()) {&#10;                        Order order = new Order();&#10;                        String orderId = rs.getString(&quot;order_id&quot;);&#10;                        order.setOrderId(orderId);&#10;                        order.setCustomerId(customerId);&#10;                        order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                        order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                        // Parse items from JSON&#10;                        String itemsJson = rs.getString(&quot;items&quot;);&#10;                        parseOrderItems(order, itemsJson);&#10;&#10;                        result.add(order);&#10;&#10;                        // Add to cache&#10;                        orders.put(orderId, order);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Update the cache&#10;            if (!result.isEmpty()) {&#10;                customerOrders.put(customerId, result);&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while loading orders: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    private void parseOrderItems(Order order, String itemsJson) {&#10;        try {&#10;            JSONArray itemsArray = new JSONArray(itemsJson);&#10;            for (int i = 0; i &lt; itemsArray.length(); i++) {&#10;                JSONObject itemObj = itemsArray.getJSONObject(i);&#10;                String category = itemObj.getString(&quot;category&quot;);&#10;                String itemName = itemObj.getString(&quot;itemName&quot;);&#10;                double price = itemObj.getDouble(&quot;price&quot;);&#10;                int quantity = itemObj.getInt(&quot;quantity&quot;);&#10;&#10;                OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;                order.addItem(item);&#10;            }&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing order items JSON: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Order getOrderStatus(String orderId) {&#10;        // Try to get from cache first&#10;        Order order = orders.get(orderId);&#10;&#10;        // If not in cache, try to load from database&#10;        if (order == null) {&#10;            try (Connection conn = DatabaseUtil.getConnection()) {&#10;                String sql = &quot;SELECT * FROM orders WHERE order_id = ?&quot;;&#10;&#10;                try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                    stmt.setString(1, orderId);&#10;&#10;                    try (ResultSet rs = stmt.executeQuery()) {&#10;                        if (rs.next()) {&#10;                            order = new Order();&#10;                            order.setOrderId(orderId);&#10;                            order.setCustomerId(rs.getLong(&quot;customer_id&quot;));&#10;                            order.setStatus(OrderStatus.valueOf(rs.getString(&quot;order_status&quot;)));&#10;                            order.setOrderTime(rs.getTimestamp(&quot;order_timestamp&quot;).toLocalDateTime());&#10;&#10;                            // Parse items from JSON&#10;                            String itemsJson = rs.getString(&quot;items&quot;);&#10;                            parseOrderItems(order, itemsJson);&#10;&#10;                            // Add to cache&#10;                            orders.put(orderId, order);&#10;                        }&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Database error while getting order status: {}&quot;, e.getMessage(), e);&#10;            }&#10;        }&#10;&#10;        return order;&#10;    }&#10;&#10;    /**&#10;     * Add an item to an existing order&#10;     *&#10;     * @param orderId   The order ID&#10;     * @param category   Menu category&#10;     * @param itemName  Item name&#10;     * @param quantity  Quantity&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean addItemToOrder(String orderId, String category, String itemName, int quantity) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            logger.warn(&quot;Order not found: {}&quot;, orderId);&#10;            return false;&#10;        }&#10;&#10;        // Get price from menu&#10;        String priceStr = menu.getItemPrice(category, itemName);&#10;        if (priceStr == null) {&#10;            logger.warn(&quot;Item not found in menu: {} in category {}&quot;, itemName, category);&#10;            return false;&#10;        }&#10;&#10;        // Parse price (remove &quot;Rs.&quot; prefix)&#10;        double price = menu.getPriceValue(priceStr);&#10;&#10;        // Check if we have the necessary ingredients for this item&#10;        OrderItem tempItem = new OrderItem(category, itemName, quantity, price);&#10;        List&lt;OrderItem&gt; itemsToCheck = new ArrayList&lt;&gt;();&#10;        itemsToCheck.add(tempItem);&#10;&#10;        // Check ingredient availability before adding to order&#10;        if (!CurrentInventory.checkIngredientsAvailability(itemsToCheck)) {&#10;            logger.warn(&quot;Cannot add {} to order: insufficient ingredients&quot;, itemName);&#10;            System.out.println(&quot;Sorry, we don't have enough ingredients to prepare &quot; + itemName + &quot; at this time.&quot;);&#10;            return false;&#10;        }&#10;&#10;        // Add item to order&#10;        OrderItem item = new OrderItem(category, itemName, quantity, price);&#10;        order.addItem(item);&#10;&#10;        // Update the order in the database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First, get all existing items for this order&#10;            String itemsJson = createItemsJson(order);&#10;&#10;            String sql = &quot;UPDATE orders SET items = ?::jsonb, bill_subtotal = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, itemsJson);&#10;                stmt.setDouble(2, order.getTotalAmount());&#10;                stmt.setString(3, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update order {} in database&quot;, orderId);&#10;                    return false;&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;&#10;        // Deduct ingredients from current inventory&#10;        CurrentInventory.useIngredientsForOrder(itemsToCheck);&#10;        logger.info(&quot;Added item to order {}: {} x{} ({})&quot;,&#10;                orderId, itemName, quantity, priceStr);&#10;        return true;&#10;    }&#10;&#10;    private String createItemsJson(Order order) {&#10;        JSONArray itemsArray = new JSONArray();&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            JSONObject itemObj = new JSONObject();&#10;            itemObj.put(&quot;category&quot;, item.getCategory());&#10;            itemObj.put(&quot;itemName&quot;, item.getItemName());&#10;            itemObj.put(&quot;price&quot;, item.getPrice());&#10;            itemObj.put(&quot;quantity&quot;, item.getQuantity());&#10;            itemsArray.put(itemObj);&#10;        }&#10;&#10;        return itemsArray.toString();&#10;    }&#10;&#10;    /**&#10;     * Update order status&#10;     *&#10;     * @param orderId Order ID&#10;     * @param status  New status&#10;     * @return true if successful, false otherwise&#10;     */&#10;    public boolean updateOrderStatus(String orderId, OrderStatus status) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return false;&#10;        }&#10;        order.setStatus(status);&#10;&#10;        // Update status in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET order_status = ? WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setString(1, status.toString());&#10;                stmt.setString(2, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                return rowsUpdated &gt; 0;&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while updating order status: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get a specified number of previous orders for a customer, sorted by most recent first&#10;     *&#10;     * @param customerId The customer's ID&#10;     * @param limit      Maximum number of orders to retrieve (default is 1 for latest order)&#10;     * @return List of the customer's orders in descending date order&#10;     */&#10;    public List&lt;Order&gt; getPreviousOrders(Long customerId, int limit) {&#10;        // Check if we have any orders in memory first&#10;        List&lt;Order&gt; customerOrderList = customerOrders.getOrDefault(customerId, new ArrayList&lt;&gt;());&#10;&#10;        // If no orders in memory, try to load from database&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in memory for customer ID: {}, loading from database...&quot;, customerId);&#10;            customerOrderList = loadOrdersFromDatabase(customerId);&#10;        }&#10;&#10;        // If still empty after trying to load from DB, return empty list&#10;        if (customerOrderList.isEmpty()) {&#10;            logger.info(&quot;No orders found in database for customer ID: {}&quot;, customerId);&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        // Sort orders by order time, most recent first&#10;        return customerOrderList.stream()&#10;                .sorted(Comparator.comparing(Order::getOrderTime).reversed())&#10;                .limit(limit &gt; 0 ? limit : 1) // Apply limit, with default of 1 if invalid limit&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    /**&#10;     * Format a single order for display&#10;     *&#10;     * @param order The order to format&#10;     * @return Formatted order summary as string&#10;     */&#10;    public String formatOrderSummary(Order order) {&#10;        if (order == null) {&#10;            return &quot;No order information available.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;);&#10;&#10;        StringBuilder summary = new StringBuilder();&#10;        summary.append(&quot;\n=================================\n&quot;);&#10;        summary.append(&quot;ORDER SUMMARY\n&quot;);&#10;        summary.append(&quot;=================================\n&quot;);&#10;        summary.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        summary.append(&quot;Date: &quot;).append(order.getOrderTime().format(dateFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Time: &quot;).append(order.getOrderTime().format(timeFormatter)).append(&quot;\n&quot;);&#10;        summary.append(&quot;Status: &quot;).append(order.getStatus()).append(&quot;\n&quot;);&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;&#10;        // List items&#10;        summary.append(&quot;ITEMS ORDERED:\n&quot;);&#10;        for (OrderItem item : order.getItems()) {&#10;            summary.append(String.format(&quot; %d x %s (Rs.%.2f)\n&quot;,&#10;                    item.getQuantity(), item.getItemName(), item.getPrice()));&#10;        }&#10;&#10;        summary.append(&quot;---------------------------------\n&quot;);&#10;        summary.append(String.format(&quot;Subtotal: Rs.%.2f\n&quot;, order.getTotalAmount()));&#10;&#10;        // Calculate additional charges&#10;        double serviceCharge = order.getTotalAmount() * 0.02;&#10;        double taxCharge = order.getTotalAmount() &gt; 150 ? 25.0 : 0.0;&#10;        double grandTotal = order.getTotalAmount() + serviceCharge + taxCharge;&#10;&#10;        summary.append(String.format(&quot;Service Charge (2%%): Rs.%.2f\n&quot;, serviceCharge));&#10;        summary.append(String.format(&quot;CGST &amp; SGST: Rs.%.2f\n&quot;, taxCharge));&#10;        summary.append(String.format(&quot;Grand Total: Rs.%.2f\n&quot;, grandTotal));&#10;        summary.append(&quot;=================================\n&quot;);&#10;&#10;        return summary.toString();&#10;    }&#10;&#10;    /**&#10;     * Format multiple orders for display&#10;     *&#10;     * @param orders List of orders to format&#10;     * @return Formatted list of order summaries as string&#10;     */&#10;    public String formatOrdersList(List&lt;Order&gt; orders) {&#10;        if (orders == null || orders.isEmpty()) {&#10;            return &quot;No previous orders found.&quot;;&#10;        }&#10;&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;);&#10;&#10;        StringBuilder result = new StringBuilder();&#10;        result.append(&quot;\n=================================\n&quot;);&#10;        result.append(&quot;YOUR ORDER HISTORY\n&quot;);&#10;        result.append(&quot;=================================\n&quot;);&#10;&#10;        int count = 1;&#10;        for (Order order : orders) {&#10;            result.append(String.format(&quot;%d. Order #%s - %s\n&quot;,&#10;                    count++,&#10;                    order.getOrderId(),&#10;                    order.getOrderTime().format(formatter)));&#10;&#10;            result.append(String.format(&quot;   Status: %s, Total: Rs.%.2f\n&quot;,&#10;                    order.getStatus(),&#10;                    order.getTotalAmount()));&#10;&#10;            // Show item count&#10;            result.append(String.format(&quot;   Items: %d\n&quot;, order.getItems().size()));&#10;        }&#10;&#10;        result.append(&quot;=================================\n&quot;);&#10;        return result.toString();&#10;    }&#10;&#10;    /**&#10;     * View order status for a customer with option to specify number of orders to display&#10;     *&#10;     * @param user The user viewing their order history&#10;     */&#10;    public void viewOrderStatus(User user) {&#10;        Scanner scanner = new Scanner(System.in);&#10;        System.out.println(&quot;\n=== Your Order History ===&quot;);&#10;&#10;        // Ask user how many orders they want to view&#10;        System.out.print(&quot;How many recent orders would you like to view? (default: 1): &quot;);&#10;        String input = scanner.nextLine().trim();&#10;&#10;        // Parse input, default to 1 if empty or invalid&#10;        int limit = 1;&#10;        if (!input.isEmpty()) {&#10;            try {&#10;                limit = Integer.parseInt(input);&#10;                if (limit &lt;= 0) {&#10;                    limit = 1;&#10;                    System.out.println(&quot;Invalid number. Showing the most recent order.&quot;);&#10;                }&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Invalid input. Showing the most recent order.&quot;);&#10;            }&#10;        }&#10;&#10;        // Get previous orders for the customer&#10;        List&lt;Order&gt; previousOrders = getPreviousOrders(user.getId(), limit);&#10;&#10;        if (previousOrders.isEmpty()) {&#10;            System.out.println(&quot;You don't have any orders yet.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Display each order&#10;        System.out.printf(&quot;Showing your %d most recent order(s):\n\n&quot;, previousOrders.size());&#10;        for (int i = 0; i &lt; previousOrders.size(); i++) {&#10;            if (i &gt; 0) {&#10;                System.out.println(&quot;\n&quot; + &quot;-&quot;.repeat(40) + &quot;\n&quot;);&#10;            }&#10;            Order order = previousOrders.get(i);&#10;            String formattedOrder = formatOrderSummary(order);&#10;            System.out.println(formattedOrder);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Display the restaurant menu in a two-page format&#10;     * @param scanner Scanner for user input&#10;     */&#10;    public void displayRestaurantMenu(Scanner scanner) {&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 1      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;        String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;        // First page: first half of categories&#10;        int midpoint = categories.length / 2;&#10;        for (int i = 0; i &lt; midpoint; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to see the next page...&quot;);&#10;        scanner.nextLine();&#10;&#10;        // Second page: second half of categories&#10;        System.out.println(&quot;\n========================================&quot;);&#10;        System.out.println(&quot;          RESTAURANT MENU - PAGE 2      &quot;);&#10;        System.out.println(&quot;========================================&quot;);&#10;&#10;        for (int i = midpoint; i &lt; categories.length; i++) {&#10;            displayMenuCategory(categories[i], menuItems.get(categories[i]));&#10;        }&#10;&#10;        System.out.println(&quot;\nPress Enter to return to main menu...&quot;);&#10;        scanner.nextLine();&#10;    }&#10;&#10;    /**&#10;     * Display a single menu category&#10;     * @param categoryName Name of the category&#10;     * @param items Map of items and their prices&#10;     */&#10;    private void displayMenuCategory(String categoryName, Map&lt;String, String&gt; items) {&#10;        System.out.println(&quot;\n--- &quot; + categoryName + &quot; ---&quot;);&#10;        for (Map.Entry&lt;String, String&gt; item : items.entrySet()) {&#10;            System.out.printf(&quot;%-30s %10s\n&quot;, item.getKey(), item.getValue());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generate bill for an order&#10;     *&#10;     * @param orderId The order ID&#10;     * @return Formatted bill as String&#10;     */&#10;    public String generateBill(String orderId) {&#10;        Order order = orders.get(orderId);&#10;        if (order == null) {&#10;            return &quot;Order not found&quot;;&#10;        }&#10;&#10;        // Calculate additional charges&#10;        double subtotal = order.getTotalAmount();&#10;        double serviceCharge = subtotal * 0.02;&#10;        double gst = subtotal * 0.05;&#10;        double finalAmount = subtotal + serviceCharge + gst;&#10;&#10;        // Update order status and payment info in database&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            String sql = &quot;UPDATE orders SET &quot; +&#10;                    &quot;bill_subtotal = ?, &quot; +&#10;                    &quot;service_charge = ?, &quot; +&#10;                    &quot;cgst_sgst = ?, &quot; +&#10;                    &quot;bill_total = ?, &quot; +&#10;                    &quot;payment_status = ?, &quot; +&#10;                    &quot;order_status = ? &quot; +&#10;                    &quot;WHERE order_id = ?&quot;;&#10;&#10;            try (PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;                stmt.setDouble(1, subtotal);&#10;                stmt.setDouble(2, serviceCharge);&#10;                stmt.setDouble(3, gst);&#10;                stmt.setDouble(4, finalAmount);&#10;                stmt.setString(5, &quot;COMPLETED&quot;);&#10;                stmt.setString(6, &quot;COMPLETED&quot;);&#10;                stmt.setString(7, orderId);&#10;&#10;                int rowsUpdated = stmt.executeUpdate();&#10;                if (rowsUpdated == 0) {&#10;                    logger.error(&quot;Failed to update bill information in database for order {}&quot;, orderId);&#10;                } else {&#10;                    logger.info(&quot;Bill information saved to database for order {}&quot;, orderId);&#10;                    // Update status in memory too&#10;                    order.setStatus(OrderStatus.COMPLETED);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error while generating bill: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        // Build bill content&#10;        StringBuilder bill = new StringBuilder();&#10;        bill.append(&quot;\n==========================================\n&quot;);&#10;        bill.append(&quot;             RESTAURANT BILL              \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;Order ID: &quot;).append(order.getOrderId()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Customer: &quot;).append(order.getCustomerName()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Date: &quot;).append(order.getOrderTime().toLocalDate()).append(&quot;\n&quot;);&#10;        bill.append(&quot;Time: &quot;).append(order.getOrderTime().toLocalTime()).append(&quot;\n&quot;);&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %-8s %-10s %-10s\n&quot;, &quot;Item&quot;, &quot;Qty&quot;, &quot;Price&quot;, &quot;Subtotal&quot;));&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;&#10;        for (OrderItem item : order.getItems()) {&#10;            bill.append(String.format(&quot;%-25s %-8d Rs.%-8.2f Rs.%.2f\n&quot;,&#10;                    item.getItemName(), item.getQuantity(), item.getPrice(), item.getSubtotal()));&#10;        }&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Total Amount&quot;, &quot;&quot;, subtotal));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;GST (5%)&quot;, &quot;&quot;, gst));&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Service Charge (2%)&quot;, &quot;&quot;, serviceCharge));&#10;&#10;        bill.append(&quot;------------------------------------------\n&quot;);&#10;        bill.append(String.format(&quot;%-25s %19s Rs.%.2f\n&quot;, &quot;Grand Total&quot;, &quot;&quot;, finalAmount));&#10;        bill.append(&quot;==========================================\n&quot;);&#10;        bill.append(&quot;          Thank You! Visit Again!         \n&quot;);&#10;        bill.append(&quot;==========================================\n&quot;);&#10;&#10;        return bill.toString();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/FirebaseAuthServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/FirebaseAuthServiceImpl.java" />
              <option name="originalContent" value="package zeta.foods.service.impl;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseAuthException;&#10;import com.google.firebase.auth.UserRecord;&#10;import com.google.firebase.auth.UserRecord.CreateRequest;&#10;import zeta.foods.service.FirebaseAuthService;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class FirebaseAuthServiceImpl implements FirebaseAuthService {&#10;&#10;    private static final String ADMIN_EMAIL = &quot;ambatisaiteja123@gmail.com&quot;;&#10;&#10;    // Predefined waiter accounts&#10;    private static final Map&lt;String, String&gt; WAITERS = new HashMap&lt;&gt;();&#10;&#10;    static {&#10;        // Initialize waiters with email and password &quot;12345678&quot;&#10;        WAITERS.put(&quot;waiter1@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter2@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter3@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter4@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter5@restaurant.com&quot;, &quot;12345678&quot;);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord authenticateUser(String email, String password) {&#10;        try {&#10;            // For admin authentication&#10;            if (email.equals(ADMIN_EMAIL) || WAITERS.containsKey(email)) {&#10;                // In real implementation, this would verify the password with Firebase&#10;                // Here we're just checking if it's a known user&#10;                return FirebaseAuth.getInstance().getUserByEmail(email);&#10;            }&#10;            return null;&#10;        } catch (FirebaseAuthException e) {&#10;            System.err.println(&quot;Authentication failed: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean isAdmin(String email) {&#10;        return email.equals(ADMIN_EMAIL);&#10;    }&#10;&#10;    @Override&#10;    public boolean isWaiter(String email) {&#10;        return WAITERS.containsKey(email);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord createUser(String email, String password, boolean isAdmin) {&#10;        CreateRequest request = new CreateRequest()&#10;                .setEmail(email)&#10;                .setPassword(password)&#10;                .setEmailVerified(true);&#10;&#10;        try {&#10;            UserRecord userRecord = FirebaseAuth.getInstance().createUser(request);&#10;&#10;            // Add custom claims for role-based access&#10;            Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();&#10;            claims.put(&quot;admin&quot;, isAdmin);&#10;            claims.put(&quot;waiter&quot;, !isAdmin);&#10;&#10;            FirebaseAuth.getInstance().setCustomUserClaims(userRecord.getUid(), claims);&#10;&#10;            return userRecord;&#10;        } catch (FirebaseAuthException e) {&#10;            System.err.println(&quot;Error creating user: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    // Method to create predefined users if they don't exist&#10;    public void setupPredefinedUsers() {&#10;        try {&#10;            // Try to create admin&#10;            try {&#10;                FirebaseAuth.getInstance().getUserByEmail(ADMIN_EMAIL);&#10;            } catch (FirebaseAuthException e) {&#10;                // User doesn't exist, create it&#10;                createUser(ADMIN_EMAIL, &quot;admin123&quot;, true);&#10;                System.out.println(&quot;Created admin user: &quot; + ADMIN_EMAIL);&#10;            }&#10;&#10;            // Create waiter accounts&#10;            for (String waiterEmail : WAITERS.keySet()) {&#10;                try {&#10;                    FirebaseAuth.getInstance().getUserByEmail(waiterEmail);&#10;                } catch (FirebaseAuthException e) {&#10;                    // User doesn't exist, create it&#10;                    createUser(waiterEmail, WAITERS.get(waiterEmail), false);&#10;                    System.out.println(&quot;Created waiter user: &quot; + waiterEmail);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error setting up predefined users: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service.impl;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseAuthException;&#10;import com.google.firebase.auth.UserRecord;&#10;import com.google.firebase.auth.UserRecord.CreateRequest;&#10;import zeta.foods.service.FirebaseAuthService;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class FirebaseAuthServiceImpl implements FirebaseAuthService {&#10;&#10;    private static final String ADMIN_EMAIL = &quot;ambatisaiteja123@gmail.com&quot;;&#10;&#10;    // Predefined waiter accounts&#10;    private static final Map&lt;String, String&gt; WAITERS = new HashMap&lt;&gt;();&#10;&#10;    static {&#10;        // Initialize waiters with email and password &quot;12345678&quot;&#10;        WAITERS.put(&quot;waiter1@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter2@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter3@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter4@restaurant.com&quot;, &quot;12345678&quot;);&#10;        WAITERS.put(&quot;waiter5@restaurant.com&quot;, &quot;12345678&quot;);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord authenticateUser(String email, String password) {&#10;        try {&#10;            // For test mode, we'll simulate authentication with predefined accounts&#10;            if ((email.equals(ADMIN_EMAIL) || WAITERS.containsKey(email)) &amp;&amp;&#10;                    password.equals(&quot;12345678&quot;)) {&#10;&#10;                // Create a mock UserRecord for testing purposes&#10;                // In production, this would verify with Firebase&#10;                System.out.println(&quot;Test authentication successful for: &quot; + email);&#10;                return createMockUserRecord(email);&#10;            }&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Authentication failed: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private UserRecord createMockUserRecord(String email) {&#10;        // Use anonymous class to create a mock UserRecord&#10;        return new UserRecord() {&#10;            @Override&#10;            public String getUid() {&#10;                return &quot;test-uid-&quot; + email.hashCode();&#10;            }&#10;&#10;            @Override&#10;            public String getEmail() {&#10;                return email;&#10;            }&#10;&#10;            @Override&#10;            public boolean isEmailVerified() {&#10;                return true;&#10;            }&#10;&#10;            // Implement other required methods with defaults&#10;            @Override&#10;            public String getDisplayName() {&#10;                return null;&#10;            }&#10;&#10;            @Override&#10;            public String getPhotoUrl() {&#10;                return null;&#10;            }&#10;&#10;            @Override&#10;            public String getPhoneNumber() {&#10;                return null;&#10;            }&#10;&#10;            @Override&#10;            public boolean isDisabled() {&#10;                return false;&#10;            }&#10;&#10;            @Override&#10;            public UserRecord.UserMetadata getUserMetadata() {&#10;                return new UserRecord.UserMetadata(System.currentTimeMillis(), System.currentTimeMillis());&#10;            }&#10;&#10;            @Override&#10;            public UserRecord.ProviderUserInfo[] getProviderData() {&#10;                return new UserRecord.ProviderUserInfo[0];&#10;            }&#10;&#10;            @Override&#10;            public Map&lt;String, Object&gt; getCustomClaims() {&#10;                return new HashMap&lt;&gt;();&#10;            }&#10;&#10;            @Override&#10;            public long getTokensValidAfterTimestamp() {&#10;                return 0;&#10;            }&#10;&#10;            @Override&#10;            public String getTenantId() {&#10;                return null;&#10;            }&#10;        };&#10;    }&#10;&#10;    @Override&#10;    public boolean isAdmin(String email) {&#10;        return email.equals(ADMIN_EMAIL);&#10;    }&#10;&#10;    @Override&#10;    public boolean isWaiter(String email) {&#10;        return WAITERS.containsKey(email);&#10;    }&#10;&#10;    @Override&#10;    public UserRecord createUser(String email, String password, boolean isAdmin) {&#10;        CreateRequest request = new CreateRequest()&#10;                .setEmail(email)&#10;                .setPassword(password)&#10;                .setEmailVerified(true);&#10;&#10;        try {&#10;            UserRecord userRecord = FirebaseAuth.getInstance().createUser(request);&#10;&#10;            // Add custom claims for role-based access&#10;            Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();&#10;            claims.put(&quot;admin&quot;, isAdmin);&#10;            claims.put(&quot;waiter&quot;, !isAdmin);&#10;&#10;            FirebaseAuth.getInstance().setCustomUserClaims(userRecord.getUid(), claims);&#10;&#10;            return userRecord;&#10;        } catch (FirebaseAuthException e) {&#10;            System.err.println(&quot;Error creating user: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    // Method to create predefined users if they don't exist&#10;    public void setupPredefinedUsers() {&#10;        try {&#10;            // Try to create admin&#10;            try {&#10;                FirebaseAuth.getInstance().getUserByEmail(ADMIN_EMAIL);&#10;            } catch (FirebaseAuthException e) {&#10;                // User doesn't exist, create it&#10;                createUser(ADMIN_EMAIL, &quot;admin123&quot;, true);&#10;                System.out.println(&quot;Created admin user: &quot; + ADMIN_EMAIL);&#10;            }&#10;&#10;            // Create waiter accounts&#10;            for (String waiterEmail : WAITERS.keySet()) {&#10;                try {&#10;                    FirebaseAuth.getInstance().getUserByEmail(waiterEmail);&#10;                } catch (FirebaseAuthException e) {&#10;                    // User doesn't exist, create it&#10;                    createUser(waiterEmail, WAITERS.get(waiterEmail), false);&#10;                    System.out.println(&quot;Created waiter user: &quot; + waiterEmail);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error setting up predefined users: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/PostgresAuthServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/PostgresAuthServiceImpl.java" />
              <option name="originalContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.AuthService;&#10;import zeta.foods.utils.DatabaseUtil;&#10;&#10;import java.sql.*;&#10;import java.util.Scanner;&#10;&#10;public class PostgresAuthServiceImpl implements AuthService {&#10;    private static final Logger logger = LoggerFactory.getLogger(PostgresAuthServiceImpl.class);&#10;&#10;    @Override&#10;    public User authenticateUser(String email, String password) {&#10;        // Log authentication attempt but mask password for security&#10;        logger.info(&quot;Attempting to authenticate user: '{}'&quot;, email);&#10;        logger.info(&quot;Password length: {}, Password value: '{}'&quot;, password != null ? password.length() : &quot;null&quot;, password);&#10;&#10;        // Print each character code to check for hidden/special characters&#10;        if (password != null) {&#10;            StringBuilder charCodes = new StringBuilder(&quot;Password char codes: &quot;);&#10;            for (char c : password.toCharArray()) {&#10;                charCodes.append((int)c).append(&quot;,&quot;);&#10;            }&#10;            logger.info(charCodes.toString());&#10;        }&#10;&#10;        // Debug: directly check if user exists with this exact email and password&#10;        try (Connection debugConn = DatabaseUtil.getConnection();&#10;             Statement debugStmt = debugConn.createStatement()) {&#10;&#10;            // First get all users matching the email only&#10;            String emailOnlyQuery = &quot;SELECT * FROM users WHERE email = '&quot; + email + &quot;'&quot;;&#10;            try (ResultSet emailRs = debugStmt.executeQuery(emailOnlyQuery)) {&#10;                if (emailRs.next()) {&#10;                    String dbEmail = emailRs.getString(&quot;email&quot;);&#10;                    String dbPassword = emailRs.getString(&quot;password&quot;);&#10;&#10;                    logger.info(&quot;Found user with email: '{}', DB password: '{}'&quot;, dbEmail, dbPassword);&#10;                    logger.info(&quot;Password length from DB: {}&quot;, dbPassword.length());&#10;&#10;                    // Print each character code of DB password&#10;                    StringBuilder dbCharCodes = new StringBuilder(&quot;DB Password char codes: &quot;);&#10;                    for (char c : dbPassword.toCharArray()) {&#10;                        dbCharCodes.append((int)c).append(&quot;,&quot;);&#10;                    }&#10;                    logger.info(dbCharCodes.toString());&#10;&#10;                    // Direct character-by-character comparison&#10;                    logger.info(&quot;Direct password comparison result: {}&quot;, dbPassword.equals(password));&#10;&#10;                    if (!dbPassword.equals(password)) {&#10;                        logger.info(&quot;Password mismatch details:&quot;);&#10;                        if (dbPassword.length() != password.length()) {&#10;                            logger.info(&quot;Length differs: DB={}, Input={}&quot;, dbPassword.length(), password.length());&#10;                        } else {&#10;                            for (int i = 0; i &lt; dbPassword.length(); i++) {&#10;                                if (dbPassword.charAt(i) != password.charAt(i)) {&#10;                                    logger.info(&quot;Mismatch at position {}: DB='{}' ({}), Input='{}' ({})&quot;,&#10;                                        i, dbPassword.charAt(i), (int)dbPassword.charAt(i),&#10;                                        password.charAt(i), (int)password.charAt(i));&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                } else {&#10;                    logger.warn(&quot;No user found with email: '{}'&quot;, email);&#10;                }&#10;            }&#10;&#10;            // Now try the full authentication query&#10;            String debugQuery = &quot;SELECT * FROM users WHERE email = '&quot; + email + &quot;' AND password = '&quot; + password + &quot;'&quot;;&#10;//            String debugQuery = &quot;SELECT * FROM users WHERE email = 'ambatisaiteja123@gmail.com' AND password = 'admin123'&quot;;&#10;            logger.info(&quot;Executing direct query: {}&quot;, debugQuery);&#10;&#10;&#10;            try (ResultSet debugRs = debugStmt.executeQuery(debugQuery)) {&#10;                if (debugRs.next()) {&#10;                    logger.info(&quot;DEBUG - Direct query found matching user!&quot;);&#10;                } else {&#10;                    logger.warn(&quot;DEBUG - Direct query found NO matching user!&quot;);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;DEBUG - Error in diagnostic queries: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        String sql = &quot;SELECT * FROM users WHERE email = ? AND password = ?&quot;;&#10;&#10;        logger.info(&quot;Preparing to execute authentication query for email: {}, password: {}&quot;, email, password);&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, email);&#10;            stmt.setString(2, password);&#10;            logger.debug(&quot;Executing authentication query for email: {}&quot;, email);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    User user = new User();&#10;                    user.setId(rs.getLong(&quot;id&quot;));&#10;                    user.setUsername(rs.getString(&quot;username&quot;));&#10;                    user.setEmail(rs.getString(&quot;email&quot;));&#10;                    user.setRole(rs.getString(&quot;role&quot;));&#10;&#10;                    // Update last login time&#10;                    updateLastLogin(user.getId());&#10;&#10;                    logger.info(&quot;User authenticated successfully: {}&quot;, email);&#10;                    return user;&#10;                } else {&#10;                    logger.warn(&quot;No user found with email: {} and provided password&quot;, email);&#10;                }&#10;            }&#10;&#10;            logger.warn(&quot;Authentication failed for user: {}&quot;, email);&#10;            return null;&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error during authentication: {}&quot;, e.getMessage(), e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Interactive console login method that handles the scanner input directly&#10;     * This is useful when running in Docker or other environments where&#10;     * standard input handling might be tricky&#10;     */&#10;    public User consoleLogin() {&#10;        // Use System.console() if available, otherwise fall back to Scanner&#10;        User authenticatedUser = null;&#10;        int attempts = 0;&#10;        final int MAX_ATTEMPTS = 3;&#10;&#10;        // Print a visual separator to make the prompt more visible&#10;        System.out.println(&quot;\n*************************************&quot;);&#10;        System.out.println(&quot;*          WELCOME                  *&quot;);&#10;        System.out.println(&quot;*************************************\n&quot;);&#10;        System.out.println(&quot;1. Login&quot;);&#10;        System.out.println(&quot;2. Sign Up (New Customer)&quot;);&#10;        System.out.println(&quot;0. Exit&quot;);&#10;        System.out.print(&quot;\nSelect an option: &quot;);&#10;        &#10;        Scanner scanner = new Scanner(System.in);&#10;        String option = scanner.nextLine().trim();&#10;        &#10;        switch (option) {&#10;            case &quot;1&quot;:&#10;                // Login process&#10;                while (attempts &lt; MAX_ATTEMPTS &amp;&amp; authenticatedUser == null) {&#10;                    try {&#10;                        String email = null;&#10;                        String password = null;&#10;&#10;                        // Try to use console if available (better for password input)&#10;                        if (System.console() != null) {&#10;                            System.out.print(&quot;\nEnter email: &quot;);&#10;                            email = System.console().readLine();&#10;                            System.out.print(&quot;Enter password: &quot;);&#10;                            password = new String(System.console().readLine());&#10;                        } else {&#10;                            // Fall back to Scanner with flush to ensure prompt is visible&#10;                            System.out.print(&quot;\nEnter email: &quot;);&#10;                            System.out.flush();&#10;                            email = scanner.nextLine().trim();&#10;&#10;                            System.out.print(&quot;Enter password: &quot;);&#10;                            System.out.flush();&#10;                            password = scanner.nextLine().trim();&#10;                        }&#10;&#10;                        if (email == null || email.isEmpty()) {&#10;                            System.out.println(&quot;Email cannot be empty. Please try again.&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        // Handle special commands&#10;                        if (&quot;exit&quot;.equalsIgnoreCase(email)) {&#10;                            logger.info(&quot;Login process aborted by user&quot;);&#10;                            break;&#10;                        } else if (&quot;simulate&quot;.equalsIgnoreCase(email)) {&#10;                            logger.info(&quot;Simulation requested from console login&quot;);&#10;                            return null; // Special case to trigger simulation&#10;                        }&#10;&#10;                        // Use the provided credentials&#10;                        authenticatedUser = authenticateUser(email, password);&#10;&#10;                        // Handle authentication result&#10;                        if (authenticatedUser == null) {&#10;                            attempts++;&#10;                            logger.warn(&quot;Login failed. Attempt {} of {}&quot;, attempts, MAX_ATTEMPTS);&#10;                            if (attempts &lt; MAX_ATTEMPTS) {&#10;                                System.out.println(&quot;Invalid email or password. Please try again.&quot;);&#10;                            }&#10;                        } else {&#10;                            System.out.println(&quot;\nWelcome, &quot; + authenticatedUser.getUsername() + &quot;!&quot;);&#10;                            System.out.println(&quot;You are logged in as: &quot; + authenticatedUser.getRole());&#10;                            displayMenuForRole(authenticatedUser.getRole());&#10;                        }&#10;                    } catch (Exception e) {&#10;                        logger.error(&quot;Error during console login: {}&quot;, e.getMessage(), e);&#10;                        System.out.println(&quot;An error occurred. Please try again.&quot;);&#10;                        attempts++;&#10;                    }&#10;                }&#10;&#10;                if (authenticatedUser == null &amp;&amp; attempts &gt;= MAX_ATTEMPTS) {&#10;                    System.out.println(&quot;Maximum login attempts exceeded. Please try again later.&quot;);&#10;                }&#10;                break;&#10;                &#10;            case &quot;2&quot;:&#10;                // Sign up process&#10;                authenticatedUser = consoleSignup(scanner);&#10;                if (authenticatedUser != null) {&#10;                    System.out.println(&quot;\nWelcome, &quot; + authenticatedUser.getUsername() + &quot;!&quot;);&#10;                    System.out.println(&quot;You are logged in as: &quot; + authenticatedUser.getRole());&#10;                    displayMenuForRole(authenticatedUser.getRole());&#10;                }&#10;                break;&#10;                &#10;            case &quot;0&quot;:&#10;                logger.info(&quot;User chose to exit&quot;);&#10;                break;&#10;                &#10;            default:&#10;                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;        }&#10;&#10;        return authenticatedUser;&#10;    }&#10;    &#10;    /**&#10;     * Interactive console signup method for new customers&#10;     * &#10;     * @param scanner Scanner for reading user input&#10;     * @return The newly created and authenticated User object, or null if signup failed&#10;     */&#10;    private User consoleSignup(Scanner scanner) {&#10;        System.out.println(&quot;\n*************************************&quot;);&#10;        System.out.println(&quot;*          NEW CUSTOMER SIGNUP      *&quot;);&#10;        System.out.println(&quot;*************************************\n&quot;);&#10;        &#10;        try {&#10;            // Get username&#10;            System.out.print(&quot;Enter your name: &quot;);&#10;            String username = scanner.nextLine().trim();&#10;            if (username.isEmpty()) {&#10;                System.out.println(&quot;Name cannot be empty.&quot;);&#10;                return null;&#10;            }&#10;            &#10;            // Get and validate email&#10;            String email = &quot;&quot;;&#10;            boolean validEmail = false;&#10;            while (!validEmail) {&#10;                System.out.print(&quot;Enter your email: &quot;);&#10;                email = scanner.nextLine().trim();&#10;                &#10;                if (email.isEmpty()) {&#10;                    System.out.println(&quot;Email cannot be empty.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                if (!isValidEmail(email)) {&#10;                    System.out.println(&quot;Invalid email format. Please enter a valid email address.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                if (userExists(email)) {&#10;                    System.out.println(&quot;This email is already registered. Please use another email or log in.&quot;);&#10;                    return null;&#10;                }&#10;                &#10;                validEmail = true;&#10;            }&#10;            &#10;            // Get and validate password&#10;            String password = &quot;&quot;;&#10;            String confirmPassword = &quot;&quot;;&#10;            boolean validPassword = false;&#10;            while (!validPassword) {&#10;                System.out.print(&quot;Enter password (minimum 6 characters): &quot;);&#10;                password = scanner.nextLine().trim();&#10;                &#10;                if (password.length() &lt; 6) {&#10;                    System.out.println(&quot;Password must be at least 6 characters long.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                System.out.print(&quot;Confirm password: &quot;);&#10;                confirmPassword = scanner.nextLine().trim();&#10;                &#10;                if (!password.equals(confirmPassword)) {&#10;                    System.out.println(&quot;Passwords do not match. Please try again.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                validPassword = true;&#10;            }&#10;            &#10;            // Register the new user&#10;            User newUser = registerUser(username, email, password, &quot;customer&quot;);&#10;            &#10;            if (newUser != null) {&#10;                System.out.println(&quot;\nRegistration successful! Your account has been created.&quot;);&#10;                return newUser;&#10;            } else {&#10;                System.out.println(&quot;\nRegistration failed. Please try again later.&quot;);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during console signup: {}&quot;, e.getMessage(), e);&#10;            System.out.println(&quot;An error occurred during registration. Please try again later.&quot;);&#10;        }&#10;        &#10;        return null;&#10;    }&#10;    &#10;    /**&#10;     * Display appropriate menu based on user role&#10;     */&#10;    private void displayMenuForRole(String role) {&#10;        System.out.println(&quot;\n=== &quot; + role.toUpperCase() + &quot; MENU ===&quot;);&#10;&#10;        switch (role.toLowerCase()) {&#10;            case &quot;admin&quot;:&#10;                System.out.println(&quot;1. Manage Users&quot;);&#10;                System.out.println(&quot;2. View System Reports&quot;);&#10;                System.out.println(&quot;3. Fetch Current Inventory&quot;);&#10;                System.out.println(&quot;4. Restore Current Inventory&quot;);&#10;                System.out.println(&quot;5. Manage Menu Items&quot;);&#10;                break;&#10;&#10;            case &quot;waiter&quot;:&#10;                System.out.println(&quot;1. Take New Order&quot;);&#10;                System.out.println(&quot;2. View Table Status&quot;);&#10;                System.out.println(&quot;3. Process Payment&quot;);&#10;                break;&#10;&#10;            case &quot;customer&quot;:&#10;                System.out.println(&quot;1. View Menu&quot;);&#10;                System.out.println(&quot;2. Place Order&quot;);&#10;                System.out.println(&quot;3. View Order Status&quot;);&#10;                break;&#10;&#10;            default:&#10;                System.out.println(&quot;No specific menu available for this role.&quot;);&#10;        }&#10;&#10;        System.out.println(&quot;0. Logout&quot;);&#10;        System.out.print(&quot;\nPlease enter your choice: &quot;);&#10;    }&#10;&#10;    @Override&#10;    public boolean isAdmin(String email) {&#10;        return checkUserRole(email, &quot;admin&quot;);&#10;    }&#10;&#10;    @Override&#10;    public boolean isWaiter(String email) {&#10;        return checkUserRole(email, &quot;waiter&quot;);&#10;    }&#10;&#10;    private boolean checkUserRole(String email, String role) {&#10;        String sql = &quot;SELECT role FROM users WHERE email = ?&quot;;&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, email);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                return rs.next() &amp;&amp; role.equals(rs.getString(&quot;role&quot;));&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error checking user role: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User createUser(String username, String email, String password, String role) {&#10;        String sql = &quot;INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?) RETURNING id&quot;;&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            // Store the password as plain text&#10;            stmt.setString(1, username);&#10;            stmt.setString(2, email);&#10;            stmt.setString(3, password);&#10;            stmt.setString(4, role);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    User user = new User();&#10;                    user.setId(rs.getLong(&quot;id&quot;));&#10;                    user.setUsername(username);&#10;                    user.setEmail(email);&#10;                    user.setRole(role);&#10;&#10;                    logger.info(&quot;Created new user: {} with role: {}&quot;, email, role);&#10;                    return user;&#10;                }&#10;            }&#10;&#10;            return null;&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error creating user: {}&quot;, e.getMessage(), e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean updateLastLogin(Long userId) {&#10;        String sql = &quot;UPDATE users SET last_login = NOW() WHERE id = ?&quot;;&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setLong(1, userId);&#10;            int rowsAffected = stmt.executeUpdate();&#10;&#10;            return rowsAffected &gt; 0;&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error updating last login: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Register a new user in the system&#10;     * &#10;     * @param username The username for the new user&#10;     * @param email The email address for the new user&#10;     * @param password The password for the new user&#10;     * @param role The role of the new user (usually &quot;customer&quot; for new registrations)&#10;     * @return The newly created User object, or null if registration failed&#10;     */&#10;    public User registerUser(String username, String email, String password, String role) {&#10;        logger.info(&quot;Attempting to register new user with email: {}&quot;, email);&#10;        &#10;        // Validate email format using regex&#10;        if (!isValidEmail(email)) {&#10;            logger.warn(&quot;Invalid email format: {}&quot;, email);&#10;            return null;&#10;        }&#10;        &#10;        // Check if user already exists&#10;        if (userExists(email)) {&#10;            logger.warn(&quot;User with email {} already exists&quot;, email);&#10;            return null;&#10;        }&#10;        &#10;        String sql = &quot;INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?) RETURNING id&quot;;&#10;        &#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;            &#10;            stmt.setString(1, username);&#10;            stmt.setString(2, email);&#10;            stmt.setString(3, password);&#10;            stmt.setString(4, role);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    // Create and return the new user&#10;                    User newUser = new User();&#10;                    newUser.setId(rs.getLong(&quot;id&quot;));&#10;                    newUser.setUsername(username);&#10;                    newUser.setEmail(email);&#10;                    newUser.setRole(role);&#10;                    &#10;                    logger.info(&quot;New user registered successfully: {}&quot;, email);&#10;                    return newUser;&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error during user registration: {}&quot;, e.getMessage(), e);&#10;        }&#10;        &#10;        return null;&#10;    }&#10;    &#10;    /**&#10;     * Check if a user with the given email already exists&#10;     * &#10;     * @param email The email to check&#10;     * @return true if the user exists, false otherwise&#10;     */&#10;    private boolean userExists(String email) {&#10;        String sql = &quot;SELECT COUNT(*) FROM users WHERE email = ?&quot;;&#10;        &#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;            &#10;            stmt.setString(1, email);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getInt(1) &gt; 0;&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error checking if user exists: {}&quot;, e.getMessage(), e);&#10;        }&#10;        &#10;        return false;&#10;    }&#10;    &#10;    /**&#10;     * Validate email format using regex&#10;     * &#10;     * @param email The email to validate&#10;     * @return true if the email is valid, false otherwise&#10;     */&#10;    private boolean isValidEmail(String email) {&#10;        // Basic email validation regex pattern&#10;        String emailRegex = &quot;^[a-zA-Z0-9_+&amp;*-]+(?:\\.[a-zA-Z0-9_+&amp;*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$&quot;;&#10;        return email != null &amp;&amp; email.matches(emailRegex);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.AuthService;&#10;import zeta.foods.utils.DatabaseUtil;&#10;&#10;import java.sql.*;&#10;import java.util.Scanner;&#10;&#10;public class PostgresAuthServiceImpl implements AuthService {&#10;    private static final Logger logger = LoggerFactory.getLogger(PostgresAuthServiceImpl.class);&#10;&#10;    @Override&#10;    public User authenticateUser(String email, String password) {&#10;        // Log authentication attempt but mask password for security&#10;        logger.info(&quot;Attempting to authenticate user: '{}'&quot;, email);&#10;        logger.info(&quot;Password length: {}, Password value: '{}'&quot;, password != null ? password.length() : &quot;null&quot;, password);&#10;&#10;        // Print each character code to check for hidden/special characters&#10;        if (password != null) {&#10;            StringBuilder charCodes = new StringBuilder(&quot;Password char codes: &quot;);&#10;            for (char c : password.toCharArray()) {&#10;                charCodes.append((int)c).append(&quot;,&quot;);&#10;            }&#10;            logger.info(charCodes.toString());&#10;        }&#10;&#10;        // Debug: directly check if user exists with this exact email and password&#10;        try (Connection debugConn = DatabaseUtil.getConnection();&#10;             Statement debugStmt = debugConn.createStatement()) {&#10;&#10;            // First get all users matching the email only&#10;            String emailOnlyQuery = &quot;SELECT * FROM users WHERE email = '&quot; + email + &quot;'&quot;;&#10;            try (ResultSet emailRs = debugStmt.executeQuery(emailOnlyQuery)) {&#10;                if (emailRs.next()) {&#10;                    String dbEmail = emailRs.getString(&quot;email&quot;);&#10;                    String dbPassword = emailRs.getString(&quot;password&quot;);&#10;&#10;                    logger.info(&quot;Found user with email: '{}', DB password: '{}'&quot;, dbEmail, dbPassword);&#10;                    logger.info(&quot;Password length from DB: {}&quot;, dbPassword.length());&#10;&#10;                    // Print each character code of DB password&#10;                    StringBuilder dbCharCodes = new StringBuilder(&quot;DB Password char codes: &quot;);&#10;                    for (char c : dbPassword.toCharArray()) {&#10;                        dbCharCodes.append((int)c).append(&quot;,&quot;);&#10;                    }&#10;                    logger.info(dbCharCodes.toString());&#10;&#10;                    // Direct character-by-character comparison&#10;                    logger.info(&quot;Direct password comparison result: {}&quot;, dbPassword.equals(password));&#10;&#10;                    if (!dbPassword.equals(password)) {&#10;                        logger.info(&quot;Password mismatch details:&quot;);&#10;                        if (dbPassword.length() != password.length()) {&#10;                            logger.info(&quot;Length differs: DB={}, Input={}&quot;, dbPassword.length(), password.length());&#10;                        } else {&#10;                            for (int i = 0; i &lt; dbPassword.length(); i++) {&#10;                                if (dbPassword.charAt(i) != password.charAt(i)) {&#10;                                    logger.info(&quot;Mismatch at position {}: DB='{}' ({}), Input='{}' ({})&quot;,&#10;                                        i, dbPassword.charAt(i), (int)dbPassword.charAt(i),&#10;                                        password.charAt(i), (int)password.charAt(i));&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                } else {&#10;                    logger.warn(&quot;No user found with email: '{}'&quot;, email);&#10;                }&#10;            }&#10;&#10;            // Now try the full authentication query&#10;            String debugQuery = &quot;SELECT * FROM users WHERE email = '&quot; + email + &quot;' AND password = '&quot; + password + &quot;'&quot;;&#10;//            String debugQuery = &quot;SELECT * FROM users WHERE email = 'ambatisaiteja123@gmail.com' AND password = 'admin123'&quot;;&#10;            logger.info(&quot;Executing direct query: {}&quot;, debugQuery);&#10;&#10;&#10;            try (ResultSet debugRs = debugStmt.executeQuery(debugQuery)) {&#10;                if (debugRs.next()) {&#10;                    logger.info(&quot;DEBUG - Direct query found matching user!&quot;);&#10;                } else {&#10;                    logger.warn(&quot;DEBUG - Direct query found NO matching user!&quot;);&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;DEBUG - Error in diagnostic queries: {}&quot;, e.getMessage());&#10;        }&#10;&#10;        String sql = &quot;SELECT * FROM users WHERE email = ? AND password = ?&quot;;&#10;&#10;        logger.info(&quot;Preparing to execute authentication query for email: {}, password: {}&quot;, email, password);&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, email);&#10;            stmt.setString(2, password);&#10;            logger.debug(&quot;Executing authentication query for email: {}&quot;, email);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    User user = new User();&#10;                    user.setId(rs.getLong(&quot;id&quot;));&#10;                    user.setUsername(rs.getString(&quot;username&quot;));&#10;                    user.setEmail(rs.getString(&quot;email&quot;));&#10;                    user.setRole(rs.getString(&quot;role&quot;));&#10;&#10;                    // Update last login time&#10;                    updateLastLogin(user.getId());&#10;&#10;                    logger.info(&quot;User authenticated successfully: {}&quot;, email);&#10;                    return user;&#10;                } else {&#10;                    logger.warn(&quot;No user found with email: {} and provided password&quot;, email);&#10;                }&#10;            }&#10;&#10;            logger.warn(&quot;Authentication failed for user: {}&quot;, email);&#10;            return null;&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error during authentication: {}&quot;, e.getMessage(), e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Interactive console login method that handles the scanner input directly&#10;     * This is useful when running in Docker or other environments where&#10;     * standard input handling might be tricky&#10;     */&#10;    public User consoleLogin() {&#10;        // Use System.console() if available, otherwise fall back to Scanner&#10;        User authenticatedUser = null;&#10;        int attempts = 0;&#10;        final int MAX_ATTEMPTS = 3;&#10;&#10;        // Print a visual separator to make the prompt more visible&#10;        System.out.println(&quot;\n*************************************&quot;);&#10;        System.out.println(&quot;*          WELCOME                  *&quot;);&#10;        System.out.println(&quot;*************************************\n&quot;);&#10;        System.out.println(&quot;1. Login&quot;);&#10;        System.out.println(&quot;2. Sign Up (New Customer)&quot;);&#10;        System.out.println(&quot;0. Exit&quot;);&#10;        System.out.print(&quot;\nSelect an option: &quot;);&#10;        &#10;        Scanner scanner = new Scanner(System.in);&#10;        String option = scanner.nextLine().trim();&#10;        &#10;        switch (option) {&#10;            case &quot;1&quot;:&#10;                // Login process&#10;                while (attempts &lt; MAX_ATTEMPTS &amp;&amp; authenticatedUser == null) {&#10;                    try {&#10;                        String email = null;&#10;                        String password = null;&#10;&#10;                        // Try to use console if available (better for password input)&#10;                        if (System.console() != null) {&#10;                            System.out.print(&quot;\nEnter email: &quot;);&#10;                            email = System.console().readLine();&#10;                            System.out.print(&quot;Enter password: &quot;);&#10;                            password = new String(System.console().readLine());&#10;                        } else {&#10;                            // Fall back to Scanner with flush to ensure prompt is visible&#10;                            System.out.print(&quot;\nEnter email: &quot;);&#10;                            System.out.flush();&#10;                            email = scanner.nextLine().trim();&#10;&#10;                            System.out.print(&quot;Enter password: &quot;);&#10;                            System.out.flush();&#10;                            password = scanner.nextLine().trim();&#10;                        }&#10;&#10;                        if (email == null || email.isEmpty()) {&#10;                            System.out.println(&quot;Email cannot be empty. Please try again.&quot;);&#10;                            continue;&#10;                        }&#10;&#10;                        // Handle special commands&#10;                        if (&quot;exit&quot;.equalsIgnoreCase(email)) {&#10;                            logger.info(&quot;Login process aborted by user&quot;);&#10;                            break;&#10;                        } else if (&quot;simulate&quot;.equalsIgnoreCase(email)) {&#10;                            logger.info(&quot;Simulation requested from console login&quot;);&#10;                            return null; // Special case to trigger simulation&#10;                        }&#10;&#10;                        // Use the provided credentials&#10;                        authenticatedUser = authenticateUser(email, password);&#10;&#10;                        // Handle authentication result&#10;                        if (authenticatedUser == null) {&#10;                            attempts++;&#10;                            logger.warn(&quot;Login failed. Attempt {} of {}&quot;, attempts, MAX_ATTEMPTS);&#10;                            if (attempts &lt; MAX_ATTEMPTS) {&#10;                                System.out.println(&quot;Invalid email or password. Please try again.&quot;);&#10;                            }&#10;                        } else {&#10;                            System.out.println(&quot;\nWelcome, &quot; + authenticatedUser.getUsername() + &quot;!&quot;);&#10;                            System.out.println(&quot;You are logged in as: &quot; + authenticatedUser.getRole());&#10;                            displayMenuForRole(authenticatedUser.getRole());&#10;                        }&#10;                    } catch (Exception e) {&#10;                        logger.error(&quot;Error during console login: {}&quot;, e.getMessage(), e);&#10;                        System.out.println(&quot;An error occurred. Please try again.&quot;);&#10;                        attempts++;&#10;                    }&#10;                }&#10;&#10;                if (authenticatedUser == null &amp;&amp; attempts &gt;= MAX_ATTEMPTS) {&#10;                    System.out.println(&quot;Maximum login attempts exceeded. Please try again later.&quot;);&#10;                }&#10;                break;&#10;                &#10;            case &quot;2&quot;:&#10;                // Sign up process&#10;                authenticatedUser = consoleSignup(scanner);&#10;                if (authenticatedUser != null) {&#10;                    System.out.println(&quot;\nWelcome, &quot; + authenticatedUser.getUsername() + &quot;!&quot;);&#10;                    System.out.println(&quot;You are logged in as: &quot; + authenticatedUser.getRole());&#10;                    displayMenuForRole(authenticatedUser.getRole());&#10;                }&#10;                break;&#10;                &#10;            case &quot;0&quot;:&#10;                logger.info(&quot;User chose to exit&quot;);&#10;                break;&#10;                &#10;            default:&#10;                System.out.println(&quot;Invalid option. Please try again.&quot;);&#10;        }&#10;&#10;        return authenticatedUser;&#10;    }&#10;    &#10;    /**&#10;     * Interactive console signup method for new customers&#10;     * &#10;     * @param scanner Scanner for reading user input&#10;     * @return The newly created and authenticated User object, or null if signup failed&#10;     */&#10;    private User consoleSignup(Scanner scanner) {&#10;        System.out.println(&quot;\n*************************************&quot;);&#10;        System.out.println(&quot;*          NEW CUSTOMER SIGNUP      *&quot;);&#10;        System.out.println(&quot;*************************************\n&quot;);&#10;        &#10;        try {&#10;            // Get username&#10;            System.out.print(&quot;Enter your name: &quot;);&#10;            String username = scanner.nextLine().trim();&#10;            if (username.isEmpty()) {&#10;                System.out.println(&quot;Name cannot be empty.&quot;);&#10;                return null;&#10;            }&#10;            &#10;            // Get and validate email&#10;            String email = &quot;&quot;;&#10;            boolean validEmail = false;&#10;            while (!validEmail) {&#10;                System.out.print(&quot;Enter your email: &quot;);&#10;                email = scanner.nextLine().trim();&#10;                &#10;                if (email.isEmpty()) {&#10;                    System.out.println(&quot;Email cannot be empty.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                if (!isValidEmail(email)) {&#10;                    System.out.println(&quot;Invalid email format. Please enter a valid email address.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                if (userExists(email)) {&#10;                    System.out.println(&quot;This email is already registered. Please use another email or log in.&quot;);&#10;                    return null;&#10;                }&#10;                &#10;                validEmail = true;&#10;            }&#10;            &#10;            // Get and validate password&#10;            String password = &quot;&quot;;&#10;            String confirmPassword = &quot;&quot;;&#10;            boolean validPassword = false;&#10;            while (!validPassword) {&#10;                System.out.print(&quot;Enter password (minimum 6 characters): &quot;);&#10;                password = scanner.nextLine().trim();&#10;                &#10;                if (password.length() &lt; 6) {&#10;                    System.out.println(&quot;Password must be at least 6 characters long.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                System.out.print(&quot;Confirm password: &quot;);&#10;                confirmPassword = scanner.nextLine().trim();&#10;                &#10;                if (!password.equals(confirmPassword)) {&#10;                    System.out.println(&quot;Passwords do not match. Please try again.&quot;);&#10;                    continue;&#10;                }&#10;                &#10;                validPassword = true;&#10;            }&#10;            &#10;            // Register the new user&#10;            User newUser = registerUser(username, email, password, &quot;customer&quot;);&#10;            &#10;            if (newUser != null) {&#10;                System.out.println(&quot;\nRegistration successful! Your account has been created.&quot;);&#10;                return newUser;&#10;            } else {&#10;                System.out.println(&quot;\nRegistration failed. Please try again later.&quot;);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error during console signup: {}&quot;, e.getMessage(), e);&#10;            System.out.println(&quot;An error occurred during registration. Please try again later.&quot;);&#10;        }&#10;        &#10;        return null;&#10;    }&#10;    &#10;    /**&#10;     * Display appropriate menu based on user role&#10;     */&#10;    private void displayMenuForRole(String role) {&#10;        System.out.println(&quot;\n=== &quot; + role.toUpperCase() + &quot; MENU ===&quot;);&#10;&#10;        switch (role.toLowerCase()) {&#10;            case &quot;admin&quot;:&#10;                System.out.println(&quot;1. Manage Users&quot;);&#10;                System.out.println(&quot;2. View System Reports&quot;);&#10;                System.out.println(&quot;3. Fetch Current Inventory&quot;);&#10;                System.out.println(&quot;4. Restore Current Inventory&quot;);&#10;                System.out.println(&quot;5. Manage Menu Items&quot;);&#10;                break;&#10;&#10;            case &quot;waiter&quot;:&#10;                System.out.println(&quot;1. Take New Order&quot;);&#10;                System.out.println(&quot;0. Logout&quot;);&#10;                break;&#10;&#10;            case &quot;customer&quot;:&#10;                System.out.println(&quot;1. View Menu&quot;);&#10;                System.out.println(&quot;2. Place Order&quot;);&#10;                System.out.println(&quot;3. View Order Status&quot;);&#10;                break;&#10;&#10;            default:&#10;                System.out.println(&quot;No specific menu available for this role.&quot;);&#10;        }&#10;&#10;        System.out.println(&quot;0. Logout&quot;);&#10;        System.out.print(&quot;\nPlease enter your choice: &quot;);&#10;    }&#10;&#10;    @Override&#10;    public boolean isAdmin(String email) {&#10;        return checkUserRole(email, &quot;admin&quot;);&#10;    }&#10;&#10;    @Override&#10;    public boolean isWaiter(String email) {&#10;        return checkUserRole(email, &quot;waiter&quot;);&#10;    }&#10;&#10;    private boolean checkUserRole(String email, String role) {&#10;        String sql = &quot;SELECT role FROM users WHERE email = ?&quot;;&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setString(1, email);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                return rs.next() &amp;&amp; role.equals(rs.getString(&quot;role&quot;));&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error checking user role: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User createUser(String username, String email, String password, String role) {&#10;        String sql = &quot;INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?) RETURNING id&quot;;&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            // Store the password as plain text&#10;            stmt.setString(1, username);&#10;            stmt.setString(2, email);&#10;            stmt.setString(3, password);&#10;            stmt.setString(4, role);&#10;&#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    User user = new User();&#10;                    user.setId(rs.getLong(&quot;id&quot;));&#10;                    user.setUsername(username);&#10;                    user.setEmail(email);&#10;                    user.setRole(role);&#10;&#10;                    logger.info(&quot;Created new user: {} with role: {}&quot;, email, role);&#10;                    return user;&#10;                }&#10;            }&#10;&#10;            return null;&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error creating user: {}&quot;, e.getMessage(), e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean updateLastLogin(Long userId) {&#10;        String sql = &quot;UPDATE users SET last_login = NOW() WHERE id = ?&quot;;&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;&#10;            stmt.setLong(1, userId);&#10;            int rowsAffected = stmt.executeUpdate();&#10;&#10;            return rowsAffected &gt; 0;&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error updating last login: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Register a new user in the system&#10;     * &#10;     * @param username The username for the new user&#10;     * @param email The email address for the new user&#10;     * @param password The password for the new user&#10;     * @param role The role of the new user (usually &quot;customer&quot; for new registrations)&#10;     * @return The newly created User object, or null if registration failed&#10;     */&#10;    public User registerUser(String username, String email, String password, String role) {&#10;        logger.info(&quot;Attempting to register new user with email: {}&quot;, email);&#10;        &#10;        // Validate email format using regex&#10;        if (!isValidEmail(email)) {&#10;            logger.warn(&quot;Invalid email format: {}&quot;, email);&#10;            return null;&#10;        }&#10;        &#10;        // Check if user already exists&#10;        if (userExists(email)) {&#10;            logger.warn(&quot;User with email {} already exists&quot;, email);&#10;            return null;&#10;        }&#10;        &#10;        String sql = &quot;INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?) RETURNING id&quot;;&#10;        &#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;            &#10;            stmt.setString(1, username);&#10;            stmt.setString(2, email);&#10;            stmt.setString(3, password);&#10;            stmt.setString(4, role);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    // Create and return the new user&#10;                    User newUser = new User();&#10;                    newUser.setId(rs.getLong(&quot;id&quot;));&#10;                    newUser.setUsername(username);&#10;                    newUser.setEmail(email);&#10;                    newUser.setRole(role);&#10;                    &#10;                    logger.info(&quot;New user registered successfully: {}&quot;, email);&#10;                    return newUser;&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Database error during user registration: {}&quot;, e.getMessage(), e);&#10;        }&#10;        &#10;        return null;&#10;    }&#10;    &#10;    /**&#10;     * Check if a user with the given email already exists&#10;     * &#10;     * @param email The email to check&#10;     * @return true if the user exists, false otherwise&#10;     */&#10;    private boolean userExists(String email) {&#10;        String sql = &quot;SELECT COUNT(*) FROM users WHERE email = ?&quot;;&#10;        &#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql)) {&#10;            &#10;            stmt.setString(1, email);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getInt(1) &gt; 0;&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error checking if user exists: {}&quot;, e.getMessage(), e);&#10;        }&#10;        &#10;        return false;&#10;    }&#10;    &#10;    /**&#10;     * Validate email format using regex&#10;     * &#10;     * @param email The email to validate&#10;     * @return true if the email is valid, false otherwise&#10;     */&#10;    private boolean isValidEmail(String email) {&#10;        // Basic email validation regex pattern&#10;        String emailRegex = &quot;^[a-zA-Z0-9_+&amp;*-]+(?:\\.[a-zA-Z0-9_+&amp;*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$&quot;;&#10;        return email != null &amp;&amp; email.matches(emailRegex);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/WaiterServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/service/impl/WaiterServiceImpl.java" />
              <option name="originalContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.Table;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.WaiterService;&#10;import zeta.foods.utils.CurrentInventory;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;&#10;/**&#10; * Implementation of the WaiterService interface&#10; */&#10;public class WaiterServiceImpl implements WaiterService {&#10;    private static final Logger logger = LoggerFactory.getLogger(WaiterServiceImpl.class);&#10;    private final CustomerServiceImpl customerService = new CustomerServiceImpl();&#10;&#10;    /**&#10;     * Take a new order for a customer&#10;     * @param scanner Scanner for user input&#10;     * @return The newly created order&#10;     */&#10;    @Override&#10;    public Order takeNewOrder(Scanner scanner) {&#10;        logger.info(&quot;Taking a new order&quot;);&#10;        System.out.println(&quot;\n=== Take New Order ===&quot;);&#10;&#10;        System.out.println(&quot;Enter customer details or assign to a table:&quot;);&#10;        System.out.print(&quot;Customer name: &quot;);&#10;        String customerName = scanner.nextLine().trim();&#10;&#10;        // Create a temporary user for the customer&#10;        User tempCustomer = new User();&#10;        tempCustomer.setUsername(customerName);&#10;        tempCustomer.setRole(&quot;customer&quot;);&#10;&#10;        // Use existing customer service to handle the order placement&#10;        Order order = customerService.placeOrder(tempCustomer);&#10;        System.out.println(&quot;Order created! Order ID: &quot; + order.getOrderId());&#10;&#10;        // Now handle order items&#10;        boolean addingItems = true;&#10;&#10;        while (addingItems) {&#10;            // Display menu categories&#10;            System.out.println(&quot;\nMenu Categories:&quot;);&#10;            TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;            String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;            for (int i = 0; i &lt; categories.length; i++) {&#10;                System.out.printf(&quot;%d. %s\n&quot;, i + 1, categories[i]);&#10;            }&#10;&#10;            System.out.print(&quot;\nSelect category (0 to finish order): &quot;);&#10;            String categoryInput = scanner.nextLine().trim();&#10;&#10;            if (&quot;0&quot;.equals(categoryInput)) {&#10;                addingItems = false;&#10;                continue;&#10;            }&#10;&#10;            try {&#10;                int categoryIndex = Integer.parseInt(categoryInput) - 1;&#10;                if (categoryIndex &lt; 0 || categoryIndex &gt;= categories.length) {&#10;                    System.out.println(&quot;Invalid category selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedCategory = categories[categoryIndex];&#10;                Map&lt;String, String&gt; items = menu.getCategoryItems(selectedCategory);&#10;&#10;                // Display items in the selected category&#10;                System.out.println(&quot;\n--- &quot; + selectedCategory + &quot; ---&quot;);&#10;                String[] itemNames = items.keySet().toArray(new String[0]);&#10;                for (int i = 0; i &lt; itemNames.length; i++) {&#10;                    System.out.printf(&quot;%d. %s - %s\n&quot;, i + 1, itemNames[i], items.get(itemNames[i]));&#10;                }&#10;&#10;                System.out.print(&quot;\nSelect item (0 to go back): &quot;);&#10;                String itemInput = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(itemInput)) {&#10;                    continue;&#10;                }&#10;&#10;                int itemIndex = Integer.parseInt(itemInput) - 1;&#10;                if (itemIndex &lt; 0 || itemIndex &gt;= itemNames.length) {&#10;                    System.out.println(&quot;Invalid item selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedItem = itemNames[itemIndex];&#10;&#10;                System.out.print(&quot;Enter quantity: &quot;);&#10;                int quantity = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (quantity &lt;= 0) {&#10;                    System.out.println(&quot;Quantity must be greater than zero.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Add item to order&#10;                boolean success = customerService.addItemToOrder(order.getOrderId(), selectedCategory, selectedItem, quantity);&#10;                if (success) {&#10;                    System.out.println(quantity + &quot; x &quot; + selectedItem + &quot; added to the order.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Failed to add item to order.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Check if order has items&#10;        if (order.getItems().isEmpty()) {&#10;            System.out.println(&quot;Order cancelled - no items added.&quot;);&#10;            return null;&#10;        }&#10;&#10;        // Generate and display bill&#10;        System.out.println(&quot;\nGenerating bill...&quot;);&#10;        String bill = customerService.generateBill(order.getOrderId());&#10;        System.out.println(bill);&#10;&#10;        System.out.println(&quot;Order has been placed successfully!&quot;);&#10;&#10;        // Associate the order with a table&#10;        assignOrderToTable(order, scanner);&#10;&#10;        return order;&#10;    }&#10;&#10;    /**&#10;     * Get all tables with their current status&#10;     * @return List of tables with occupation status&#10;     */&#10;    @Override&#10;    public List&lt;Table&gt; getAllTables() {&#10;        logger.info(&quot;Retrieving all tables&quot;);&#10;        List&lt;Table&gt; tables = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&#10;                     &quot;SELECT * FROM tables ORDER BY table_number&quot;)) {&#10;&#10;            while (rs.next()) {&#10;                Table table = new Table();&#10;                table.setTableNumber(rs.getInt(&quot;table_number&quot;));&#10;                table.setOccupied(rs.getBoolean(&quot;is_occupied&quot;));&#10;                table.setServed(rs.getBoolean(&quot;is_served&quot;));&#10;&#10;                // Convert SQL timestamp to LocalDateTime if not null&#10;                Timestamp startTime = rs.getTimestamp(&quot;booking_start_time&quot;);&#10;                if (startTime != null) {&#10;                    table.setBookingStartTime(startTime.toLocalDateTime());&#10;                }&#10;&#10;                Timestamp endTime = rs.getTimestamp(&quot;booking_end_time&quot;);&#10;                if (endTime != null) {&#10;                    table.setBookingEndTime(endTime.toLocalDateTime());&#10;                }&#10;&#10;                tables.add(table);&#10;            }&#10;&#10;            logger.info(&quot;Retrieved {} tables from database&quot;, tables.size());&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error retrieving tables: {}&quot;, e.getMessage(), e);&#10;&#10;            // If no tables exist yet, create a default set&#10;            if (tables.isEmpty()) {&#10;                logger.info(&quot;No tables found in database, initializing default tables&quot;);&#10;                for (int i = 1; i &lt;= 10; i++) {&#10;                    createTable(i);&#10;                    tables.add(new Table(i));&#10;                }&#10;            }&#10;        }&#10;&#10;        return tables;&#10;    }&#10;&#10;    /**&#10;     * Assign an order to a table&#10;     * @param order The order to assign&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private void assignOrderToTable(Order order, Scanner scanner) {&#10;        System.out.println(&quot;\nAssign order to a table:&quot;);&#10;&#10;        // Display available tables&#10;        List&lt;Table&gt; tables = getAllTables();&#10;        List&lt;Table&gt; availableTables = new ArrayList&lt;&gt;();&#10;&#10;        System.out.println(&quot;\nAvailable Tables:&quot;);&#10;        for (Table table : tables) {&#10;            if (!table.isOccupied()) {&#10;                availableTables.add(table);&#10;                System.out.println(table.toString());&#10;            }&#10;        }&#10;&#10;        if (availableTables.isEmpty()) {&#10;            System.out.println(&quot;No tables are currently available. Creating a new table.&quot;);&#10;            // Create a new table with the next number&#10;            int nextTableNumber = tables.isEmpty() ? 1 : tables.size() + 1;&#10;            Table newTable = createTable(nextTableNumber);&#10;            availableTables.add(newTable);&#10;            System.out.println(newTable.toString());&#10;        }&#10;&#10;        int tableNumber;&#10;        while (true) {&#10;            System.out.print(&quot;Enter table number: &quot;);&#10;            try {&#10;                tableNumber = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                // Check if the table exists and is available&#10;                boolean tableValid = false;&#10;                for (Table table : availableTables) {&#10;                    if (table.getTableNumber() == tableNumber) {&#10;                        tableValid = true;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (tableValid) {&#10;                    break;&#10;                } else {&#10;                    System.out.println(&quot;Invalid or occupied table number. Please select an available table.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid table number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Occupy the table and link to the order&#10;        occupyTable(tableNumber, order.getOrderId());&#10;        System.out.println(&quot;Order #&quot; + order.getOrderId() + &quot; has been assigned to Table #&quot; + tableNumber);&#10;    }&#10;&#10;    /**&#10;     * Create a new table in the database&#10;     * @param tableNumber The table number&#10;     * @return The created table object&#10;     */&#10;    private Table createTable(int tableNumber) {&#10;        logger.info(&quot;Creating new table with number: {}&quot;, tableNumber);&#10;        Table table = new Table(tableNumber);&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(&#10;                     &quot;INSERT INTO tables (table_number, is_occupied, is_served) VALUES (?, ?, ?) &quot; +&#10;                             &quot;ON CONFLICT (table_number) DO NOTHING&quot;)) {&#10;&#10;            stmt.setInt(1, tableNumber);&#10;            stmt.setBoolean(2, false);&#10;            stmt.setBoolean(3, false);&#10;            stmt.executeUpdate();&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error creating table: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return table;&#10;    }&#10;&#10;    /**&#10;     * Occupy a table and associate it with an order&#10;     * @param tableNumber The table number to occupy&#10;     * @param orderId The order ID to associate with the table&#10;     */&#10;    private void occupyTable(int tableNumber, String orderId) {&#10;        logger.info(&quot;Occupying table #{} for order ID: {}&quot;, tableNumber, orderId);&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First update the table status&#10;            try (PreparedStatement stmt = conn.prepareStatement(&#10;                    &quot;UPDATE tables SET is_occupied = true, is_served = false, booking_start_time = NOW() &quot; +&#10;                            &quot;WHERE table_number = ?&quot;)) {&#10;&#10;                stmt.setInt(1, tableNumber);&#10;                stmt.executeUpdate();&#10;            }&#10;&#10;            // Then get the table ID&#10;            int tableId;&#10;            try (PreparedStatement stmt = conn.prepareStatement(&#10;                    &quot;SELECT id FROM tables WHERE table_number = ?&quot;)) {&#10;&#10;                stmt.setInt(1, tableNumber);&#10;                ResultSet rs = stmt.executeQuery();&#10;&#10;                if (rs.next()) {&#10;                    tableId = rs.getInt(&quot;id&quot;);&#10;&#10;                    // Associate table with order&#10;                    try (PreparedStatement linkStmt = conn.prepareStatement(&#10;                            &quot;INSERT INTO order_tables (order_id, table_id) VALUES (?, ?)&quot;)) {&#10;&#10;                        linkStmt.setString(1, orderId);  // Changed from setLong to setString&#10;                        linkStmt.setInt(2, tableId);&#10;                        linkStmt.executeUpdate();&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error occupying table: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.service.impl;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.Order;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.Table;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.WaiterService;&#10;import zeta.foods.utils.CurrentInventory;&#10;import zeta.foods.utils.DatabaseUtil;&#10;import zeta.foods.utils.menu;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;&#10;/**&#10; * Implementation of the WaiterService interface&#10; */&#10;public class WaiterServiceImpl implements WaiterService {&#10;    private static final Logger logger = LoggerFactory.getLogger(WaiterServiceImpl.class);&#10;    private final CustomerServiceImpl customerService = new CustomerServiceImpl();&#10;&#10;    /**&#10;     * Take a new order for a customer&#10;     * @param scanner Scanner for user input&#10;     * @return The newly created order&#10;     */&#10;    @Override&#10;    public Order takeNewOrder(Scanner scanner) {&#10;        logger.info(&quot;Taking a new order&quot;);&#10;        System.out.println(&quot;\n=== Take New Order ===&quot;);&#10;&#10;        System.out.println(&quot;Enter customer details or assign to a table:&quot;);&#10;        System.out.print(&quot;Customer name: &quot;);&#10;        String customerName = scanner.nextLine().trim();&#10;&#10;        // Create a temporary user for the customer&#10;        User tempCustomer = new User();&#10;        tempCustomer.setUsername(customerName);&#10;        tempCustomer.setRole(&quot;customer&quot;);&#10;&#10;        // Use existing customer service to handle the order placement&#10;        Order order = customerService.placeOrder(tempCustomer);&#10;        System.out.println(&quot;Order created! Order ID: &quot; + order.getOrderId());&#10;&#10;        // Now handle order items&#10;        boolean addingItems = true;&#10;&#10;        while (addingItems) {&#10;            // Display menu categories&#10;            System.out.println(&quot;\nMenu Categories:&quot;);&#10;            TreeMap&lt;String, Map&lt;String, String&gt;&gt; menuItems = menu.menuItems;&#10;            String[] categories = menuItems.keySet().toArray(new String[0]);&#10;&#10;            for (int i = 0; i &lt; categories.length; i++) {&#10;                System.out.printf(&quot;%d. %s\n&quot;, i + 1, categories[i]);&#10;            }&#10;&#10;            System.out.print(&quot;\nSelect category (0 to finish order): &quot;);&#10;            String categoryInput = scanner.nextLine().trim();&#10;&#10;            if (&quot;0&quot;.equals(categoryInput)) {&#10;                addingItems = false;&#10;                continue;&#10;            }&#10;&#10;            try {&#10;                int categoryIndex = Integer.parseInt(categoryInput) - 1;&#10;                if (categoryIndex &lt; 0 || categoryIndex &gt;= categories.length) {&#10;                    System.out.println(&quot;Invalid category selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedCategory = categories[categoryIndex];&#10;                Map&lt;String, String&gt; items = menu.getCategoryItems(selectedCategory);&#10;&#10;                // Display items in the selected category&#10;                System.out.println(&quot;\n--- &quot; + selectedCategory + &quot; ---&quot;);&#10;                String[] itemNames = items.keySet().toArray(new String[0]);&#10;                for (int i = 0; i &lt; itemNames.length; i++) {&#10;                    System.out.printf(&quot;%d. %s - %s\n&quot;, i + 1, itemNames[i], items.get(itemNames[i]));&#10;                }&#10;&#10;                System.out.print(&quot;\nSelect item (0 to go back): &quot;);&#10;                String itemInput = scanner.nextLine().trim();&#10;&#10;                if (&quot;0&quot;.equals(itemInput)) {&#10;                    continue;&#10;                }&#10;&#10;                int itemIndex = Integer.parseInt(itemInput) - 1;&#10;                if (itemIndex &lt; 0 || itemIndex &gt;= itemNames.length) {&#10;                    System.out.println(&quot;Invalid item selection.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                String selectedItem = itemNames[itemIndex];&#10;&#10;                System.out.print(&quot;Enter quantity: &quot;);&#10;                int quantity = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                if (quantity &lt;= 0) {&#10;                    System.out.println(&quot;Quantity must be greater than zero.&quot;);&#10;                    continue;&#10;                }&#10;&#10;                // Add item to order&#10;                boolean success = customerService.addItemToOrder(order.getOrderId(), selectedCategory, selectedItem, quantity);&#10;                if (success) {&#10;                    System.out.println(quantity + &quot; x &quot; + selectedItem + &quot; added to the order.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Failed to add item to order.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Check if order has items&#10;        if (order.getItems().isEmpty()) {&#10;            System.out.println(&quot;Order cancelled - no items added.&quot;);&#10;            return null;&#10;        }&#10;&#10;        // Generate and display bill&#10;        System.out.println(&quot;\nGenerating bill...&quot;);&#10;        String bill = customerService.generateBill(order.getOrderId());&#10;        System.out.println(bill);&#10;&#10;        System.out.println(&quot;Order has been placed successfully!&quot;);&#10;&#10;        // Associate the order with a table&#10;        assignOrderToTable(order, scanner);&#10;&#10;        return order;&#10;    }&#10;&#10;    /**&#10;     * Get all tables with their current status&#10;     * @return List of tables with occupation status&#10;     */&#10;    @Override&#10;    public List&lt;Table&gt; getAllTables() {&#10;        logger.info(&quot;Retrieving all tables&quot;);&#10;        List&lt;Table&gt; tables = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             Statement stmt = conn.createStatement();&#10;             ResultSet rs = stmt.executeQuery(&#10;                     &quot;SELECT * FROM tables ORDER BY table_number&quot;)) {&#10;&#10;            while (rs.next()) {&#10;                Table table = new Table();&#10;                table.setTableNumber(rs.getInt(&quot;table_number&quot;));&#10;                table.setOccupied(rs.getBoolean(&quot;is_occupied&quot;));&#10;                table.setServed(rs.getBoolean(&quot;is_served&quot;));&#10;&#10;                // Convert SQL timestamp to LocalDateTime if not null&#10;                Timestamp startTime = rs.getTimestamp(&quot;booking_start_time&quot;);&#10;                if (startTime != null) {&#10;                    table.setBookingStartTime(startTime.toLocalDateTime());&#10;                }&#10;&#10;                Timestamp endTime = rs.getTimestamp(&quot;booking_end_time&quot;);&#10;                if (endTime != null) {&#10;                    table.setBookingEndTime(endTime.toLocalDateTime());&#10;                }&#10;&#10;                tables.add(table);&#10;            }&#10;&#10;            logger.info(&quot;Retrieved {} tables from database&quot;, tables.size());&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error retrieving tables: {}&quot;, e.getMessage(), e);&#10;&#10;            // If no tables exist yet, create a default set&#10;            if (tables.isEmpty()) {&#10;                logger.info(&quot;No tables found in database, initializing default tables&quot;);&#10;                for (int i = 1; i &lt;= 10; i++) {&#10;                    createTable(i);&#10;                    tables.add(new Table(i));&#10;                }&#10;            }&#10;        }&#10;&#10;        return tables;&#10;    }&#10;&#10;    /**&#10;     * Assign an order to a table&#10;     * @param order The order to assign&#10;     * @param scanner Scanner for user input&#10;     */&#10;    private void assignOrderToTable(Order order, Scanner scanner) {&#10;        System.out.println(&quot;\nAssign order to a table:&quot;);&#10;&#10;        // Display available tables&#10;        List&lt;Table&gt; tables = getAllTables();&#10;        List&lt;Table&gt; availableTables = new ArrayList&lt;&gt;();&#10;&#10;        System.out.println(&quot;\nAvailable Tables:&quot;);&#10;        for (Table table : tables) {&#10;            if (!table.isOccupied()) {&#10;                availableTables.add(table);&#10;                System.out.println(table.toString());&#10;            }&#10;        }&#10;&#10;        if (availableTables.isEmpty()) {&#10;            System.out.println(&quot;No tables are currently available. Creating a new table.&quot;);&#10;            // Create a new table with the next number&#10;            int nextTableNumber = tables.isEmpty() ? 1 : tables.size() + 1;&#10;            Table newTable = createTable(nextTableNumber);&#10;            availableTables.add(newTable);&#10;            System.out.println(newTable.toString());&#10;        }&#10;&#10;        int tableNumber;&#10;        while (true) {&#10;            System.out.print(&quot;Enter table number: &quot;);&#10;            try {&#10;                tableNumber = Integer.parseInt(scanner.nextLine().trim());&#10;&#10;                // Check if the table exists and is available&#10;                boolean tableValid = false;&#10;                for (Table table : availableTables) {&#10;                    if (table.getTableNumber() == tableNumber) {&#10;                        tableValid = true;&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (tableValid) {&#10;                    break;&#10;                } else {&#10;                    System.out.println(&quot;Invalid or occupied table number. Please select an available table.&quot;);&#10;                }&#10;&#10;            } catch (NumberFormatException e) {&#10;                System.out.println(&quot;Please enter a valid table number.&quot;);&#10;            }&#10;        }&#10;&#10;        // Occupy the table and link to the order&#10;        occupyTable(tableNumber, order.getOrderId());&#10;        System.out.println(&quot;Order #&quot; + order.getOrderId() + &quot; has been assigned to Table #&quot; + tableNumber);&#10;    }&#10;&#10;    /**&#10;     * Create a new table in the database&#10;     * @param tableNumber The table number&#10;     * @return The created table object&#10;     */&#10;    private Table createTable(int tableNumber) {&#10;        logger.info(&quot;Creating new table with number: {}&quot;, tableNumber);&#10;        Table table = new Table(tableNumber);&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(&#10;                     &quot;INSERT INTO tables (table_number, is_occupied, is_served) VALUES (?, ?, ?) &quot; +&#10;                             &quot;ON CONFLICT (table_number) DO NOTHING&quot;)) {&#10;&#10;            stmt.setInt(1, tableNumber);&#10;            stmt.setBoolean(2, false);&#10;            stmt.setBoolean(3, false);&#10;            stmt.executeUpdate();&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error creating table: {}&quot;, e.getMessage(), e);&#10;        }&#10;&#10;        return table;&#10;    }&#10;&#10;    /**&#10;     * Occupy a table and associate it with an order&#10;     * @param tableNumber The table number to occupy&#10;     * @param orderId The order ID to associate with the table&#10;     */&#10;    private void occupyTable(int tableNumber, String orderId) {&#10;        logger.info(&quot;Occupying table #{} for order ID: {}&quot;, tableNumber, orderId);&#10;&#10;        try (Connection conn = DatabaseUtil.getConnection()) {&#10;            // First update the table status&#10;            try (PreparedStatement stmt = conn.prepareStatement(&#10;                    &quot;UPDATE tables SET is_occupied = true, is_served = false, booking_start_time = NOW() &quot; +&#10;                            &quot;WHERE table_number = ?&quot;)) {&#10;&#10;                stmt.setInt(1, tableNumber);&#10;                stmt.executeUpdate();&#10;            }&#10;&#10;            // Then get the table ID&#10;            int tableId;&#10;            try (PreparedStatement stmt = conn.prepareStatement(&#10;                    &quot;SELECT id FROM tables WHERE table_number = ?&quot;)) {&#10;&#10;                stmt.setInt(1, tableNumber);&#10;                ResultSet rs = stmt.executeQuery();&#10;&#10;                if (rs.next()) {&#10;                    tableId = rs.getInt(&quot;id&quot;);&#10;&#10;                    // Associate table with order&#10;                    try (PreparedStatement linkStmt = conn.prepareStatement(&#10;                            &quot;INSERT INTO order_tables (order_id, table_id) VALUES (?, ?)&quot;)) {&#10;&#10;                        linkStmt.setString(1, orderId);  // Changed from setLong to setString&#10;                        linkStmt.setInt(2, tableId);&#10;                        linkStmt.executeUpdate();&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error occupying table: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all tables that are occupied but not yet served&#10;     * @return List of unserved tables&#10;     */&#10;    @Override&#10;    public List&lt;Table&gt; getUnservedTables() {&#10;        logger.info(&quot;Retrieving unserved tables&quot;);&#10;        List&lt;Table&gt; unservedTables = new ArrayList&lt;&gt;();&#10;        &#10;        try (Connection conn = DatabaseUtil.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(&#10;                     &quot;SELECT * FROM tables WHERE is_occupied = true AND is_served = false ORDER BY table_number&quot;)) {&#10;                     &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    Table table = new Table();&#10;                    table.setTableNumber(rs.getInt(&quot;table_number&quot;));&#10;                    table.setOccupied(rs.getBoolean(&quot;is_occupied&quot;));&#10;                    table.setServed(rs.getBoolean(&quot;is_served&quot;));&#10;                    &#10;                    // Convert SQL timestamp to LocalDateTime if not null&#10;                    Timestamp startTime = rs.getTimestamp(&quot;booking_start_time&quot;);&#10;                    if (startTime != null) {&#10;                        table.setBookingStartTime(startTime.toLocalDateTime());&#10;                    }&#10;                    &#10;                    Timestamp endTime = rs.getTimestamp(&quot;booking_end_time&quot;);&#10;                    if (endTime != null) {&#10;                        table.setBookingEndTime(endTime.toLocalDateTime());&#10;                    }&#10;                    &#10;                    unservedTables.add(table);&#10;                }&#10;            }&#10;            &#10;            logger.info(&quot;Retrieved {} unserved tables from database&quot;, unservedTables.size());&#10;            &#10;        } catch (SQLException e) {&#10;            logger.error(&quot;Error retrieving unserved tables: {}&quot;, e.getMessage(), e);&#10;        }&#10;        &#10;        return unservedTables;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/simulation/AuthSimulation.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/simulation/AuthSimulation.java" />
              <option name="updatedContent" value="package zeta.foods.simulation;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.User;&#10;import zeta.foods.service.AuthService;&#10;import zeta.foods.service.impl.PostgresAuthServiceImpl;&#10;&#10;/**&#10; * A simulation tool for testing the authentication system&#10; * without requiring manual input.&#10; */&#10;public class AuthSimulation {&#10;    private static final Logger logger = LoggerFactory.getLogger(AuthSimulation.class);&#10;    private final AuthService authService;&#10;&#10;    public AuthSimulation(AuthService authService) {&#10;        this.authService = authService;&#10;    }&#10;&#10;    /**&#10;     * Run a simulation to test user login with different account types.&#10;     */&#10;    public void runLoginSimulation() {&#10;        logger.info(&quot;=== Starting Authentication Simulation ===&quot;);&#10;        &#10;        // Test admin login&#10;        logger.info(&quot;Testing admin login...&quot;);&#10;        testLogin(&quot;ambatisaiteja123@gmail.com&quot;, &quot;admin123&quot;, &quot;Admin&quot;);&#10;        &#10;        // Test waiter login&#10;        logger.info(&quot;Testing waiter login...&quot;);&#10;        testLogin(&quot;waiter1@restaurant.com&quot;, &quot;12345678&quot;, &quot;Waiter&quot;);&#10;        &#10;        // Test customer login&#10;        logger.info(&quot;Testing customer login...&quot;);&#10;        testLogin(&quot;customer1@example.com&quot;, &quot;12345678&quot;, &quot;Customer&quot;);&#10;        &#10;        // Test invalid login&#10;        logger.info(&quot;Testing invalid login...&quot;);&#10;        testLogin(&quot;nonexistent@example.com&quot;, &quot;wrongpassword&quot;, &quot;Invalid User&quot;);&#10;        &#10;        logger.info(&quot;=== Authentication Simulation Completed ===&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Helper method to test a specific login&#10;     */&#10;    private void testLogin(String email, String password, String userType) {&#10;        logger.info(&quot;Attempting to log in as {}: {}&quot;, userType, email);&#10;        User user = authService.authenticateUser(email, password);&#10;        &#10;        if (user != null) {&#10;            logger.info(&quot; Login successful for {}&quot;, userType);&#10;            logger.info(&quot;User details - ID: {}, Username: {}, Role: {}&quot;, &#10;                    user.getId(), user.getUsername(), user.getRole());&#10;            &#10;            // Display appropriate menu based on user role&#10;            if (user.isAdmin()) {&#10;                displayAdminMenu();&#10;            } else if (user.isWaiter()) {&#10;                displayWaiterMenu();&#10;            } else {&#10;                displayCustomerMenu();&#10;            }&#10;            &#10;            logger.info(&quot;Session ended for {}&quot;, userType);&#10;        } else {&#10;            logger.info(&quot; Login failed for {} with email: {}&quot;, userType, email);&#10;        }&#10;        &#10;        logger.info(&quot;-----------------------------------&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Display admin menu options&#10;     */&#10;    private void displayAdminMenu() {&#10;        logger.info(&quot; ADMIN MENU:&quot;);&#10;        logger.info(&quot;1. Manage Users&quot;);&#10;        logger.info(&quot;2. View System Reports&quot;);&#10;        logger.info(&quot;3. Update Inventory&quot;);&#10;        logger.info(&quot;4. Manage Menu Items&quot;);&#10;        logger.info(&quot;5. Exit&quot;);&#10;        &#10;        // Simulate admin selecting an option&#10;        logger.info(&quot;Admin selected: View System Reports&quot;);&#10;        logger.info(&quot;Generating reports...&quot;);&#10;        logger.info(&quot;Total Orders: 243&quot;);&#10;        logger.info(&quot;Revenue: $5,678.90&quot;);&#10;        logger.info(&quot;Popular Items: Pasta Carbonara, Chicken Parmesan&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Display waiter menu options&#10;     */&#10;    private void displayWaiterMenu() {&#10;        logger.info(&quot; WAITER MENU:&quot;);&#10;        logger.info(&quot;1. Take New Order&quot;);&#10;        logger.info(&quot;2. View Table Status&quot;);&#10;        logger.info(&quot;3. Process Payment&quot;);&#10;        logger.info(&quot;4. Exit&quot;);&#10;        &#10;        // Simulate waiter selecting an option&#10;        logger.info(&quot;Waiter selected: View Table Status&quot;);&#10;        logger.info(&quot;Table 1: Occupied (4 guests) - Order in progress&quot;);&#10;        logger.info(&quot;Table 2: Available&quot;);&#10;        logger.info(&quot;Table 3: Reserved (19:00)&quot;);&#10;        logger.info(&quot;Table 4: Occupied (2 guests) - Waiting for food&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Display customer menu options&#10;     */&#10;    private void displayCustomerMenu() {&#10;        logger.info(&quot; CUSTOMER MENU:&quot;);&#10;        logger.info(&quot;1. View Menu&quot;);&#10;        logger.info(&quot;2. Place Order&quot;);&#10;        logger.info(&quot;3. View Order Status&quot;);&#10;        logger.info(&quot;4. Exit&quot;);&#10;        &#10;        // Simulate customer selecting an option&#10;        logger.info(&quot;Customer selected: View Menu&quot;);&#10;        logger.info(&quot;APPETIZERS:&quot;);&#10;        logger.info(&quot;- Garlic Bread ($4.99)&quot;);&#10;        logger.info(&quot;- Calamari ($8.99)&quot;);&#10;        logger.info(&quot;MAIN COURSES:&quot;);&#10;        logger.info(&quot;- Pasta Carbonara ($14.99)&quot;);&#10;        logger.info(&quot;- Grilled Salmon ($19.99)&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/utils/CurrentInventory.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/utils/CurrentInventory.java" />
              <option name="originalContent" value="package zeta.foods.utils;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.Recipe;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.time.LocalDate;&#10;import java.time.format.DateTimeFormatter;&#10;import java.time.format.DateTimeParseException;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Manages the current inventory with date-based validation and tracking&#10; */&#10;public class CurrentInventory {&#10;    private static final Logger logger = LoggerFactory.getLogger(CurrentInventory.class);&#10;&#10;    // Map for storing current inventory&#10;    private static Map&lt;String, Integer&gt; currentInventory = new HashMap&lt;&gt;();&#10;&#10;    // File paths&#10;    private static final String CURRENT_INVENTORY_FILE_PATH = &quot;src/main/resources/CurrentInventory.txt&quot;;&#10;    private static final String INVENTORY_FILE_PATH = &quot;src/main/resources/inventory.txt&quot;;&#10;&#10;    // Date format&#10;    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;&#10;    // Static block to initialize current inventory on class load&#10;    static {&#10;        initializeCurrentInventory();&#10;    }&#10;&#10;    /**&#10;     * Initialize the current inventory, validating the date and updating if necessary&#10;     */&#10;    public static void initializeCurrentInventory() {&#10;        logger.info(&quot;Initializing current inventory...&quot;);&#10;&#10;        // Check if the current inventory file exists and if date is current&#10;        if (!isCurrentInventoryUpToDate()) {&#10;            logger.info(&quot;Current inventory is not up to date or doesn't exist. Refreshing from main inventory.&quot;);&#10;            refreshCurrentInventoryFromMain();&#10;        } else {&#10;            logger.info(&quot;Current inventory is up to date. Loading from CurrentInventory.txt&quot;);&#10;            loadCurrentInventory();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if the current inventory file exists and has today's date&#10;     * @return true if the file exists and the date matches today, false otherwise&#10;     */&#10;    private static boolean isCurrentInventoryUpToDate() {&#10;        try {&#10;            File file = new File(CURRENT_INVENTORY_FILE_PATH);&#10;            if (!file.exists()) {&#10;                logger.info(&quot;CurrentInventory.txt doesn't exist.&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Read the first line to get the date&#10;            List&lt;String&gt; lines = Files.readAllLines(Paths.get(CURRENT_INVENTORY_FILE_PATH), StandardCharsets.UTF_8);&#10;            if (lines.isEmpty()) {&#10;                logger.warn(&quot;CurrentInventory.txt is empty.&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Parse the date from the first line&#10;            String dateString = lines.get(0);&#10;            LocalDate fileDate;&#10;            try {&#10;                fileDate = LocalDate.parse(dateString, DATE_FORMAT);&#10;            } catch (DateTimeParseException e) {&#10;                logger.warn(&quot;Invalid date format in CurrentInventory.txt: {}&quot;, dateString);&#10;                return false;&#10;            }&#10;&#10;            // Compare with today's date&#10;            LocalDate today = LocalDate.now();&#10;            return fileDate.equals(today);&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error checking current inventory file: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load the current inventory from CurrentInventory.txt&#10;     */&#10;    private static void loadCurrentInventory() {&#10;        logger.info(&quot;Loading current inventory from file...&quot;);&#10;        currentInventory.clear();&#10;&#10;        try {&#10;            List&lt;String&gt; lines = Files.readAllLines(Paths.get(CURRENT_INVENTORY_FILE_PATH), StandardCharsets.UTF_8);&#10;&#10;            // Skip first two lines (date and empty line)&#10;            if (lines.size() &lt;= 2) {&#10;                logger.warn(&quot;CurrentInventory.txt doesn't contain ingredient data.&quot;);&#10;                return;&#10;            }&#10;&#10;            for (int i = 2; i &lt; lines.size(); i++) {&#10;                String line = lines.get(i).trim();&#10;                if (line.isEmpty()) continue;&#10;&#10;                String[] parts = line.split(&quot;-&quot;);&#10;                if (parts.length == 2) {&#10;                    String ingredient = parts[0].trim();&#10;                    try {&#10;                        int quantity = Integer.parseInt(parts[1].trim());&#10;                        currentInventory.put(ingredient, quantity);&#10;                        logger.debug(&quot;Loaded current inventory item: {} - {}&quot;, ingredient, quantity);&#10;                    } catch (NumberFormatException e) {&#10;                        logger.error(&quot;Invalid quantity format for ingredient: {}&quot;, parts[0]);&#10;                    }&#10;                }&#10;            }&#10;&#10;            logger.info(&quot;Current inventory loaded successfully with {} ingredients&quot;, currentInventory.size());&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error loading current inventory from file: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh the current inventory from the main inventory.txt file&#10;     */&#10;    private static void refreshCurrentInventoryFromMain() {&#10;        logger.info(&quot;Refreshing current inventory from main inventory...&quot;);&#10;        currentInventory.clear();&#10;&#10;        try {&#10;            // First, load from the main inventory file&#10;            try (InputStream is = CurrentInventory.class.getClassLoader().getResourceAsStream(&quot;inventory.txt&quot;);&#10;                 BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {&#10;&#10;                String line;&#10;                while ((line = reader.readLine()) != null) {&#10;                    line = line.trim();&#10;                    if (line.isEmpty()) continue;&#10;&#10;                    String[] parts = line.split(&quot;-&quot;);&#10;                    if (parts.length == 2) {&#10;                        String ingredient = parts[0].trim();&#10;                        try {&#10;                            int quantity = Integer.parseInt(parts[1].trim());&#10;                            currentInventory.put(ingredient, quantity);&#10;                        } catch (NumberFormatException e) {&#10;                            logger.error(&quot;Invalid quantity in inventory.txt for: {}&quot;, parts[0]);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Then, save the current inventory with today's date&#10;            saveCurrentInventory();&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error refreshing current inventory: {}&quot;, e.getMessage(), e);&#10;        } catch (NullPointerException e) {&#10;            logger.error(&quot;Inventory file not found&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Save the current inventory to the CurrentInventory.txt file&#10;     */&#10;    public static void saveCurrentInventory() {&#10;        logger.info(&quot;Saving current inventory to file...&quot;);&#10;&#10;        try (FileWriter writer = new FileWriter(CURRENT_INVENTORY_FILE_PATH);&#10;             BufferedWriter bufferedWriter = new BufferedWriter(writer)) {&#10;&#10;            // Write today's date as the first line&#10;            bufferedWriter.write(LocalDate.now().format(DATE_FORMAT));&#10;            bufferedWriter.newLine();&#10;&#10;            // Write an empty line as the second line&#10;            bufferedWriter.newLine();&#10;&#10;            // Write all inventory items alphabetically&#10;            currentInventory.entrySet().stream()&#10;                    .sorted(Map.Entry.comparingByKey())&#10;                    .forEach(entry -&gt; {&#10;                        try {&#10;                            bufferedWriter.write(entry.getKey() + &quot; - &quot; + entry.getValue());&#10;                            bufferedWriter.newLine();&#10;                        } catch (IOException e) {&#10;                            logger.error(&quot;Error writing ingredient to file: {}&quot;, entry.getKey(), e);&#10;                        }&#10;                    });&#10;&#10;            logger.info(&quot;Current inventory successfully saved with {} ingredients&quot;, currentInventory.size());&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error saving current inventory to file: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the quantity of an ingredient in the current inventory&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @return The quantity or 0 if not found&#10;     */&#10;    public static int getQuantity(String ingredient) {&#10;        return currentInventory.getOrDefault(ingredient, 0);&#10;    }&#10;&#10;    /**&#10;     * Update the quantity of an ingredient in the current inventory&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @param newQuantity The new quantity&#10;     */&#10;    public static void updateQuantity(String ingredient, int newQuantity) {&#10;        if (newQuantity &gt;= 0) {&#10;            currentInventory.put(ingredient, newQuantity);&#10;            logger.info(&quot;Updated current quantity for {}: {}&quot;, ingredient, newQuantity);&#10;            // Save changes to file after each update&#10;            saveCurrentInventory();&#10;        } else {&#10;            logger.warn(&quot;Attempted to set negative quantity for {}: {}&quot;, ingredient, newQuantity);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if there are enough ingredients for an order&#10;     *&#10;     * @param orderItems List of order items to check&#10;     * @return true if there are sufficient ingredients, false otherwise&#10;     */&#10;    public static boolean checkIngredientsAvailability(List&lt;OrderItem&gt; orderItems) {&#10;        logger.info(&quot;Checking ingredient availability for order with {} items&quot;, orderItems.size());&#10;&#10;        // Create a map to track required ingredients and quantities&#10;        Map&lt;String, Integer&gt; requiredIngredients = new HashMap&lt;&gt;();&#10;&#10;        // Calculate required ingredients&#10;        for (OrderItem item : orderItems) {&#10;            String dishName = item.getItemName();&#10;            int quantity = item.getQuantity();&#10;&#10;            // Get recipe for this dish&#10;            Recipe recipe = recipes.getRecipe(dishName);&#10;            if (recipe == null) {&#10;                logger.warn(&quot;No recipe found for dish: {}&quot;, dishName);&#10;                return false;&#10;            }&#10;&#10;            // Add up required ingredients&#10;            for (Map.Entry&lt;String, Integer&gt; entry : recipe.getIngredients().entrySet()) {&#10;                String ingredient = entry.getKey();&#10;                int amountNeeded = entry.getValue() * quantity;&#10;&#10;                requiredIngredients.merge(ingredient, amountNeeded, Integer::sum);&#10;            }&#10;        }&#10;&#10;        // Check if we have enough of each ingredient&#10;        for (Map.Entry&lt;String, Integer&gt; entry : requiredIngredients.entrySet()) {&#10;            String ingredient = entry.getKey();&#10;            int required = entry.getValue();&#10;            int available = getQuantity(ingredient);&#10;&#10;            if (available &lt; required) {&#10;                logger.warn(&quot;Insufficient quantity of {}: required {}, available {}&quot;,&#10;                        ingredient, required, available);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        logger.info(&quot;All ingredients available for the order&quot;);&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Use ingredients for an order&#10;     *&#10;     * @param orderItems List of order items to prepare&#10;     * @return true if ingredients were successfully used, false otherwise&#10;     */&#10;    public static boolean useIngredientsForOrder(List&lt;OrderItem&gt; orderItems) {&#10;        // First check if we have enough ingredients&#10;        if (!checkIngredientsAvailability(orderItems)) {&#10;            return false;&#10;        }&#10;&#10;        logger.info(&quot;Using ingredients for order with {} items&quot;, orderItems.size());&#10;&#10;        // Create a map to track required ingredients and quantities&#10;        Map&lt;String, Integer&gt; requiredIngredients = new HashMap&lt;&gt;();&#10;&#10;        // Calculate required ingredients&#10;        for (OrderItem item : orderItems) {&#10;            String dishName = item.getItemName();&#10;            int quantity = item.getQuantity();&#10;&#10;            // Get recipe for this dish&#10;            Recipe recipe = recipes.getRecipe(dishName);&#10;            if (recipe == null) {&#10;                logger.warn(&quot;No recipe found for dish: {}&quot;, dishName);&#10;                return false;&#10;            }&#10;&#10;            // Add up required ingredients&#10;            for (Map.Entry&lt;String, Integer&gt; entry : recipe.getIngredients().entrySet()) {&#10;                String ingredient = entry.getKey();&#10;                int amountNeeded = entry.getValue() * quantity;&#10;&#10;                requiredIngredients.merge(ingredient, amountNeeded, Integer::sum);&#10;            }&#10;        }&#10;&#10;        // Deduct ingredients from inventory&#10;        for (Map.Entry&lt;String, Integer&gt; entry : requiredIngredients.entrySet()) {&#10;            String ingredient = entry.getKey();&#10;            int required = entry.getValue();&#10;            int available = getQuantity(ingredient);&#10;&#10;            updateQuantity(ingredient, available - required);&#10;        }&#10;&#10;        // Save changes to file&#10;        saveCurrentInventory();&#10;&#10;        logger.info(&quot;Ingredients successfully used for the order&quot;);&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Display the current inventory to the console&#10;     */&#10;    public static void displayCurrentInventory() {&#10;        System.out.println(&quot;\n======== Current Inventory ========&quot;);&#10;        System.out.println(&quot;Date: &quot; + LocalDate.now().format(DATE_FORMAT));&#10;        System.out.println(String.format(&quot;%-25s %10s&quot;, &quot;Ingredient&quot;, &quot;Quantity&quot;));&#10;        System.out.println(&quot;------------------------------------&quot;);&#10;&#10;        currentInventory.entrySet().stream()&#10;                .sorted(Map.Entry.comparingByKey())&#10;                .forEach(entry -&gt;&#10;                        System.out.println(String.format(&quot;%-25s %10d&quot;, entry.getKey(), entry.getValue())));&#10;&#10;        System.out.println(&quot;====================================\n&quot;);&#10;    }&#10;&#10;    /**&#10;     * Reset the current inventory to match the main inventory&#10;     */&#10;    public static void resetCurrentInventory() {&#10;        logger.info(&quot;Resetting current inventory to main inventory values&quot;);&#10;        refreshCurrentInventoryFromMain();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.utils;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import zeta.foods.model.OrderItem;&#10;import zeta.foods.model.Recipe;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.time.LocalDate;&#10;import java.time.format.DateTimeFormatter;&#10;import java.time.format.DateTimeParseException;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * Manages the current inventory with date-based validation and tracking&#10; */&#10;public class CurrentInventory {&#10;    private static final Logger logger = LoggerFactory.getLogger(CurrentInventory.class);&#10;&#10;    // Map for storing current inventory&#10;    private static Map&lt;String, Integer&gt; currentInventory = new HashMap&lt;&gt;();&#10;&#10;    // File paths&#10;    private static final String USER_HOME = System.getProperty(&quot;user.home&quot;);&#10;    private static final String DATA_DIR = USER_HOME + File.separator + &quot;restaurant_data&quot;;&#10;    private static final String CURRENT_INVENTORY_FILE_PATH = DATA_DIR + File.separator + &quot;CurrentInventory.txt&quot;;&#10;    &#10;    // Source resource path for initial data&#10;    private static final String INVENTORY_RESOURCE_PATH = &quot;inventory.txt&quot;;&#10;&#10;    // Date format&#10;    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;&#10;    // Static block to initialize current inventory on class load&#10;    static {&#10;        // Create data directory if it doesn't exist&#10;        createDataDirectory();&#10;        initializeCurrentInventory();&#10;    }&#10;    &#10;    /**&#10;     * Create data directory if it doesn't exist&#10;     */&#10;    private static void createDataDirectory() {&#10;        File dataDir = new File(DATA_DIR);&#10;        if (!dataDir.exists()) {&#10;            if (dataDir.mkdirs()) {&#10;                logger.info(&quot;Created data directory at: {}&quot;, DATA_DIR);&#10;            } else {&#10;                logger.error(&quot;Failed to create data directory at: {}&quot;, DATA_DIR);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Initialize the current inventory, validating the date and updating if necessary&#10;     */&#10;    public static void initializeCurrentInventory() {&#10;        logger.info(&quot;Initializing current inventory...&quot;);&#10;&#10;        // Check if the current inventory file exists and if date is current&#10;        if (!isCurrentInventoryUpToDate()) {&#10;            logger.info(&quot;Current inventory is not up to date or doesn't exist. Refreshing from main inventory.&quot;);&#10;            refreshCurrentInventoryFromMain();&#10;        } else {&#10;            logger.info(&quot;Current inventory is up to date. Loading from CurrentInventory.txt&quot;);&#10;            loadCurrentInventory();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if the current inventory file exists and has today's date&#10;     * @return true if the file exists and the date matches today, false otherwise&#10;     */&#10;    private static boolean isCurrentInventoryUpToDate() {&#10;        try {&#10;            File file = new File(CURRENT_INVENTORY_FILE_PATH);&#10;            if (!file.exists()) {&#10;                logger.info(&quot;CurrentInventory.txt doesn't exist at path: {}&quot;, CURRENT_INVENTORY_FILE_PATH);&#10;                return false;&#10;            }&#10;&#10;            // Read the first line to get the date&#10;            List&lt;String&gt; lines = Files.readAllLines(Paths.get(CURRENT_INVENTORY_FILE_PATH), StandardCharsets.UTF_8);&#10;            if (lines.isEmpty()) {&#10;                logger.warn(&quot;CurrentInventory.txt is empty.&quot;);&#10;                return false;&#10;            }&#10;&#10;            // Parse the date from the first line&#10;            String dateString = lines.get(0);&#10;            LocalDate fileDate;&#10;            try {&#10;                fileDate = LocalDate.parse(dateString, DATE_FORMAT);&#10;            } catch (DateTimeParseException e) {&#10;                logger.warn(&quot;Invalid date format in CurrentInventory.txt: {}&quot;, dateString);&#10;                return false;&#10;            }&#10;&#10;            // Compare with today's date&#10;            LocalDate today = LocalDate.now();&#10;            return fileDate.equals(today);&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error checking current inventory file: {}&quot;, e.getMessage(), e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load the current inventory from CurrentInventory.txt&#10;     */&#10;    private static void loadCurrentInventory() {&#10;        logger.info(&quot;Loading current inventory from file: {}&quot;, CURRENT_INVENTORY_FILE_PATH);&#10;        currentInventory.clear();&#10;&#10;        try {&#10;            List&lt;String&gt; lines = Files.readAllLines(Paths.get(CURRENT_INVENTORY_FILE_PATH), StandardCharsets.UTF_8);&#10;&#10;            // Skip first two lines (date and empty line)&#10;            if (lines.size() &lt;= 2) {&#10;                logger.warn(&quot;CurrentInventory.txt doesn't contain ingredient data.&quot;);&#10;                return;&#10;            }&#10;&#10;            for (int i = 2; i &lt; lines.size(); i++) {&#10;                String line = lines.get(i).trim();&#10;                if (line.isEmpty()) continue;&#10;&#10;                String[] parts = line.split(&quot;-&quot;);&#10;                if (parts.length == 2) {&#10;                    String ingredient = parts[0].trim();&#10;                    try {&#10;                        int quantity = Integer.parseInt(parts[1].trim());&#10;                        currentInventory.put(ingredient, quantity);&#10;                        logger.debug(&quot;Loaded current inventory item: {} - {}&quot;, ingredient, quantity);&#10;                    } catch (NumberFormatException e) {&#10;                        logger.error(&quot;Invalid quantity format for ingredient: {}&quot;, parts[0]);&#10;                    }&#10;                }&#10;            }&#10;&#10;            logger.info(&quot;Current inventory loaded successfully with {} ingredients&quot;, currentInventory.size());&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error loading current inventory from file: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refresh the current inventory from the main inventory.txt file&#10;     */&#10;    private static void refreshCurrentInventoryFromMain() {&#10;        logger.info(&quot;Refreshing current inventory from main inventory...&quot;);&#10;        currentInventory.clear();&#10;&#10;        try {&#10;            // First, load from the main inventory resource file&#10;            try (InputStream is = CurrentInventory.class.getClassLoader().getResourceAsStream(INVENTORY_RESOURCE_PATH);&#10;                 BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {&#10;&#10;                String line;&#10;                while ((line = reader.readLine()) != null) {&#10;                    line = line.trim();&#10;                    if (line.isEmpty()) continue;&#10;&#10;                    String[] parts = line.split(&quot;-&quot;);&#10;                    if (parts.length == 2) {&#10;                        String ingredient = parts[0].trim();&#10;                        try {&#10;                            int quantity = Integer.parseInt(parts[1].trim());&#10;                            currentInventory.put(ingredient, quantity);&#10;                        } catch (NumberFormatException e) {&#10;                            logger.error(&quot;Invalid quantity in inventory.txt for: {}&quot;, parts[0]);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Then, save the current inventory with today's date&#10;            saveCurrentInventory();&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error refreshing current inventory: {}&quot;, e.getMessage(), e);&#10;        } catch (NullPointerException e) {&#10;            logger.error(&quot;Inventory resource file not found: {}&quot;, INVENTORY_RESOURCE_PATH, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Save the current inventory to the CurrentInventory.txt file&#10;     */&#10;    public static void saveCurrentInventory() {&#10;        logger.info(&quot;Saving current inventory to file: {}&quot;, CURRENT_INVENTORY_FILE_PATH);&#10;&#10;        try (FileWriter writer = new FileWriter(CURRENT_INVENTORY_FILE_PATH);&#10;             BufferedWriter bufferedWriter = new BufferedWriter(writer)) {&#10;&#10;            // Write today's date as the first line&#10;            bufferedWriter.write(LocalDate.now().format(DATE_FORMAT));&#10;            bufferedWriter.newLine();&#10;&#10;            // Write an empty line as the second line&#10;            bufferedWriter.newLine();&#10;&#10;            // Write all inventory items alphabetically&#10;            currentInventory.entrySet().stream()&#10;                    .sorted(Map.Entry.comparingByKey())&#10;                    .forEach(entry -&gt; {&#10;                        try {&#10;                            bufferedWriter.write(entry.getKey() + &quot; - &quot; + entry.getValue());&#10;                            bufferedWriter.newLine();&#10;                        } catch (IOException e) {&#10;                            logger.error(&quot;Error writing ingredient to file: {}&quot;, entry.getKey(), e);&#10;                        }&#10;                    });&#10;&#10;            logger.info(&quot;Current inventory successfully saved with {} ingredients&quot;, currentInventory.size());&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error saving current inventory to file: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the quantity of an ingredient in the current inventory&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @return The quantity or 0 if not found&#10;     */&#10;    public static int getQuantity(String ingredient) {&#10;        return currentInventory.getOrDefault(ingredient, 0);&#10;    }&#10;&#10;    /**&#10;     * Update the quantity of an ingredient in the current inventory&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @param newQuantity The new quantity&#10;     */&#10;    public static void updateQuantity(String ingredient, int newQuantity) {&#10;        if (newQuantity &gt;= 0) {&#10;            currentInventory.put(ingredient, newQuantity);&#10;            logger.info(&quot;Updated current quantity for {}: {}&quot;, ingredient, newQuantity);&#10;            // Save changes to file after each update&#10;            saveCurrentInventory();&#10;        } else {&#10;            logger.warn(&quot;Attempted to set negative quantity for {}: {}&quot;, ingredient, newQuantity);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if there are enough ingredients for an order&#10;     *&#10;     * @param orderItems List of order items to check&#10;     * @return true if there are sufficient ingredients, false otherwise&#10;     */&#10;    public static boolean checkIngredientsAvailability(List&lt;OrderItem&gt; orderItems) {&#10;        logger.info(&quot;Checking ingredient availability for order with {} items&quot;, orderItems.size());&#10;&#10;        // Create a map to track required ingredients and quantities&#10;        Map&lt;String, Integer&gt; requiredIngredients = new HashMap&lt;&gt;();&#10;&#10;        // Calculate required ingredients&#10;        for (OrderItem item : orderItems) {&#10;            String dishName = item.getItemName();&#10;            int quantity = item.getQuantity();&#10;&#10;            // Get recipe for this dish&#10;            Recipe recipe = recipes.getRecipe(dishName);&#10;            if (recipe == null) {&#10;                logger.warn(&quot;No recipe found for dish: {}&quot;, dishName);&#10;                return false;&#10;            }&#10;&#10;            // Add up required ingredients&#10;            for (Map.Entry&lt;String, Integer&gt; entry : recipe.getIngredients().entrySet()) {&#10;                String ingredient = entry.getKey();&#10;                int amountNeeded = entry.getValue() * quantity;&#10;&#10;                requiredIngredients.merge(ingredient, amountNeeded, Integer::sum);&#10;            }&#10;        }&#10;&#10;        // Check if we have enough of each ingredient&#10;        for (Map.Entry&lt;String, Integer&gt; entry : requiredIngredients.entrySet()) {&#10;            String ingredient = entry.getKey();&#10;            int required = entry.getValue();&#10;            int available = getQuantity(ingredient);&#10;&#10;            if (available &lt; required) {&#10;                logger.warn(&quot;Insufficient quantity of {}: required {}, available {}&quot;,&#10;                        ingredient, required, available);&#10;                return false;&#10;            }&#10;        }&#10;&#10;        logger.info(&quot;All ingredients available for the order&quot;);&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Use ingredients for an order&#10;     *&#10;     * @param orderItems List of order items to prepare&#10;     * @return true if ingredients were successfully used, false otherwise&#10;     */&#10;    public static boolean useIngredientsForOrder(List&lt;OrderItem&gt; orderItems) {&#10;        // First check if we have enough ingredients&#10;        if (!checkIngredientsAvailability(orderItems)) {&#10;            return false;&#10;        }&#10;&#10;        logger.info(&quot;Using ingredients for order with {} items&quot;, orderItems.size());&#10;&#10;        // Create a map to track required ingredients and quantities&#10;        Map&lt;String, Integer&gt; requiredIngredients = new HashMap&lt;&gt;();&#10;&#10;        // Calculate required ingredients&#10;        for (OrderItem item : orderItems) {&#10;            String dishName = item.getItemName();&#10;            int quantity = item.getQuantity();&#10;&#10;            // Get recipe for this dish&#10;            Recipe recipe = recipes.getRecipe(dishName);&#10;            if (recipe == null) {&#10;                logger.warn(&quot;No recipe found for dish: {}&quot;, dishName);&#10;                return false;&#10;            }&#10;&#10;            // Add up required ingredients&#10;            for (Map.Entry&lt;String, Integer&gt; entry : recipe.getIngredients().entrySet()) {&#10;                String ingredient = entry.getKey();&#10;                int amountNeeded = entry.getValue() * quantity;&#10;&#10;                requiredIngredients.merge(ingredient, amountNeeded, Integer::sum);&#10;            }&#10;        }&#10;&#10;        // Deduct ingredients from inventory&#10;        for (Map.Entry&lt;String, Integer&gt; entry : requiredIngredients.entrySet()) {&#10;            String ingredient = entry.getKey();&#10;            int required = entry.getValue();&#10;            int available = getQuantity(ingredient);&#10;&#10;            updateQuantity(ingredient, available - required);&#10;        }&#10;&#10;        // Save changes to file&#10;        saveCurrentInventory();&#10;&#10;        logger.info(&quot;Ingredients successfully used for the order&quot;);&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Display the current inventory to the console&#10;     */&#10;    public static void displayCurrentInventory() {&#10;        System.out.println(&quot;\n======== Current Inventory ========&quot;);&#10;        System.out.println(&quot;Date: &quot; + LocalDate.now().format(DATE_FORMAT));&#10;        System.out.println(String.format(&quot;%-25s %10s&quot;, &quot;Ingredient&quot;, &quot;Quantity&quot;));&#10;        System.out.println(&quot;------------------------------------&quot;);&#10;&#10;        currentInventory.entrySet().stream()&#10;                .sorted(Map.Entry.comparingByKey())&#10;                .forEach(entry -&gt;&#10;                        System.out.println(String.format(&quot;%-25s %10d&quot;, entry.getKey(), entry.getValue())));&#10;&#10;        System.out.println(&quot;====================================\n&quot;);&#10;    }&#10;&#10;    /**&#10;     * Reset the current inventory to match the main inventory&#10;     */&#10;    public static void resetCurrentInventory() {&#10;        logger.info(&quot;Resetting current inventory to main inventory values&quot;);&#10;        refreshCurrentInventoryFromMain();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/utils/DatabaseUtil.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/utils/DatabaseUtil.java" />
              <option name="originalContent" value="package zeta.foods.utils;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.SQLException;&#10;&#10;public class DatabaseUtil {&#10;    private static final Logger logger = LoggerFactory.getLogger(DatabaseUtil.class);&#10;&#10;    private static final String DB_HOST = System.getenv().getOrDefault(&quot;DB_HOST&quot;, &quot;localhost&quot;);&#10;    private static final String DB_PORT = System.getenv().getOrDefault(&quot;DB_PORT&quot;, &quot;5432&quot;);&#10;    private static final String DB_NAME = System.getenv().getOrDefault(&quot;DB_NAME&quot;, &quot;restaurant_management&quot;);&#10;    private static final String DB_USER = System.getenv().getOrDefault(&quot;DB_USER&quot;, &quot;postgres&quot;);&#10;    private static final String DB_PASSWORD = System.getenv().getOrDefault(&quot;DB_PASSWORD&quot;, &quot;postgres&quot;);&#10;&#10;&#10;&#10;&#10;&#10;        if (connection == null || connection.isClosed()) {&#10;            try {&#10;                // Load PostgreSQL JDBC driver&#10;                Class.forName(&quot;org.postgresql.Driver&quot;);&#10;&#10;&#10;                    DB_USER,&#10;                    DB_PASSWORD&#10;                );&#10;&#10;                logger.info(&quot;Database connection established&quot;);&#10;            } catch (ClassNotFoundException e) {&#10;&#10;                throw new SQLException(&quot;Database driver not found&quot;, e);&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Failed to connect to database: {}&quot;, e.getMessage(), e);&#10;                throw e;&#10;            }&#10;        }&#10;&#10;        return connection;&#10;    }&#10;&#10;    public static void closeConnection() {&#10;        if (connection != null) {&#10;&#10;                connection.close();&#10;                logger.info(&quot;Database connection closed&quot;);&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Error closing database connection&quot;, e);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package zeta.foods.utils;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.SQLException;&#10;&#10;public class DatabaseUtil {&#10;    private static final Logger logger = LoggerFactory.getLogger(DatabaseUtil.class);&#10;    &#10;    private static final String DB_HOST = System.getenv().getOrDefault(&quot;DB_HOST&quot;, &quot;localhost&quot;);&#10;    private static final String DB_PORT = System.getenv().getOrDefault(&quot;DB_PORT&quot;, &quot;5432&quot;);&#10;    // Check for new database from migrations, otherwise use default&#10;    private static final String DB_NAME = System.getenv().getOrDefault(&quot;DB_NAME&quot;, &quot;restaurant_management_new&quot;);&#10;    private static final String DB_USER = System.getenv().getOrDefault(&quot;DB_USER&quot;, &quot;restaurant_user&quot;);&#10;    private static final String DB_PASSWORD = System.getenv().getOrDefault(&quot;DB_PASSWORD&quot;, &quot;restaurant_password&quot;);&#10;    &#10;    private static final String JDBC_URL = String.format(&quot;jdbc:postgresql://%s:%s/%s&quot;, DB_HOST, DB_PORT, DB_NAME);&#10;    &#10;    private static Connection connection = null;&#10;    &#10;    public static Connection getConnection() throws SQLException {&#10;        if (connection == null || connection.isClosed()) {&#10;            try {&#10;                // Load PostgreSQL JDBC driver&#10;                Class.forName(&quot;org.postgresql.Driver&quot;);&#10;                &#10;                logger.info(&quot;Connecting to database {} at {}:{}&quot;, DB_NAME, DB_HOST, DB_PORT);&#10;                &#10;                // Create connection&#10;                connection = DriverManager.getConnection(&#10;                    JDBC_URL,&#10;                    DB_USER,&#10;                    DB_PASSWORD&#10;                );&#10;                &#10;                logger.info(&quot;Database connection established&quot;);&#10;            } catch (ClassNotFoundException e) {&#10;                logger.error(&quot;PostgreSQL JDBC driver not found&quot;, e);&#10;                throw new SQLException(&quot;Database driver not found&quot;, e);&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Failed to connect to database: {}&quot;, e.getMessage(), e);&#10;                throw e;&#10;            }&#10;        }&#10;        &#10;        return connection;&#10;    }&#10;    &#10;    public static void closeConnection() {&#10;        if (connection != null) {&#10;            try {&#10;                connection.close();&#10;                logger.info(&quot;Database connection closed&quot;);&#10;            } catch (SQLException e) {&#10;                logger.error(&quot;Error closing database connection&quot;, e);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/zeta/foods/utils/Inventory.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/zeta/foods/utils/Inventory.java" />
              <option name="originalContent" value="package zeta.foods.utils;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Inventory {&#10;    public static Map &lt;String, Integer&gt; Inventory = new HashMap&lt;&gt;();&#10;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package zeta.foods.utils;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class Inventory {&#10;    private static final Logger logger = LoggerFactory.getLogger(Inventory.class);&#10;    public static Map&lt;String, Integer&gt; Inventory = new HashMap&lt;&gt;();&#10;    private static final String INVENTORY_FILE_PATH = &quot;src/main/resources/inventory.txt&quot;;&#10;&#10;    // Static block to load inventory on class initialization&#10;    static {&#10;        loadInventoryFromFile();&#10;    }&#10;&#10;    /**&#10;     * Loads inventory items from the inventory.txt file&#10;     */&#10;    public static void loadInventoryFromFile() {&#10;        logger.info(&quot;Loading inventory from file...&quot;);&#10;&#10;        try (InputStream is = Inventory.class.getClassLoader().getResourceAsStream(&quot;inventory.txt&quot;);&#10;             BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {&#10;&#10;            String line;&#10;            while ((line = reader.readLine()) != null) {&#10;                // Skip empty lines&#10;                if (line.trim().isEmpty()) {&#10;                    continue;&#10;                }&#10;&#10;                // Split the line by hyphen and trim whitespace&#10;                String[] parts = line.split(&quot;-&quot;);&#10;                if (parts.length == 2) {&#10;                    String ingredient = parts[0].trim();&#10;                    try {&#10;                        int quantity = Integer.parseInt(parts[1].trim());&#10;                        Inventory.put(ingredient, quantity);&#10;                        logger.debug(&quot;Loaded ingredient: {} - {}&quot;, ingredient, quantity);&#10;                    } catch (NumberFormatException e) {&#10;                        logger.error(&quot;Invalid quantity format for ingredient: {}&quot;, parts[0]);&#10;                    }&#10;                } else {&#10;                    logger.warn(&quot;Invalid line format in inventory file: {}&quot;, line);&#10;                }&#10;            }&#10;&#10;            logger.info(&quot;Inventory loaded successfully with {} ingredients&quot;, Inventory.size());&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error loading inventory from file: {}&quot;, e.getMessage(), e);&#10;        } catch (NullPointerException e) {&#10;            logger.error(&quot;Inventory file not found&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Saves the current inventory state back to the inventory.txt file&#10;     */&#10;    public static void saveInventoryToFile() {&#10;        logger.info(&quot;Saving inventory to file...&quot;);&#10;&#10;        try (FileWriter writer = new FileWriter(INVENTORY_FILE_PATH);&#10;             BufferedWriter bufferedWriter = new BufferedWriter(writer)) {&#10;&#10;            // Sort ingredients alphabetically for consistent file structure&#10;            Inventory.entrySet().stream()&#10;                    .sorted(Map.Entry.comparingByKey())&#10;                    .forEach(entry -&gt; {&#10;                        try {&#10;                            bufferedWriter.write(entry.getKey() + &quot; - &quot; + entry.getValue());&#10;                            bufferedWriter.newLine();&#10;                        } catch (IOException e) {&#10;                            logger.error(&quot;Error writing ingredient to file: {}&quot;, entry.getKey(), e);&#10;                        }&#10;                    });&#10;&#10;            logger.info(&quot;Inventory successfully saved with {} ingredients&quot;, Inventory.size());&#10;&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error saving inventory to file: {}&quot;, e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the current quantity of an ingredient&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @return The quantity or 0 if not found&#10;     */&#10;    public static int getQuantity(String ingredient) {&#10;        return Inventory.getOrDefault(ingredient, 0);&#10;    }&#10;&#10;    /**&#10;     * Update the quantity of an ingredient&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @param newQuantity The new quantity&#10;     */&#10;    public static void updateQuantity(String ingredient, int newQuantity) {&#10;        if (newQuantity &gt;= 0) {&#10;            Inventory.put(ingredient, newQuantity);&#10;            logger.info(&quot;Updated quantity for {}: {}&quot;, ingredient, newQuantity);&#10;        } else {&#10;            logger.warn(&quot;Attempted to set negative quantity for {}: {}&quot;, ingredient, newQuantity);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reduce the quantity of an ingredient by a specific amount&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @param amount The amount to reduce&#10;     * @return true if successful, false if insufficient quantity&#10;     */&#10;    public static boolean useIngredient(String ingredient, int amount) {&#10;        int currentQuantity = getQuantity(ingredient);&#10;&#10;        if (currentQuantity &gt;= amount) {&#10;            updateQuantity(ingredient, currentQuantity - amount);&#10;            // Optionally save inventory after each use&#10;            // saveInventoryToFile();&#10;            return true;&#10;        } else {&#10;            logger.warn(&quot;Insufficient quantity of {} (requested: {}, available: {})&quot;,&#10;                    ingredient, amount, currentQuantity);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add a new ingredient to the inventory&#10;     *&#10;     * @param ingredient The ingredient name&#10;     * @param quantity The initial quantity&#10;     */&#10;    public static void addIngredient(String ingredient, int quantity) {&#10;        if (quantity &lt; 0) {&#10;            logger.warn(&quot;Cannot add ingredient with negative quantity: {} - {}&quot;, ingredient, quantity);&#10;            return;&#10;        }&#10;&#10;        Inventory.put(ingredient, quantity);&#10;        logger.info(&quot;Added new ingredient: {} - {}&quot;, ingredient, quantity);&#10;        // Optionally save inventory after adding ingredient&#10;        // saveInventoryToFile();&#10;    }&#10;&#10;    /**&#10;     * Save changes after multiple inventory operations&#10;     * Call this method after you've made several changes to the inventory&#10;     */&#10;    public static void saveChanges() {&#10;        saveInventoryToFile();&#10;    }&#10;&#10;    /**&#10;     * Print the current inventory to the console&#10;     */&#10;    public static void displayInventory() {&#10;        System.out.println(&quot;\n======== Current Inventory ========&quot;);&#10;        System.out.println(String.format(&quot;%-20s %10s&quot;, &quot;Ingredient&quot;, &quot;Quantity&quot;));&#10;        System.out.println(&quot;-----------------------------------&quot;);&#10;&#10;        Inventory.entrySet().stream()&#10;                .sorted(Map.Entry.comparingByKey())&#10;                .forEach(entry -&gt;&#10;                        System.out.println(String.format(&quot;%-20s %10d&quot;, entry.getKey(), entry.getValue())));&#10;&#10;        System.out.println(&quot;===================================\n&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>